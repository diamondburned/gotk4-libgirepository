// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gio2_DBusInterfaceSkeleton_ConnectGAuthorizeMethod(gpointer, void*, guintptr);
import "C"

// GType values.
var (
	GTypeDBusInterfaceSkeleton = coreglib.Type(girepository.MustFind("Gio", "DBusInterfaceSkeleton").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDBusInterfaceSkeleton, F: marshalDBusInterfaceSkeleton},
	})
}

// DBusInterfaceSkeletonOverrides contains methods that are overridable.
type DBusInterfaceSkeletonOverrides struct {
}

func defaultDBusInterfaceSkeletonOverrides(v *DBusInterfaceSkeleton) DBusInterfaceSkeletonOverrides {
	return DBusInterfaceSkeletonOverrides{}
}

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DBusInterface
}

var (
	_ coreglib.Objector = (*DBusInterfaceSkeleton)(nil)
)

// DBusInterfaceSkeletonner describes types inherited from class DBusInterfaceSkeleton.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type DBusInterfaceSkeletonner interface {
	coreglib.Objector
	baseDBusInterfaceSkeleton() *DBusInterfaceSkeleton
}

var _ DBusInterfaceSkeletonner = (*DBusInterfaceSkeleton)(nil)

func init() {
	coreglib.RegisterClassInfo[*DBusInterfaceSkeleton, *DBusInterfaceSkeletonClass, DBusInterfaceSkeletonOverrides](
		GTypeDBusInterfaceSkeleton,
		initDBusInterfaceSkeletonClass,
		wrapDBusInterfaceSkeleton,
		defaultDBusInterfaceSkeletonOverrides,
	)
}

func initDBusInterfaceSkeletonClass(gclass unsafe.Pointer, overrides DBusInterfaceSkeletonOverrides, classInitFunc func(*DBusInterfaceSkeletonClass)) {
	if classInitFunc != nil {
		class := (*DBusInterfaceSkeletonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusInterfaceSkeleton(obj *coreglib.Object) *DBusInterfaceSkeleton {
	return &DBusInterfaceSkeleton{
		Object: obj,
		DBusInterface: DBusInterface{
			Object: obj,
		},
	}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	return wrapDBusInterfaceSkeleton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *DBusInterfaceSkeleton) baseDBusInterfaceSkeleton() *DBusInterfaceSkeleton {
	return v
}

// BaseDBusInterfaceSkeleton returns the underlying base object.
func BaseDBusInterfaceSkeleton(obj DBusInterfaceSkeletonner) *DBusInterfaceSkeleton {
	return obj.baseDBusInterfaceSkeleton()
}

// ConnectGAuthorizeMethod is emitted when a method is invoked by a remote
// caller and used to determine if the method call is authorized.
//
// Note that this signal is emitted in a thread dedicated to handling the method
// call so handlers are allowed to perform blocking IO. This means that it is
// appropriate to call e.g. polkit_authority_check_authorization_sync()
// (http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#polkit-authority-check-authorization-sync)
// with the POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION
// (http://hal.freedesktop.org/docs/polkit/PolkitAuthority.htmlLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS)
// flag set.
//
// If FALSE is returned then no further handlers are run and the signal handler
// must take a reference to invocation and finish handling the call (e.g. return
// an error via g_dbus_method_invocation_return_error()).
//
// Otherwise, if TRUE is returned, signal emission continues. If no handlers
// return FALSE, then the method is dispatched. If interface has an enclosing
// BusObjectSkeleton, then the BusObjectSkeleton::authorize-method signal
// handlers run before the handlers for this signal.
//
// The default class handler just returns TRUE.
//
// Please note that the common case is optimized: if no signals handlers are
// connected and the default class handler isn't overridden (for both interface
// and the enclosing BusObjectSkeleton, if any) and BusInterfaceSkeleton:g-flags
// does not have the
// G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD flags
// set, no dedicated thread is ever used and the call will be handled in the
// same thread as the object that interface belongs to was exported in.
func (v *DBusInterfaceSkeleton) ConnectGAuthorizeMethod(f func(invocation *DBusMethodInvocation) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "g-authorize-method", false, unsafe.Pointer(C._gotk4_gio2_DBusInterfaceSkeleton_ConnectGAuthorizeMethod), f)
}

// DBusInterfaceSkeletonClass class structure for BusInterfaceSkeleton.
//
// An instance of this type is always passed by reference.
type DBusInterfaceSkeletonClass struct {
	*dBusInterfaceSkeletonClass
}

// dBusInterfaceSkeletonClass is the struct that's finalized.
type dBusInterfaceSkeletonClass struct {
	native unsafe.Pointer
}

var GIRInfoDBusInterfaceSkeletonClass = girepository.MustFind("Gio", "DBusInterfaceSkeletonClass")
