// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeDBusAnnotationInfo = coreglib.Type(girepository.MustFind("Gio", "DBusAnnotationInfo").RegisteredGType())
	GTypeDBusArgInfo        = coreglib.Type(girepository.MustFind("Gio", "DBusArgInfo").RegisteredGType())
	GTypeDBusInterfaceInfo  = coreglib.Type(girepository.MustFind("Gio", "DBusInterfaceInfo").RegisteredGType())
	GTypeDBusMethodInfo     = coreglib.Type(girepository.MustFind("Gio", "DBusMethodInfo").RegisteredGType())
	GTypeDBusNodeInfo       = coreglib.Type(girepository.MustFind("Gio", "DBusNodeInfo").RegisteredGType())
	GTypeDBusPropertyInfo   = coreglib.Type(girepository.MustFind("Gio", "DBusPropertyInfo").RegisteredGType())
	GTypeDBusSignalInfo     = coreglib.Type(girepository.MustFind("Gio", "DBusSignalInfo").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDBusAnnotationInfo, F: marshalDBusAnnotationInfo},
		coreglib.TypeMarshaler{T: GTypeDBusArgInfo, F: marshalDBusArgInfo},
		coreglib.TypeMarshaler{T: GTypeDBusInterfaceInfo, F: marshalDBusInterfaceInfo},
		coreglib.TypeMarshaler{T: GTypeDBusMethodInfo, F: marshalDBusMethodInfo},
		coreglib.TypeMarshaler{T: GTypeDBusNodeInfo, F: marshalDBusNodeInfo},
		coreglib.TypeMarshaler{T: GTypeDBusPropertyInfo, F: marshalDBusPropertyInfo},
		coreglib.TypeMarshaler{T: GTypeDBusSignalInfo, F: marshalDBusSignalInfo},
	})
}

// DBusAnnotationInfo: information about an annotation.
//
// An instance of this type is always passed by reference.
type DBusAnnotationInfo struct {
	*dBusAnnotationInfo
}

// dBusAnnotationInfo is the struct that's finalized.
type dBusAnnotationInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusAnnotationInfo = girepository.MustFind("Gio", "DBusAnnotationInfo")

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusAnnotationInfo{&dBusAnnotationInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusAnnotationInfo) RefCount() int {
	offset := GIRInfoDBusAnnotationInfo.StructFieldOffset("ref_count")
	valptr := (*int)(unsafe.Add(d.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Key: name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
func (d *DBusAnnotationInfo) Key() string {
	offset := GIRInfoDBusAnnotationInfo.StructFieldOffset("key")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Value: value of the annotation.
func (d *DBusAnnotationInfo) Value() string {
	offset := GIRInfoDBusAnnotationInfo.StructFieldOffset("value")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusAnnotationInfo) Annotations() []*DBusAnnotationInfo {
	offset := GIRInfoDBusAnnotationInfo.StructFieldOffset("annotations")
	valptr := (*[]*DBusAnnotationInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusAnnotationInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusAnnotationInfo) SetRefCount(refCount int) {
	offset := GIRInfoDBusAnnotationInfo.StructFieldOffset("ref_count")
	valptr := (*C.gint)(unsafe.Add(d.native, offset))
	*valptr = C.gint(refCount)
}

// DBusArgInfo: information about an argument for a method or a signal.
//
// An instance of this type is always passed by reference.
type DBusArgInfo struct {
	*dBusArgInfo
}

// dBusArgInfo is the struct that's finalized.
type dBusArgInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusArgInfo = girepository.MustFind("Gio", "DBusArgInfo")

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusArgInfo{&dBusArgInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusArgInfo) RefCount() int {
	offset := GIRInfoDBusArgInfo.StructFieldOffset("ref_count")
	valptr := (*int)(unsafe.Add(d.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name of the argument, e.g. unix_user_id.
func (d *DBusArgInfo) Name() string {
	offset := GIRInfoDBusArgInfo.StructFieldOffset("name")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Signature d-Bus signature of the argument (a single complete type).
func (d *DBusArgInfo) Signature() string {
	offset := GIRInfoDBusArgInfo.StructFieldOffset("signature")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusArgInfo) Annotations() []*DBusAnnotationInfo {
	offset := GIRInfoDBusArgInfo.StructFieldOffset("annotations")
	valptr := (*[]*DBusAnnotationInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusAnnotationInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusArgInfo) SetRefCount(refCount int) {
	offset := GIRInfoDBusArgInfo.StructFieldOffset("ref_count")
	valptr := (*C.gint)(unsafe.Add(d.native, offset))
	*valptr = C.gint(refCount)
}

// DBusInterfaceInfo: information about a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusInterfaceInfo struct {
	*dBusInterfaceInfo
}

// dBusInterfaceInfo is the struct that's finalized.
type dBusInterfaceInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusInterfaceInfo = girepository.MustFind("Gio", "DBusInterfaceInfo")

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusInterfaceInfo{&dBusInterfaceInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusInterfaceInfo) RefCount() int {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("ref_count")
	valptr := (*int)(unsafe.Add(d.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
func (d *DBusInterfaceInfo) Name() string {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("name")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Methods: pointer to a NULL-terminated array of pointers to BusMethodInfo
// structures or NULL if there are no methods.
func (d *DBusInterfaceInfo) Methods() []*DBusMethodInfo {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("methods")
	valptr := (*[]*DBusMethodInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusMethodInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusMethodInfo, i)
		for i := range src {
			_v[i] = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusMethodInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Signals: pointer to a NULL-terminated array of pointers to BusSignalInfo
// structures or NULL if there are no signals.
func (d *DBusInterfaceInfo) Signals() []*DBusSignalInfo {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("signals")
	valptr := (*[]*DBusSignalInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusSignalInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusSignalInfo, i)
		for i := range src {
			_v[i] = (*DBusSignalInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusSignalInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Properties: pointer to a NULL-terminated array of pointers to BusPropertyInfo
// structures or NULL if there are no properties.
func (d *DBusInterfaceInfo) Properties() []*DBusPropertyInfo {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("properties")
	valptr := (*[]*DBusPropertyInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusPropertyInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusPropertyInfo, i)
		for i := range src {
			_v[i] = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusPropertyInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusInterfaceInfo) Annotations() []*DBusAnnotationInfo {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("annotations")
	valptr := (*[]*DBusAnnotationInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusAnnotationInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusInterfaceInfo) SetRefCount(refCount int) {
	offset := GIRInfoDBusInterfaceInfo.StructFieldOffset("ref_count")
	valptr := (*C.gint)(unsafe.Add(d.native, offset))
	*valptr = C.gint(refCount)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusMethodInfo struct {
	*dBusMethodInfo
}

// dBusMethodInfo is the struct that's finalized.
type dBusMethodInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusMethodInfo = girepository.MustFind("Gio", "DBusMethodInfo")

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusMethodInfo{&dBusMethodInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusMethodInfo) RefCount() int {
	offset := GIRInfoDBusMethodInfo.StructFieldOffset("ref_count")
	valptr := (*int)(unsafe.Add(d.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus method, e.g. RequestName.
func (d *DBusMethodInfo) Name() string {
	offset := GIRInfoDBusMethodInfo.StructFieldOffset("name")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// InArgs: pointer to a NULL-terminated array of pointers to BusArgInfo
// structures or NULL if there are no in arguments.
func (d *DBusMethodInfo) InArgs() []*DBusArgInfo {
	offset := GIRInfoDBusMethodInfo.StructFieldOffset("in_args")
	valptr := (*[]*DBusArgInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusArgInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusArgInfo, i)
		for i := range src {
			_v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusArgInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// OutArgs: pointer to a NULL-terminated array of pointers to BusArgInfo
// structures or NULL if there are no out arguments.
func (d *DBusMethodInfo) OutArgs() []*DBusArgInfo {
	offset := GIRInfoDBusMethodInfo.StructFieldOffset("out_args")
	valptr := (*[]*DBusArgInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusArgInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusArgInfo, i)
		for i := range src {
			_v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusArgInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusMethodInfo) Annotations() []*DBusAnnotationInfo {
	offset := GIRInfoDBusMethodInfo.StructFieldOffset("annotations")
	valptr := (*[]*DBusAnnotationInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusAnnotationInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusMethodInfo) SetRefCount(refCount int) {
	offset := GIRInfoDBusMethodInfo.StructFieldOffset("ref_count")
	valptr := (*C.gint)(unsafe.Add(d.native, offset))
	*valptr = C.gint(refCount)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
//
// An instance of this type is always passed by reference.
type DBusNodeInfo struct {
	*dBusNodeInfo
}

// dBusNodeInfo is the struct that's finalized.
type dBusNodeInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusNodeInfo = girepository.MustFind("Gio", "DBusNodeInfo")

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusNodeInfo{&dBusNodeInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusNodeInfo) RefCount() int {
	offset := GIRInfoDBusNodeInfo.StructFieldOffset("ref_count")
	valptr := (*int)(unsafe.Add(d.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Path: path of the node or NULL if omitted. Note that this may be a relative
// path. See the D-Bus specification for more details.
func (d *DBusNodeInfo) Path() string {
	offset := GIRInfoDBusNodeInfo.StructFieldOffset("path")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Interfaces: pointer to a NULL-terminated array of pointers to
// BusInterfaceInfo structures or NULL if there are no interfaces.
func (d *DBusNodeInfo) Interfaces() []*DBusInterfaceInfo {
	offset := GIRInfoDBusNodeInfo.StructFieldOffset("interfaces")
	valptr := (*[]*DBusInterfaceInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusInterfaceInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusInterfaceInfo, i)
		for i := range src {
			_v[i] = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusInterfaceInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Nodes: pointer to a NULL-terminated array of pointers to BusNodeInfo
// structures or NULL if there are no nodes.
func (d *DBusNodeInfo) Nodes() []*DBusNodeInfo {
	offset := GIRInfoDBusNodeInfo.StructFieldOffset("nodes")
	valptr := (*[]*DBusNodeInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusNodeInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusNodeInfo, i)
		for i := range src {
			_v[i] = (*DBusNodeInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusNodeInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusNodeInfo) Annotations() []*DBusAnnotationInfo {
	offset := GIRInfoDBusNodeInfo.StructFieldOffset("annotations")
	valptr := (*[]*DBusAnnotationInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusAnnotationInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusNodeInfo) SetRefCount(refCount int) {
	offset := GIRInfoDBusNodeInfo.StructFieldOffset("ref_count")
	valptr := (*C.gint)(unsafe.Add(d.native, offset))
	*valptr = C.gint(refCount)
}

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusPropertyInfo struct {
	*dBusPropertyInfo
}

// dBusPropertyInfo is the struct that's finalized.
type dBusPropertyInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusPropertyInfo = girepository.MustFind("Gio", "DBusPropertyInfo")

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusPropertyInfo{&dBusPropertyInfo{(unsafe.Pointer)(b)}}, nil
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusSignalInfo struct {
	*dBusSignalInfo
}

// dBusSignalInfo is the struct that's finalized.
type dBusSignalInfo struct {
	native unsafe.Pointer
}

var GIRInfoDBusSignalInfo = girepository.MustFind("Gio", "DBusSignalInfo")

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusSignalInfo{&dBusSignalInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusSignalInfo) RefCount() int {
	offset := GIRInfoDBusSignalInfo.StructFieldOffset("ref_count")
	valptr := (*int)(unsafe.Add(d.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Name: name of the D-Bus signal, e.g. "NameOwnerChanged".
func (d *DBusSignalInfo) Name() string {
	offset := GIRInfoDBusSignalInfo.StructFieldOffset("name")
	valptr := (*string)(unsafe.Add(d.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Args: pointer to a NULL-terminated array of pointers to BusArgInfo structures
// or NULL if there are no arguments.
func (d *DBusSignalInfo) Args() []*DBusArgInfo {
	offset := GIRInfoDBusSignalInfo.StructFieldOffset("args")
	valptr := (*[]*DBusArgInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusArgInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusArgInfo, i)
		for i := range src {
			_v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusArgInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusSignalInfo) Annotations() []*DBusAnnotationInfo {
	offset := GIRInfoDBusSignalInfo.StructFieldOffset("annotations")
	valptr := (*[]*DBusAnnotationInfo)(unsafe.Add(d.native, offset))
	var _v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			_v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					{
						var args [1]girepository.Argument
						*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
						Gio.GIRInfoDBusAnnotationInfo.InvokeRecordMethod("unref", args[:], nil)
					}
				},
			)
		}
	}
	return _v
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusSignalInfo) SetRefCount(refCount int) {
	offset := GIRInfoDBusSignalInfo.StructFieldOffset("ref_count")
	valptr := (*C.gint)(unsafe.Add(d.native, offset))
	*valptr = C.gint(refCount)
}
