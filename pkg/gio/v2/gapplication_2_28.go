// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_Application_ConnectStartup(gpointer, guintptr);
// extern void _gotk4_gio2_Application_ConnectShutdown(gpointer, guintptr);
// extern void _gotk4_gio2_Application_ConnectOpen(gpointer, void**, gint, gchar*, guintptr);
// extern void _gotk4_gio2_Application_ConnectActivate(gpointer, guintptr);
// extern gint _gotk4_gio2_Application_ConnectHandleLocalOptions(gpointer, GVariantDict*, guintptr);
// extern gint _gotk4_gio2_Application_ConnectCommandLine(gpointer, void*, guintptr);
// extern gboolean _gotk4_gio2_Application_ConnectNameLost(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeApplication = coreglib.Type(girepository.MustFind("Gio", "Application").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeApplication, F: marshalApplication},
	})
}

// ApplicationOverrides contains methods that are overridable.
type ApplicationOverrides struct {
}

func defaultApplicationOverrides(v *Application) ApplicationOverrides {
	return ApplicationOverrides{}
}

// Application is the foundation of an application. It wraps some low-level
// platform-specific services and is intended to act as the foundation for
// higher-level application classes such as Application or Application. In
// general, you should not use this class outside of a higher level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: com.example.MyApp, org.example.internal_apps.Calculator,
// org._7_zip.Archiver. For details on valid application identifiers, see
// g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some ‘platform data’ from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the before_emit or after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ActionGroup
	ActionMap
}

var (
	_ coreglib.Objector = (*Application)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Application, *ApplicationClass, ApplicationOverrides](
		GTypeApplication,
		initApplicationClass,
		wrapApplication,
		defaultApplicationOverrides,
	)
}

func initApplicationClass(gclass unsafe.Pointer, overrides ApplicationOverrides, classInitFunc func(*ApplicationClass)) {
	if classInitFunc != nil {
		class := (*ApplicationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplication(obj *coreglib.Object) *Application {
	return &Application{
		Object: obj,
		ActionGroup: ActionGroup{
			Object: obj,
		},
		ActionMap: ActionMap{
			Object: obj,
		},
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	return wrapApplication(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate signal is emitted on the primary instance when an activation
// occurs. See g_application_activate().
func (v *Application) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectActivate), f)
}

// ConnectCommandLine signal is emitted on the primary instance when a
// commandline is not handled locally. See g_application_run() and the
// CommandLine documentation for more information.
func (v *Application) ConnectCommandLine(f func(commandLine *ApplicationCommandLine) (gint int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "command-line", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectCommandLine), f)
}

// ConnectHandleLocalOptions signal is emitted on the local instance after the
// parsing of the commandline options has occurred.
//
// You can add options to be recognised during commandline option parsing using
// g_application_add_main_option_entries() and g_application_add_option_group().
//
// Signal handlers can inspect options (along with values pointed to from the
// arg_data of an installed Entrys) in order to decide to perform certain
// actions, including direct local handling (which may be useful for options
// like --version).
//
// In the event that the application is marked
// G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will send the
// options dictionary to the primary instance where it can be read with
// g_application_command_line_get_options_dict(). The signal handler can modify
// the dictionary before returning, and the modified dictionary will be sent.
//
// In the event that G_APPLICATION_HANDLES_COMMAND_LINE is not set, "normal
// processing" will treat the remaining uncollected command line arguments as
// filenames or URIs. If there are no arguments, the application is activated by
// g_application_activate(). One or more arguments results in a call to
// g_application_open().
//
// If you want to handle the local commandline arguments for yourself by
// converting them to calls to g_application_open() or
// g_action_group_activate_action() then you must be sure to register the
// application first. You should probably not call g_application_activate() for
// yourself, however: just return -1 and allow the default handler to do it for
// you. This will ensure that the --gapplication-service switch works properly
// (i.e. no activation in that case).
//
// Note that this signal is emitted from the default implementation of
// local_command_line(). If you override that function and don't chain up then
// this signal will never be emitted.
//
// You can override local_command_line() if you need more powerful capabilities
// than what is provided here, but this should not normally be required.
func (v *Application) ConnectHandleLocalOptions(f func(options *glib.VariantDict) (gint int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "handle-local-options", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectHandleLocalOptions), f)
}

// ConnectNameLost signal is emitted only on the registered primary instance
// when a new instance has taken over. This can only happen if the application
// is using the G_APPLICATION_ALLOW_REPLACEMENT flag.
//
// The default handler for this signal calls g_application_quit().
func (v *Application) ConnectNameLost(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "name-lost", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectNameLost), f)
}

// ConnectOpen signal is emitted on the primary instance when there are files to
// open. See g_application_open() for more information.
func (v *Application) ConnectOpen(f func(files []Filer, hint string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "open", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectOpen), f)
}

// ConnectShutdown signal is emitted only on the registered primary instance
// immediately after the main loop terminates.
func (v *Application) ConnectShutdown(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "shutdown", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectShutdown), f)
}

// ConnectStartup signal is emitted on the primary instance immediately after
// registration. See g_application_register().
func (v *Application) ConnectStartup(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "startup", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectStartup), f)
}

// ApplicationClass: virtual function table for #GApplication.
//
// An instance of this type is always passed by reference.
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized.
type applicationClass struct {
	native unsafe.Pointer
}

var GIRInfoApplicationClass = girepository.MustFind("Gio", "ApplicationClass")
