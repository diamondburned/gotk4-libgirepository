// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeResourceError       = coreglib.Type(girepository.MustFind("Gio", "ResourceError").RegisteredGType())
	GTypeSocketClientEvent   = coreglib.Type(girepository.MustFind("Gio", "SocketClientEvent").RegisteredGType())
	GTypeResourceFlags       = coreglib.Type(girepository.MustFind("Gio", "ResourceFlags").RegisteredGType())
	GTypeResourceLookupFlags = coreglib.Type(girepository.MustFind("Gio", "ResourceLookupFlags").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeResourceError, F: marshalResourceError},
		coreglib.TypeMarshaler{T: GTypeSocketClientEvent, F: marshalSocketClientEvent},
		coreglib.TypeMarshaler{T: GTypeResourceFlags, F: marshalResourceFlags},
		coreglib.TypeMarshaler{T: GTypeResourceLookupFlags, F: marshalResourceLookupFlags},
	})
}

// ResourceError: error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError C.gint

const (
	// ResourceErrorNotFound: no file was found at the requested path.
	ResourceErrorNotFound ResourceError = iota
	// ResourceErrorInternal: unknown error.
	ResourceErrorInternal
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResourceError.
func (r ResourceError) String() string {
	switch r {
	case ResourceErrorNotFound:
		return "NotFound"
	case ResourceErrorInternal:
		return "Internal"
	default:
		return fmt.Sprintf("ResourceError(%d)", r)
	}
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent C.gint

const (
	// SocketClientResolving: client is doing a DNS lookup.
	SocketClientResolving SocketClientEvent = iota
	// SocketClientResolved: client has completed a DNS lookup.
	SocketClientResolved
	// SocketClientConnecting: client is connecting to a remote host (either a
	// proxy or the destination server).
	SocketClientConnecting
	// SocketClientConnected: client has connected to a remote host.
	SocketClientConnected
	// SocketClientProxyNegotiating: client is negotiating with a proxy to
	// connect to the destination server.
	SocketClientProxyNegotiating
	// SocketClientProxyNegotiated: client has negotiated with the proxy server.
	SocketClientProxyNegotiated
	// SocketClientTLSHandshaking: client is performing a TLS handshake.
	SocketClientTLSHandshaking
	// SocketClientTLSHandshaked: client has performed a TLS handshake.
	SocketClientTLSHandshaked
	// SocketClientComplete: client is done with a particular Connectable.
	SocketClientComplete
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketClientEvent.
func (s SocketClientEvent) String() string {
	switch s {
	case SocketClientResolving:
		return "Resolving"
	case SocketClientResolved:
		return "Resolved"
	case SocketClientConnecting:
		return "Connecting"
	case SocketClientConnected:
		return "Connected"
	case SocketClientProxyNegotiating:
		return "ProxyNegotiating"
	case SocketClientProxyNegotiated:
		return "ProxyNegotiated"
	case SocketClientTLSHandshaking:
		return "TLSHandshaking"
	case SocketClientTLSHandshaked:
		return "TLSHandshaked"
	case SocketClientComplete:
		return "Complete"
	default:
		return fmt.Sprintf("SocketClientEvent(%d)", s)
	}
}

// ResourceFlags give information about a particular file inside a resource
// bundle.
type ResourceFlags C.guint

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResourceFlags.
func (r ResourceFlags) String() string {
	if r == 0 {
		return "ResourceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(41)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResourceFlagsNone:
			builder.WriteString("None|")
		case ResourceFlagsCompressed:
			builder.WriteString("Compressed|")
		default:
			builder.WriteString(fmt.Sprintf("ResourceFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResourceFlags) Has(other ResourceFlags) bool {
	return (r & other) == other
}

// ResourceLookupFlags determine how resource path lookups are handled.
type ResourceLookupFlags C.guint

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResourceLookupFlags.
func (r ResourceLookupFlags) String() string {
	if r == 0 {
		return "ResourceLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResourceLookupFlagsNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("ResourceLookupFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResourceLookupFlags) Has(other ResourceLookupFlags) bool {
	return (r & other) == other
}
