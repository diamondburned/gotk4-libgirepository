// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gio2_SocketService_ConnectIncoming(gpointer, void*, GObject, guintptr);
import "C"

// GType values.
var (
	GTypeSocketService = coreglib.Type(girepository.MustFind("Gio", "SocketService").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSocketService, F: marshalSocketService},
	})
}

// SocketServiceOverrides contains methods that are overridable.
type SocketServiceOverrides struct {
}

func defaultSocketServiceOverrides(v *SocketService) SocketServiceOverrides {
	return SocketServiceOverrides{}
}

// SocketService is an object that represents a service that is provided to the
// network or over local sockets. When a new connection is made to the service
// the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService struct {
	_ [0]func() // equal guard
	SocketListener
}

var (
	_ coreglib.Objector = (*SocketService)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SocketService, *SocketServiceClass, SocketServiceOverrides](
		GTypeSocketService,
		initSocketServiceClass,
		wrapSocketService,
		defaultSocketServiceOverrides,
	)
}

func initSocketServiceClass(gclass unsafe.Pointer, overrides SocketServiceOverrides, classInitFunc func(*SocketServiceClass)) {
	if classInitFunc != nil {
		class := (*SocketServiceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketService(obj *coreglib.Object) *SocketService {
	return &SocketService{
		SocketListener: SocketListener{
			Object: obj,
		},
	}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	return wrapSocketService(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectIncoming signal is emitted when a new incoming connection to service
// needs to be handled. The handler must initiate the handling of connection,
// but may not block; in essence, asynchronous operations must be used.
//
// connection will be unreffed once the signal handler returns, so you need to
// ref it yourself if you are planning to use it.
func (v *SocketService) ConnectIncoming(f func(connection *SocketConnection, sourceObject *coreglib.Object) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "incoming", false, unsafe.Pointer(C._gotk4_gio2_SocketService_ConnectIncoming), f)
}
