// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFileIOStream = coreglib.Type(girepository.MustFind("Gio", "FileIOStream").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileIOStream, F: marshalFileIOStream},
	})
}

// FileIOStreamOverrides contains methods that are overridable.
type FileIOStreamOverrides struct {
}

func defaultFileIOStreamOverrides(v *FileIOStream) FileIOStreamOverrides {
	return FileIOStreamOverrides{}
}

// FileIOStream provides io streams that both read and write to the same file
// handle.
//
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file io stream, use g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
//
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
type FileIOStream struct {
	_ [0]func() // equal guard
	IOStream

	*coreglib.Object
	Seekable
}

var (
	_ IOStreamer        = (*FileIOStream)(nil)
	_ coreglib.Objector = (*FileIOStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileIOStream, *FileIOStreamClass, FileIOStreamOverrides](
		GTypeFileIOStream,
		initFileIOStreamClass,
		wrapFileIOStream,
		defaultFileIOStreamOverrides,
	)
}

func initFileIOStreamClass(gclass unsafe.Pointer, overrides FileIOStreamOverrides, classInitFunc func(*FileIOStreamClass)) {
	if classInitFunc != nil {
		class := (*FileIOStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileIOStream(obj *coreglib.Object) *FileIOStream {
	return &FileIOStream{
		IOStream: IOStream{
			Object: obj,
		},
		Object: obj,
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	return wrapFileIOStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
