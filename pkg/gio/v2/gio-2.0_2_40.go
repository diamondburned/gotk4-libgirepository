// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_AppInfoMonitor_ConnectChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeAppInfoMonitor = coreglib.Type(girepository.MustFind("Gio", "AppInfoMonitor").RegisteredGType())
	GTypeNotification   = coreglib.Type(girepository.MustFind("Gio", "Notification").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAppInfoMonitor, F: marshalAppInfoMonitor},
		coreglib.TypeMarshaler{T: GTypeNotification, F: marshalNotification},
	})
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppInfoMonitor)(nil)
)

func wrapAppInfoMonitor(obj *coreglib.Object) *AppInfoMonitor {
	return &AppInfoMonitor{
		Object: obj,
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	return wrapAppInfoMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged: signal emitted when the app info database for changes (ie:
// newly installed or removed applications).
func (v *AppInfoMonitor) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "changed", false, unsafe.Pointer(C._gotk4_gio2_AppInfoMonitor_ConnectChanged), f)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Notification)(nil)
)

func wrapNotification(obj *coreglib.Object) *Notification {
	return &Notification{
		Object: obj,
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	return wrapNotification(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
