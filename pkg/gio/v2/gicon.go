// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeIcon = coreglib.Type(girepository.MustFind("Gio", "Icon").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIcon, F: marshalIcon},
	})
}

// IconOverrider contains methods that are overridable.
type IconOverrider interface {
}

// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon).
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
//
// Icon wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Icon struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Icon)(nil)
)

// Iconner describes Icon's interface methods.
type Iconner interface {
	coreglib.Objector

	baseIcon() *Icon
}

var _ Iconner = (*Icon)(nil)

func ifaceInitIconner(gifacePtr, data C.gpointer) {
}

func wrapIcon(obj *coreglib.Object) *Icon {
	return &Icon{
		Object: obj,
	}
}

func marshalIcon(p uintptr) (interface{}, error) {
	return wrapIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Icon) baseIcon() *Icon {
	return v
}

// BaseIcon returns the underlying base object.
func BaseIcon(obj Iconner) *Icon {
	return obj.baseIcon()
}

// IconIface is used to implement GIcon types for various different systems. See
// Icon and Icon for examples of how to implement this interface.
//
// An instance of this type is always passed by reference.
type IconIface struct {
	*iconIface
}

// iconIface is the struct that's finalized.
type iconIface struct {
	native unsafe.Pointer
}

var GIRInfoIconIface = girepository.MustFind("Gio", "IconIface")
