// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeSocketAddressEnumerator = coreglib.Type(girepository.MustFind("Gio", "SocketAddressEnumerator").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSocketAddressEnumerator, F: marshalSocketAddressEnumerator},
	})
}

// SocketAddressEnumeratorOverrides contains methods that are overridable.
type SocketAddressEnumeratorOverrides struct {
}

func defaultSocketAddressEnumeratorOverrides(v *SocketAddressEnumerator) SocketAddressEnumeratorOverrides {
	return SocketAddressEnumeratorOverrides{}
}

// SocketAddressEnumerator is an enumerator type for Address instances. It is
// returned by enumeration functions such as g_socket_connectable_enumerate(),
// which returns a AddressEnumerator to list each Address which could be used to
// connect to that Connectable.
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
//
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned NULL, further enumeration
// with that AddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketAddressEnumerator)(nil)
)

// SocketAddressEnumeratorrer describes types inherited from class SocketAddressEnumerator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type SocketAddressEnumeratorrer interface {
	coreglib.Objector
	baseSocketAddressEnumerator() *SocketAddressEnumerator
}

var _ SocketAddressEnumeratorrer = (*SocketAddressEnumerator)(nil)

func init() {
	coreglib.RegisterClassInfo[*SocketAddressEnumerator, *SocketAddressEnumeratorClass, SocketAddressEnumeratorOverrides](
		GTypeSocketAddressEnumerator,
		initSocketAddressEnumeratorClass,
		wrapSocketAddressEnumerator,
		defaultSocketAddressEnumeratorOverrides,
	)
}

func initSocketAddressEnumeratorClass(gclass unsafe.Pointer, overrides SocketAddressEnumeratorOverrides, classInitFunc func(*SocketAddressEnumeratorClass)) {
	if classInitFunc != nil {
		class := (*SocketAddressEnumeratorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketAddressEnumerator(obj *coreglib.Object) *SocketAddressEnumerator {
	return &SocketAddressEnumerator{
		Object: obj,
	}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	return wrapSocketAddressEnumerator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *SocketAddressEnumerator) baseSocketAddressEnumerator() *SocketAddressEnumerator {
	return v
}

// BaseSocketAddressEnumerator returns the underlying base object.
func BaseSocketAddressEnumerator(obj SocketAddressEnumeratorrer) *SocketAddressEnumerator {
	return obj.baseSocketAddressEnumerator()
}

// SocketAddressEnumeratorClass class structure for AddressEnumerator.
//
// An instance of this type is always passed by reference.
type SocketAddressEnumeratorClass struct {
	*socketAddressEnumeratorClass
}

// socketAddressEnumeratorClass is the struct that's finalized.
type socketAddressEnumeratorClass struct {
	native unsafe.Pointer
}

var GIRInfoSocketAddressEnumeratorClass = girepository.MustFind("Gio", "SocketAddressEnumeratorClass")
