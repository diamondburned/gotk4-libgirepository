// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeTLSChannelBindingError = coreglib.Type(girepository.MustFind("Gio", "TlsChannelBindingError").RegisteredGType())
	GTypeTLSChannelBindingType  = coreglib.Type(girepository.MustFind("Gio", "TlsChannelBindingType").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTLSChannelBindingError, F: marshalTLSChannelBindingError},
		coreglib.TypeMarshaler{T: GTypeTLSChannelBindingType, F: marshalTLSChannelBindingType},
	})
}

// TLSChannelBindingError: error code used with G_TLS_CHANNEL_BINDING_ERROR in a
// #GError to indicate a TLS channel binding retrieval error.
type TLSChannelBindingError C.gint

const (
	// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TLSChannelBindingErrorNotImplemented TLSChannelBindingError = iota
	// TLSChannelBindingErrorInvalidState: handshake is not yet complete on the
	// connection which is a strong requirement for any existing binding type.
	TLSChannelBindingErrorInvalidState
	// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TLSChannelBindingErrorNotAvailable
	// TLSChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// tls-server-end-point binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TLSChannelBindingErrorNotSupported
	// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TLSChannelBindingErrorGeneralError
)

func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
	return TLSChannelBindingError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSChannelBindingError.
func (t TLSChannelBindingError) String() string {
	switch t {
	case TLSChannelBindingErrorNotImplemented:
		return "NotImplemented"
	case TLSChannelBindingErrorInvalidState:
		return "InvalidState"
	case TLSChannelBindingErrorNotAvailable:
		return "NotAvailable"
	case TLSChannelBindingErrorNotSupported:
		return "NotSupported"
	case TLSChannelBindingErrorGeneralError:
		return "GeneralError"
	default:
		return fmt.Sprintf("TLSChannelBindingError(%d)", t)
	}
}

// TLSChannelBindingType: type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// tls-unique-for-telnet (https://tools.ietf.org/html/rfc5929#section-5) binding
// type is not currently implemented.
type TLSChannelBindingType C.gint

const (
	// TLSChannelBindingTLSUnique: tls-unique
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type.
	TLSChannelBindingTLSUnique TLSChannelBindingType = iota
	// TLSChannelBindingTLSServerEndPoint: tls-server-end-point
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type.
	TLSChannelBindingTLSServerEndPoint
)

func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
	return TLSChannelBindingType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSChannelBindingType.
func (t TLSChannelBindingType) String() string {
	switch t {
	case TLSChannelBindingTLSUnique:
		return "Unique"
	case TLSChannelBindingTLSServerEndPoint:
		return "ServerEndPoint"
	default:
		return fmt.Sprintf("TLSChannelBindingType(%d)", t)
	}
}
