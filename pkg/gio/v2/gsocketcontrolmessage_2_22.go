// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeSocketControlMessage = coreglib.Type(girepository.MustFind("Gio", "SocketControlMessage").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSocketControlMessage, F: marshalSocketControlMessage},
	})
}

// SocketControlMessageOverrides contains methods that are overridable.
type SocketControlMessageOverrides struct {
}

func defaultSocketControlMessageOverrides(v *SocketControlMessage) SocketControlMessageOverrides {
	return SocketControlMessageOverrides{}
}

// SocketControlMessage is a special-purpose utility message that can be sent to
// or received from a #GSocket. These types of messages are often called
// "ancillary data".
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
type SocketControlMessage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketControlMessage)(nil)
)

// SocketControlMessager describes types inherited from class SocketControlMessage.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type SocketControlMessager interface {
	coreglib.Objector
	baseSocketControlMessage() *SocketControlMessage
}

var _ SocketControlMessager = (*SocketControlMessage)(nil)

func init() {
	coreglib.RegisterClassInfo[*SocketControlMessage, *SocketControlMessageClass, SocketControlMessageOverrides](
		GTypeSocketControlMessage,
		initSocketControlMessageClass,
		wrapSocketControlMessage,
		defaultSocketControlMessageOverrides,
	)
}

func initSocketControlMessageClass(gclass unsafe.Pointer, overrides SocketControlMessageOverrides, classInitFunc func(*SocketControlMessageClass)) {
	if classInitFunc != nil {
		class := (*SocketControlMessageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSocketControlMessage(obj *coreglib.Object) *SocketControlMessage {
	return &SocketControlMessage{
		Object: obj,
	}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	return wrapSocketControlMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *SocketControlMessage) baseSocketControlMessage() *SocketControlMessage {
	return v
}

// BaseSocketControlMessage returns the underlying base object.
func BaseSocketControlMessage(obj SocketControlMessager) *SocketControlMessage {
	return obj.baseSocketControlMessage()
}
