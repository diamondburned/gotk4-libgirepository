// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_SimpleAction_ConnectChangeState(gpointer, GVariant*, guintptr);
// extern void _gotk4_gio2_SimpleAction_ConnectActivate(gpointer, GVariant*, guintptr);
import "C"

// GType values.
var (
	GTypeDBusActionGroup  = coreglib.Type(girepository.MustFind("Gio", "DBusActionGroup").RegisteredGType())
	GTypeDBusMenuModel    = coreglib.Type(girepository.MustFind("Gio", "DBusMenuModel").RegisteredGType())
	GTypeSimpleAction     = coreglib.Type(girepository.MustFind("Gio", "SimpleAction").RegisteredGType())
	GTypeSimplePermission = coreglib.Type(girepository.MustFind("Gio", "SimplePermission").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDBusActionGroup, F: marshalDBusActionGroup},
		coreglib.TypeMarshaler{T: GTypeDBusMenuModel, F: marshalDBusMenuModel},
		coreglib.TypeMarshaler{T: GTypeSimpleAction, F: marshalSimpleAction},
		coreglib.TypeMarshaler{T: GTypeSimplePermission, F: marshalSimplePermission},
	})
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object

	RemoteActionGroup
}

var (
	_ coreglib.Objector = (*DBusActionGroup)(nil)
)

func wrapDBusActionGroup(obj *coreglib.Object) *DBusActionGroup {
	return &DBusActionGroup{
		Object: obj,
		RemoteActionGroup: RemoteActionGroup{
			ActionGroup: ActionGroup{
				Object: obj,
			},
		},
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	return wrapDBusActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel struct {
	_ [0]func() // equal guard
	MenuModel
}

var (
	_ MenuModeller = (*DBusMenuModel)(nil)
)

func wrapDBusMenuModel(obj *coreglib.Object) *DBusMenuModel {
	return &DBusMenuModel{
		MenuModel: MenuModel{
			Object: obj,
		},
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	return wrapDBusMenuModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SimpleAction is the obvious simple implementation of the #GAction interface.
// This is the easiest way to create an action for purposes of adding it to a
// ActionGroup.
//
// See also Action.
type SimpleAction struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Action
}

var (
	_ coreglib.Objector = (*SimpleAction)(nil)
)

func wrapSimpleAction(obj *coreglib.Object) *SimpleAction {
	return &SimpleAction{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	return wrapSimpleAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate indicates that the action was just activated.
//
// parameter will always be of the expected type, i.e. the parameter type
// specified when the action was created. If an incorrect type is given when
// activating the action, this signal is not emitted.
//
// Since GLib 2.40, if no handler is connected to this signal then the default
// behaviour for boolean-stated actions with a NULL parameter type is to toggle
// them via the Action::change-state signal. For stateful actions where the
// state type is equal to the parameter type, the default is to forward them
// directly to Action::change-state. This should allow almost all users of
// Action to connect only one handler or the other.
func (v *SimpleAction) ConnectActivate(f func(parameter *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gio2_SimpleAction_ConnectActivate), f)
}

// ConnectChangeState indicates that the action just received a request to
// change its state.
//
// value will always be of the correct state type, i.e. the type of the initial
// state passed to g_simple_action_new_stateful(). If an incorrect type is given
// when requesting to change the state, this signal is not emitted.
//
// If no handler is connected to this signal then the default behaviour is to
// call g_simple_action_set_state() to set the state to the requested value. If
// you connect a signal handler then no default action is taken. If the state
// should change then you must call g_simple_action_set_state() from the
// handler.
//
// An example of a 'change-state' handler:
//
//    static void
//    change_volume_state (GSimpleAction *action,
//                         GVariant      *value,
//                         gpointer       user_data)
//    {
//      gint requested;
//
//      requested = g_variant_get_int32 (value);
//
//      // Volume only goes from 0 to 10
//      if (0 <= requested && requested <= 10)
//        g_simple_action_set_state (action, value);
//    }
//
// The handler need not set the state to the requested value. It could set it to
// any value at all, or take some other action.
func (v *SimpleAction) ConnectChangeState(f func(value *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "change-state", false, unsafe.Pointer(C._gotk4_gio2_SimpleAction_ConnectChangeState), f)
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission struct {
	_ [0]func() // equal guard
	Permission
}

var (
	_ Permissioner = (*SimplePermission)(nil)
)

func wrapSimplePermission(obj *coreglib.Object) *SimplePermission {
	return &SimplePermission{
		Permission: Permission{
			Object: obj,
		},
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	return wrapSimplePermission(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
