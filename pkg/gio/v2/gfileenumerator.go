// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFileEnumerator = coreglib.Type(girepository.MustFind("Gio", "FileEnumerator").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileEnumerator, F: marshalFileEnumerator},
	})
}

// FileEnumeratorOverrides contains methods that are overridable.
type FileEnumeratorOverrides struct {
}

func defaultFileEnumeratorOverrides(v *FileEnumerator) FileEnumeratorOverrides {
	return FileEnumeratorOverrides{}
}

// FileEnumerator allows you to operate on a set of #GFiles, returning a Info
// structure for each file enumerated (e.g. g_file_enumerate_children() will
// return a Enumerator for each of the children within a directory).
//
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
type FileEnumerator struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileEnumerator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileEnumerator, *FileEnumeratorClass, FileEnumeratorOverrides](
		GTypeFileEnumerator,
		initFileEnumeratorClass,
		wrapFileEnumerator,
		defaultFileEnumeratorOverrides,
	)
}

func initFileEnumeratorClass(gclass unsafe.Pointer, overrides FileEnumeratorOverrides, classInitFunc func(*FileEnumeratorClass)) {
	if classInitFunc != nil {
		class := (*FileEnumeratorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileEnumerator(obj *coreglib.Object) *FileEnumerator {
	return &FileEnumerator{
		Object: obj,
	}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	return wrapFileEnumerator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FileEnumeratorClass: instance of this type is always passed by reference.
type FileEnumeratorClass struct {
	*fileEnumeratorClass
}

// fileEnumeratorClass is the struct that's finalized.
type fileEnumeratorClass struct {
	native unsafe.Pointer
}

var GIRInfoFileEnumeratorClass = girepository.MustFind("Gio", "FileEnumeratorClass")
