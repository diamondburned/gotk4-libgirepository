// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeRemoteActionGroup = coreglib.Type(girepository.MustFind("Gio", "RemoteActionGroup").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRemoteActionGroup, F: marshalRemoteActionGroup},
	})
}

// RemoteActionGroupOverrider contains methods that are overridable.
type RemoteActionGroupOverrider interface {
}

// RemoteActionGroup interface is implemented by Group instances that either
// transmit action invocations to other processes or receive action invocations
// in the local process from other processes.
//
// The interface has _full variants of the two methods on Group used to activate
// actions: g_action_group_activate_action() and
// g_action_group_change_action_state(). These variants allow a "platform data"
// #GVariant to be specified: a dictionary providing context for the action
// invocation (for example: timestamps, startup notification IDs, etc).
//
// BusActionGroup implements ActionGroup. This provides a mechanism to send
// platform data for action invocations over D-Bus.
//
// Additionally, g_dbus_connection_export_action_group() will check if the
// exported Group implements ActionGroup and use the _full variants of the calls
// if available. This provides a mechanism by which to receive platform data for
// action invocations that arrive by way of D-Bus.
//
// RemoteActionGroup wraps an interface. This means the user can get the
// underlying type by calling Cast().
type RemoteActionGroup struct {
	_ [0]func() // equal guard
	ActionGroup
}

var ()

// RemoteActionGrouper describes RemoteActionGroup's interface methods.
type RemoteActionGrouper interface {
	coreglib.Objector

	baseRemoteActionGroup() *RemoteActionGroup
}

var _ RemoteActionGrouper = (*RemoteActionGroup)(nil)

func ifaceInitRemoteActionGrouper(gifacePtr, data C.gpointer) {
}

func wrapRemoteActionGroup(obj *coreglib.Object) *RemoteActionGroup {
	return &RemoteActionGroup{
		ActionGroup: ActionGroup{
			Object: obj,
		},
	}
}

func marshalRemoteActionGroup(p uintptr) (interface{}, error) {
	return wrapRemoteActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *RemoteActionGroup) baseRemoteActionGroup() *RemoteActionGroup {
	return v
}

// BaseRemoteActionGroup returns the underlying base object.
func BaseRemoteActionGroup(obj RemoteActionGrouper) *RemoteActionGroup {
	return obj.baseRemoteActionGroup()
}

// RemoteActionGroupInterface: virtual function table for ActionGroup.
//
// An instance of this type is always passed by reference.
type RemoteActionGroupInterface struct {
	*remoteActionGroupInterface
}

// remoteActionGroupInterface is the struct that's finalized.
type remoteActionGroupInterface struct {
	native unsafe.Pointer
}

var GIRInfoRemoteActionGroupInterface = girepository.MustFind("Gio", "RemoteActionGroupInterface")
