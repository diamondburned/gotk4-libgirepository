// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeResolverRecordType = coreglib.Type(girepository.MustFind("Gio", "ResolverRecordType").RegisteredGType())
	GTypeTestDBusFlags      = coreglib.Type(girepository.MustFind("Gio", "TestDBusFlags").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeResolverRecordType, F: marshalResolverRecordType},
		coreglib.TypeMarshaler{T: GTypeTestDBusFlags, F: marshalTestDBusFlags},
	})
}

// ResolverRecordType: type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// (qqqs), containing a guint16 with the priority, a guint16 with the weight, a
// guint16 with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// (qs), representing a guint16 with the preference, and a string containing the
// mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// (as), representing an array of the strings in the text record. Note: Most TXT
// records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// (ssuuuuu), representing a string containing the primary name server, a string
// containing the administrator, the serial as a guint32, the refresh interval
// as a guint32, the retry interval as a guint32, the expire timeout as a
// guint32, and the TTL as a guint32.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature (s),
// representing a string of the hostname of the name server.
type ResolverRecordType C.gint

const (
	// ResolverRecordSrv: look up DNS SRV records for a domain.
	ResolverRecordSrv ResolverRecordType = 1
	// ResolverRecordMx: look up DNS MX records for a domain.
	ResolverRecordMx ResolverRecordType = 2
	// ResolverRecordTxt: look up DNS TXT records for a name.
	ResolverRecordTxt ResolverRecordType = 3
	// ResolverRecordSoa: look up DNS SOA records for a zone.
	ResolverRecordSoa ResolverRecordType = 4
	// ResolverRecordNs: look up DNS NS records for a domain.
	ResolverRecordNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResolverRecordType.
func (r ResolverRecordType) String() string {
	switch r {
	case ResolverRecordSrv:
		return "Srv"
	case ResolverRecordMx:
		return "Mx"
	case ResolverRecordTxt:
		return "Txt"
	case ResolverRecordSoa:
		return "Soa"
	case ResolverRecordNs:
		return "Ns"
	default:
		return fmt.Sprintf("ResolverRecordType(%d)", r)
	}
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags C.guint

const (
	// TestDBusNone: no flags.
	TestDBusNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TestDBusFlags.
func (t TestDBusFlags) String() string {
	if t == 0 {
		return "TestDBusFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(12)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TestDBusNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("TestDBusFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TestDBusFlags) Has(other TestDBusFlags) bool {
	return (t & other) == other
}
