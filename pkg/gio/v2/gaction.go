// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAction = coreglib.Type(girepository.MustFind("Gio", "Action").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAction, F: marshalAction},
	})
}

// ActionOverrider contains methods that are overridable.
type ActionOverrider interface {
}

// Action represents a single named action.
//
// The main interface to an action is that it can be activated with
// g_action_activate(). This results in the 'activate' signal being emitted. An
// activation has a #GVariant parameter (which may be NULL). The correct type
// for the parameter is determined by a static parameter type (which is given at
// construction time).
//
// An action may optionally have a state, in which case the state may be set
// with g_action_change_state(). This call takes a #GVariant. The correct type
// for the state is determined by a static state type (which is given at
// construction time).
//
// The state may have a hint associated with it, specifying its valid range.
//
// #GAction is merely the interface to the concept of an action, as described
// above. Various implementations of actions exist, including Action.
//
// In all cases, the implementing class is responsible for storing the name of
// the action, the parameter type, the enabled state, the optional state type
// and the state and emitting the appropriate signals when these change. The
// implementor is responsible for filtering calls to g_action_activate() and
// g_action_change_state() for type safety and for the state being enabled.
//
// Probably the only useful thing to do with a #GAction is to put it inside of a
// ActionGroup.
//
// Action wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Action struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Action)(nil)
)

// Actioner describes Action's interface methods.
type Actioner interface {
	coreglib.Objector

	baseAction() *Action
}

var _ Actioner = (*Action)(nil)

func ifaceInitActioner(gifacePtr, data C.gpointer) {
}

func wrapAction(obj *coreglib.Object) *Action {
	return &Action{
		Object: obj,
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	return wrapAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Action) baseAction() *Action {
	return v
}

// BaseAction returns the underlying base object.
func BaseAction(obj Actioner) *Action {
	return obj.baseAction()
}
