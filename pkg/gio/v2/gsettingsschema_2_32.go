// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeSettingsSchema       = coreglib.Type(girepository.MustFind("Gio", "SettingsSchema").RegisteredGType())
	GTypeSettingsSchemaSource = coreglib.Type(girepository.MustFind("Gio", "SettingsSchemaSource").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSettingsSchema, F: marshalSettingsSchema},
		coreglib.TypeMarshaler{T: GTypeSettingsSchemaSource, F: marshalSettingsSchemaSource},
	})
}

// SettingsSchema and Schema APIs provide a mechanism for advanced control over
// the loading of schemas and a mechanism for introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
//
// An instance of this type is always passed by reference.
type SettingsSchema struct {
	*settingsSchema
}

// settingsSchema is the struct that's finalized.
type settingsSchema struct {
	native unsafe.Pointer
}

var GIRInfoSettingsSchema = girepository.MustFind("Gio", "SettingsSchema")

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SettingsSchema{&settingsSchema{(unsafe.Pointer)(b)}}, nil
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
//
// An instance of this type is always passed by reference.
type SettingsSchemaSource struct {
	*settingsSchemaSource
}

// settingsSchemaSource is the struct that's finalized.
type settingsSchemaSource struct {
	native unsafe.Pointer
}

var GIRInfoSettingsSchemaSource = girepository.MustFind("Gio", "SettingsSchemaSource")

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SettingsSchemaSource{&settingsSchemaSource{(unsafe.Pointer)(b)}}, nil
}
