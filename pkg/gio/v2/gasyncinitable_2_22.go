// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAsyncInitable = coreglib.Type(girepository.MustFind("Gio", "AsyncInitable").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAsyncInitable, F: marshalAsyncInitable},
	})
}

// AsyncInitableOverrider contains methods that are overridable.
type AsyncInitableOverrider interface {
}

// AsyncInitable: this is the asynchronous version of #GInitable; it behaves the
// same in all ways except that initialization is asynchronous. For more details
// see the descriptions on #GInitable.
//
// A class may implement both the #GInitable and Initable interfaces.
//
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways. For C
// applications you generally just call g_async_initable_new_async() directly,
// or indirectly via a foo_thing_new_async() wrapper. This will call
// g_async_initable_init_async() under the cover, calling back with NULL and a
// set GError on failure.
//
// A typical implementation might look something like this:
//
//    enum {
//       NOT_INITIALIZED,
//       INITIALIZING,
//       INITIALIZED
//    };
//
//    static void
//    _foo_ready_cb (Foo *self)
//    {
//      GList *l;
//
//      self->priv->state = INITIALIZED;
//
//      for (l = self->priv->init_results; l != NULL; l = l->next)
//        {
//          GTask *task = l->data;
//
//          if (self->priv->success)
//            g_task_return_boolean (task, TRUE);
//          else
//            g_task_return_new_error (task, ...);
//          g_object_unref (task);
//        }
//
//      g_list_free (self->priv->init_results);
//      self->priv->init_results = NULL;
//    }
//
//    static void
//    foo_init_async (GAsyncInitable       *initable,
//                    int                   io_priority,
//                    GCancellable         *cancellable,
//                    GAsyncReadyCallback   callback,
//                    gpointer              user_data)
//    {
//      Foo *self = FOO (initable);
//      GTask *task;
//
//      task = g_task_new (initable, cancellable, callback, user_data);
//      g_task_set_name (task, G_STRFUNC);
//
//      switch (self->priv->state)
//        {
//          case NOT_INITIALIZED:
//            _foo_get_ready (self);
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            self->priv->state = INITIALIZING;
//            break;
//          case INITIALIZING:
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            break;
//          case INITIALIZED:
//            if (!self->priv->success)
//              g_task_return_new_error (task, ...);
//            else
//              g_task_return_boolean (task, TRUE);
//            g_object_unref (task);
//            break;
//        }
//    }
//
//    static gboolean
//    foo_init_finish (GAsyncInitable       *initable,
//                     GAsyncResult         *result,
//                     GError              **error)
//    {
//      g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
//
//      return g_task_propagate_boolean (G_TASK (result), error);
//    }
//
//    static void
//    foo_async_initable_iface_init (gpointer g_iface,
//                                   gpointer data)
//    {
//      GAsyncInitableIface *iface = g_iface;
//
//      iface->init_async = foo_init_async;
//      iface->init_finish = foo_init_finish;
//    }.
//
// AsyncInitable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AsyncInitable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AsyncInitable)(nil)
)

// AsyncInitabler describes AsyncInitable's interface methods.
type AsyncInitabler interface {
	coreglib.Objector

	baseAsyncInitable() *AsyncInitable
}

var _ AsyncInitabler = (*AsyncInitable)(nil)

func ifaceInitAsyncInitabler(gifacePtr, data C.gpointer) {
}

func wrapAsyncInitable(obj *coreglib.Object) *AsyncInitable {
	return &AsyncInitable{
		Object: obj,
	}
}

func marshalAsyncInitable(p uintptr) (interface{}, error) {
	return wrapAsyncInitable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *AsyncInitable) baseAsyncInitable() *AsyncInitable {
	return v
}

// BaseAsyncInitable returns the underlying base object.
func BaseAsyncInitable(obj AsyncInitabler) *AsyncInitable {
	return obj.baseAsyncInitable()
}

// AsyncInitableIface provides an interface for asynchronous initializing object
// such that initialization may fail.
//
// An instance of this type is always passed by reference.
type AsyncInitableIface struct {
	*asyncInitableIface
}

// asyncInitableIface is the struct that's finalized.
type asyncInitableIface struct {
	native unsafe.Pointer
}

var GIRInfoAsyncInitableIface = girepository.MustFind("Gio", "AsyncInitableIface")
