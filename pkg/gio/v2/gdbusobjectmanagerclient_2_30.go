// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxySignal(gpointer, void*, void*, gchar*, gchar*, GVariant*, guintptr);
// extern void _gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxyPropertiesChanged(gpointer, void*, void*, GVariant*, gchar**, guintptr);
import "C"

// GType values.
var (
	GTypeDBusObjectManagerClient = coreglib.Type(girepository.MustFind("Gio", "DBusObjectManagerClient").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDBusObjectManagerClient, F: marshalDBusObjectManagerClient},
	})
}

// DBusObjectManagerClientOverrides contains methods that are overridable.
type DBusObjectManagerClientOverrides struct {
}

func defaultDBusObjectManagerClientOverrides(v *DBusObjectManagerClient) DBusObjectManagerClientOverrides {
	return DBusObjectManagerClientOverrides{}
}

// DBusObjectManagerClient is used to create, monitor and delete object proxies
// for remote objects exported by a BusObjectManagerServer (or any code
// implementing the org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is NULL.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted) â€“ BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to NULL (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is NULL when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still NULL. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. :1.42) and NULL even in the case where the name of
// interest is atomically replaced
//
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
type DBusObjectManagerClient struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncInitable
	DBusObjectManager
	Initable
}

var (
	_ coreglib.Objector = (*DBusObjectManagerClient)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusObjectManagerClient, *DBusObjectManagerClientClass, DBusObjectManagerClientOverrides](
		GTypeDBusObjectManagerClient,
		initDBusObjectManagerClientClass,
		wrapDBusObjectManagerClient,
		defaultDBusObjectManagerClientOverrides,
	)
}

func initDBusObjectManagerClientClass(gclass unsafe.Pointer, overrides DBusObjectManagerClientOverrides, classInitFunc func(*DBusObjectManagerClientClass)) {
	if classInitFunc != nil {
		class := (*DBusObjectManagerClientClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusObjectManagerClient(obj *coreglib.Object) *DBusObjectManagerClient {
	return &DBusObjectManagerClient{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		DBusObjectManager: DBusObjectManager{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	return wrapDBusObjectManagerClient(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectInterfaceProxyPropertiesChanged is emitted when one or more D-Bus
// properties on proxy changes. The local cache has already been updated when
// this signal fires. Note that both changed_properties and
// invalidated_properties are guaranteed to never be NULL (either may be empty
// though).
//
// This signal exists purely as a convenience to avoid having to connect signals
// to all interface proxies managed by manager.
//
// This signal is emitted in the [thread-default main
// context][g-main-context-push-thread-default] that manager was constructed in.
func (v *DBusObjectManagerClient) ConnectInterfaceProxyPropertiesChanged(f func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, changedProperties *glib.Variant, invalidatedProperties []string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "interface-proxy-properties-changed", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxyPropertiesChanged), f)
}

// ConnectInterfaceProxySignal is emitted when a D-Bus signal is received on
// interface_proxy.
//
// This signal exists purely as a convenience to avoid having to connect signals
// to all interface proxies managed by manager.
//
// This signal is emitted in the [thread-default main
// context][g-main-context-push-thread-default] that manager was constructed in.
func (v *DBusObjectManagerClient) ConnectInterfaceProxySignal(f func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName, signalName string, parameters *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "interface-proxy-signal", false, unsafe.Pointer(C._gotk4_gio2_DBusObjectManagerClient_ConnectInterfaceProxySignal), f)
}

// DBusObjectManagerClientClass class structure for BusObjectManagerClient.
//
// An instance of this type is always passed by reference.
type DBusObjectManagerClientClass struct {
	*dBusObjectManagerClientClass
}

// dBusObjectManagerClientClass is the struct that's finalized.
type dBusObjectManagerClientClass struct {
	native unsafe.Pointer
}

var GIRInfoDBusObjectManagerClientClass = girepository.MustFind("Gio", "DBusObjectManagerClientClass")
