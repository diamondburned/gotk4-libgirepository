// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunched(gpointer, void*, GVariant*, guintptr);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed(gpointer, gchar*, guintptr);
import "C"

// GType values.
var (
	GTypeAppInfo          = coreglib.Type(girepository.MustFind("Gio", "AppInfo").RegisteredGType())
	GTypeAppLaunchContext = coreglib.Type(girepository.MustFind("Gio", "AppLaunchContext").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAppInfo, F: marshalAppInfo},
		coreglib.TypeMarshaler{T: GTypeAppLaunchContext, F: marshalAppLaunchContext},
	})
}

// AppInfoOverrider contains methods that are overridable.
type AppInfoOverrider interface {
}

// AppInfo and LaunchContext are used for describing and launching applications
// installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key totem U and a single URI, sftp://foo/file.avi, then
// /home/user/.gvfs/sftp on foo/file.avi will be passed. This will only work if
// a set of suitable GIO extensions (such as gvfs 2.26 compiled with FUSE
// support), is available and operational; if this is not the case, the URI will
// be passed unmodified to the application. Some URIs, such as mailto:, of
// course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
// This code will work when both cdda://sr0/Track 1.wav and
// /home/user/.gvfs/cdda on sr0/Track 1.wav is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
//
// AppInfo wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AppInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppInfo)(nil)
)

// AppInfor describes AppInfo's interface methods.
type AppInfor interface {
	coreglib.Objector

	baseAppInfo() *AppInfo
}

var _ AppInfor = (*AppInfo)(nil)

func ifaceInitAppInfor(gifacePtr, data C.gpointer) {
}

func wrapAppInfo(obj *coreglib.Object) *AppInfo {
	return &AppInfo{
		Object: obj,
	}
}

func marshalAppInfo(p uintptr) (interface{}, error) {
	return wrapAppInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *AppInfo) baseAppInfo() *AppInfo {
	return v
}

// BaseAppInfo returns the underlying base object.
func BaseAppInfo(obj AppInfor) *AppInfo {
	return obj.baseAppInfo()
}

// AppLaunchContextOverrides contains methods that are overridable.
type AppLaunchContextOverrides struct {
}

func defaultAppLaunchContextOverrides(v *AppLaunchContext) AppLaunchContextOverrides {
	return AppLaunchContextOverrides{}
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppLaunchContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppLaunchContext, *AppLaunchContextClass, AppLaunchContextOverrides](
		GTypeAppLaunchContext,
		initAppLaunchContextClass,
		wrapAppLaunchContext,
		defaultAppLaunchContextOverrides,
	)
}

func initAppLaunchContextClass(gclass unsafe.Pointer, overrides AppLaunchContextOverrides, classInitFunc func(*AppLaunchContextClass)) {
	if classInitFunc != nil {
		class := (*AppLaunchContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppLaunchContext(obj *coreglib.Object) *AppLaunchContext {
	return &AppLaunchContext{
		Object: obj,
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	return wrapAppLaunchContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectLaunchFailed signal is emitted when a Info launch fails. The startup
// notification id is provided, so that the launcher can cancel the startup
// notification.
func (v *AppLaunchContext) ConnectLaunchFailed(f func(startupNotifyId string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "launch-failed", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunchFailed), f)
}

// ConnectLaunched signal is emitted when a Info is successfully launched. The
// platform_data is an GVariant dictionary mapping strings to variants (ie
// a{sv}), which contains additional, platform-specific data about this launch.
// On UNIX, at least the "pid" and "startup-notification-id" keys will be
// present.
func (v *AppLaunchContext) ConnectLaunched(f func(info AppInfor, platformData *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "launched", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunched), f)
}

// AppInfoIface: application Information interface, for operating system
// portability.
//
// An instance of this type is always passed by reference.
type AppInfoIface struct {
	*appInfoIface
}

// appInfoIface is the struct that's finalized.
type appInfoIface struct {
	native unsafe.Pointer
}

var GIRInfoAppInfoIface = girepository.MustFind("Gio", "AppInfoIface")

// AppLaunchContextClass: instance of this type is always passed by reference.
type AppLaunchContextClass struct {
	*appLaunchContextClass
}

// appLaunchContextClass is the struct that's finalized.
type appLaunchContextClass struct {
	native unsafe.Pointer
}

var GIRInfoAppLaunchContextClass = girepository.MustFind("Gio", "AppLaunchContextClass")
