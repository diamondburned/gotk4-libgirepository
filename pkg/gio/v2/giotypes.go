// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFileAttributeMatcher = coreglib.Type(girepository.MustFind("Gio", "FileAttributeMatcher").RegisteredGType())
	GTypeSrvTarget            = coreglib.Type(girepository.MustFind("Gio", "SrvTarget").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileAttributeMatcher, F: marshalFileAttributeMatcher},
		coreglib.TypeMarshaler{T: GTypeSrvTarget, F: marshalSrvTarget},
	})
}

// AsyncReadyCallback: type definition for a function that will be called back
// when an asynchronous operation within GIO has been completed. ReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later iteration of
// the [thread-default main context][g-main-context-push-thread-default] where
// the #GTask was created. All other users of ReadyCallback must likewise call
// it asynchronously in a later iteration of the main context.
type AsyncReadyCallback func(res AsyncResulter)

// FileProgressCallback: when doing file operations that may take a while, such
// as moving a file or copying a file, a progress callback is used to pass how
// far along that operation is to the application.
type FileProgressCallback func(currentNumBytes, totalNumBytes int64)

// FileReadMoreCallback: when loading the partial contents of a file with
// g_file_load_partial_contents_async(), it may become necessary to determine if
// any more data from the file should be loaded. A ReadMoreCallback function
// facilitates this by returning TRUE if more data should be read, or FALSE
// otherwise.
type FileReadMoreCallback func(fileContents string, fileSize int64) (ok bool)

// FileAttributeMatcher determines if a string matches a file attribute.
//
// An instance of this type is always passed by reference.
type FileAttributeMatcher struct {
	*fileAttributeMatcher
}

// fileAttributeMatcher is the struct that's finalized.
type fileAttributeMatcher struct {
	native unsafe.Pointer
}

var GIRInfoFileAttributeMatcher = girepository.MustFind("Gio", "FileAttributeMatcher")

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FileAttributeMatcher{&fileAttributeMatcher{(unsafe.Pointer)(b)}}, nil
}

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
//
// An instance of this type is always passed by reference.
type SrvTarget struct {
	*srvTarget
}

// srvTarget is the struct that's finalized.
type srvTarget struct {
	native unsafe.Pointer
}

var GIRInfoSrvTarget = girepository.MustFind("Gio", "SrvTarget")

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SrvTarget{&srvTarget{(unsafe.Pointer)(b)}}, nil
}
