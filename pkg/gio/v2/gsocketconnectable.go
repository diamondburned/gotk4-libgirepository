// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeSocketConnectable = coreglib.Type(girepository.MustFind("Gio", "SocketConnectable").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSocketConnectable, F: marshalSocketConnectable},
	})
}

// SocketConnectableOverrider contains methods that are overridable.
type SocketConnectableOverrider interface {
}

// SocketConnectable objects that describe one or more potential socket
// endpoints implement Connectable. Callers can then use
// g_socket_connectable_enumerate() to get a AddressEnumerator to try out each
// socket address in turn until one succeeds, as shown in the sample code below.
//
//    MyConnectionType *
//    connect_to_host (const char    *hostname,
//                     guint16        port,
//                     GCancellable  *cancellable,
//                     GError       **error)
//    {
//      MyConnection *conn = NULL;
//      GSocketConnectable *addr;
//      GSocketAddressEnumerator *enumerator;
//      GSocketAddress *sockaddr;
//      GError *conn_error = NULL;
//
//      addr = g_network_address_new (hostname, port);
//      enumerator = g_socket_connectable_enumerate (addr);
//      g_object_unref (addr);
//
//      // Try each sockaddr until we succeed. Record the first connection error,
//      // but not any further ones (since they'll probably be basically the same
//      // as the first).
//      while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//        {
//          conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
//          g_object_unref (sockaddr);
//        }
//      g_object_unref (enumerator);
//
//      if (conn)
//        {
//          if (conn_error)
//            {
//              // We couldn't connect to the first address, but we succeeded
//              // in connecting to a later address.
//              g_error_free (conn_error);
//            }
//          return conn;
//        }
//      else if (error)
//        {
//          /// Either initial lookup failed, or else the caller cancelled us.
//          if (conn_error)
//            g_error_free (conn_error);
//          return NULL;
//        }
//      else
//        {
//          g_error_propagate (error, conn_error);
//          return NULL;
//        }
//    }.
//
// SocketConnectable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type SocketConnectable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*SocketConnectable)(nil)
)

// SocketConnectabler describes SocketConnectable's interface methods.
type SocketConnectabler interface {
	coreglib.Objector

	baseSocketConnectable() *SocketConnectable
}

var _ SocketConnectabler = (*SocketConnectable)(nil)

func ifaceInitSocketConnectabler(gifacePtr, data C.gpointer) {
}

func wrapSocketConnectable(obj *coreglib.Object) *SocketConnectable {
	return &SocketConnectable{
		Object: obj,
	}
}

func marshalSocketConnectable(p uintptr) (interface{}, error) {
	return wrapSocketConnectable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *SocketConnectable) baseSocketConnectable() *SocketConnectable {
	return v
}

// BaseSocketConnectable returns the underlying base object.
func BaseSocketConnectable(obj SocketConnectabler) *SocketConnectable {
	return obj.baseSocketConnectable()
}

// SocketConnectableIface provides an interface for returning a
// AddressEnumerator and AddressEnumerator
//
// An instance of this type is always passed by reference.
type SocketConnectableIface struct {
	*socketConnectableIface
}

// socketConnectableIface is the struct that's finalized.
type socketConnectableIface struct {
	native unsafe.Pointer
}

var GIRInfoSocketConnectableIface = girepository.MustFind("Gio", "SocketConnectableIface")
