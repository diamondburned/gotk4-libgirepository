// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_DBusProxy_ConnectGSignal(gpointer, gchar*, gchar*, GVariant*, guintptr);
// extern void _gotk4_gio2_DBusProxy_ConnectGPropertiesChanged(gpointer, GVariant*, gchar**, guintptr);
import "C"

// GType values.
var (
	GTypeDBusProxy = coreglib.Type(girepository.MustFind("Gio", "DBusProxy").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDBusProxy, F: marshalDBusProxy},
	})
}

// DBusProxyOverrides contains methods that are overridable.
type DBusProxyOverrides struct {
}

func defaultDBusProxyOverrides(v *DBusProxy) DBusProxyOverrides {
	return DBusProxyOverrides{}
}

// DBusProxy is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c).
type DBusProxy struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncInitable
	DBusInterface
	Initable
}

var (
	_ coreglib.Objector = (*DBusProxy)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DBusProxy, *DBusProxyClass, DBusProxyOverrides](
		GTypeDBusProxy,
		initDBusProxyClass,
		wrapDBusProxy,
		defaultDBusProxyOverrides,
	)
}

func initDBusProxyClass(gclass unsafe.Pointer, overrides DBusProxyOverrides, classInitFunc func(*DBusProxyClass)) {
	if classInitFunc != nil {
		class := (*DBusProxyClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDBusProxy(obj *coreglib.Object) *DBusProxy {
	return &DBusProxy{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		DBusInterface: DBusInterface{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	return wrapDBusProxy(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectGPropertiesChanged is emitted when one or more D-Bus properties on
// proxy changes. The local cache has already been updated when this signal
// fires. Note that both changed_properties and invalidated_properties are
// guaranteed to never be NULL (either may be empty though).
//
// If the proxy has the flag G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES set,
// then invalidated_properties will always be empty.
//
// This signal corresponds to the PropertiesChanged D-Bus signal on the
// org.freedesktop.DBus.Properties interface.
func (v *DBusProxy) ConnectGPropertiesChanged(f func(changedProperties *glib.Variant, invalidatedProperties []string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "g-properties-changed", false, unsafe.Pointer(C._gotk4_gio2_DBusProxy_ConnectGPropertiesChanged), f)
}

// ConnectGSignal is emitted when a signal from the remote object and interface
// that proxy is for, has been received.
func (v *DBusProxy) ConnectGSignal(f func(senderName, signalName string, parameters *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "g-signal", false, unsafe.Pointer(C._gotk4_gio2_DBusProxy_ConnectGSignal), f)
}

// DBusProxyClass class structure for BusProxy.
//
// An instance of this type is always passed by reference.
type DBusProxyClass struct {
	*dBusProxyClass
}

// dBusProxyClass is the struct that's finalized.
type dBusProxyClass struct {
	native unsafe.Pointer
}

var GIRInfoDBusProxyClass = girepository.MustFind("Gio", "DBusProxyClass")
