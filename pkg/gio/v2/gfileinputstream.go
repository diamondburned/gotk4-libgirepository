// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFileInputStream = coreglib.Type(girepository.MustFind("Gio", "FileInputStream").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileInputStream, F: marshalFileInputStream},
	})
}

// FileInputStreamOverrides contains methods that are overridable.
type FileInputStreamOverrides struct {
}

func defaultFileInputStreamOverrides(v *FileInputStream) FileInputStreamOverrides {
	return FileInputStreamOverrides{}
}

// FileInputStream provides input streams that take their content from a file.
//
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
type FileInputStream struct {
	_ [0]func() // equal guard
	InputStream

	*coreglib.Object
	Seekable
}

var (
	_ InputStreamer     = (*FileInputStream)(nil)
	_ coreglib.Objector = (*FileInputStream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileInputStream, *FileInputStreamClass, FileInputStreamOverrides](
		GTypeFileInputStream,
		initFileInputStreamClass,
		wrapFileInputStream,
		defaultFileInputStreamOverrides,
	)
}

func initFileInputStreamClass(gclass unsafe.Pointer, overrides FileInputStreamOverrides, classInitFunc func(*FileInputStreamClass)) {
	if classInitFunc != nil {
		class := (*FileInputStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileInputStream(obj *coreglib.Object) *FileInputStream {
	return &FileInputStream{
		InputStream: InputStream{
			Object: obj,
		},
		Object: obj,
		Seekable: Seekable{
			Object: obj,
		},
	}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	return wrapFileInputStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FileInputStreamClass: instance of this type is always passed by reference.
type FileInputStreamClass struct {
	*fileInputStreamClass
}

// fileInputStreamClass is the struct that's finalized.
type fileInputStreamClass struct {
	native unsafe.Pointer
}

var GIRInfoFileInputStreamClass = girepository.MustFind("Gio", "FileInputStreamClass")
