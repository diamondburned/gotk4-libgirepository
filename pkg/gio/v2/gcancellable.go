// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_Cancellable_ConnectCancelled(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeCancellable = coreglib.Type(girepository.MustFind("Gio", "Cancellable").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCancellable, F: marshalCancellable},
	})
}

// CancellableOverrides contains methods that are overridable.
type CancellableOverrides struct {
}

func defaultCancellableOverrides(v *Cancellable) CancellableOverrides {
	return CancellableOverrides{}
}

// Cancellable is a thread-safe operation cancellation stack used throughout GIO
// to allow for cancellation of synchronous and asynchronous operations.
type Cancellable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Cancellable)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Cancellable, *CancellableClass, CancellableOverrides](
		GTypeCancellable,
		initCancellableClass,
		wrapCancellable,
		defaultCancellableOverrides,
	)
}

func initCancellableClass(gclass unsafe.Pointer, overrides CancellableOverrides, classInitFunc func(*CancellableClass)) {
	if classInitFunc != nil {
		class := (*CancellableClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCancellable(obj *coreglib.Object) *Cancellable {
	return &Cancellable{
		Object: obj,
	}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	return wrapCancellable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCancelled is emitted when the operation has been cancelled.
//
// Can be used by implementations of cancellable operations. If the operation is
// cancelled from another thread, the signal will be emitted in the thread that
// cancelled the operation, not the thread that is running the operation.
//
// Note that disconnecting from this signal (or any signal) in a multi-threaded
// program is prone to race conditions. For instance it is possible that a
// signal handler may be invoked even after a call to
// g_signal_handler_disconnect() for that handler has already returned.
//
// There is also a problem when cancellation happens right before connecting to
// the signal. If this happens the signal will unexpectedly not be emitted, and
// checking before connecting to the signal leaves a race condition where this
// is still happening.
//
// In order to make it safe and easy to connect handlers there are two helper
// functions: g_cancellable_connect() and g_cancellable_disconnect() which
// protect against problems like this.
//
// An example of how to us this:
//
//        // Make sure we don't do unnecessary work if already cancelled
//        if (g_cancellable_set_error_if_cancelled (cancellable, error))
//          return;
//
//        // Set up all the data needed to be able to handle cancellation
//        // of the operation
//        my_data = my_data_new (...);
//
//        id = 0;
//        if (cancellable)
//          id = g_cancellable_connect (cancellable,
//        			      G_CALLBACK (cancelled_handler)
//        			      data, NULL);
//
//        // cancellable operation here...
//
//        g_cancellable_disconnect (cancellable, id);
//
//        // cancelled_handler is never called after this, it is now safe
//        // to free the data
//        my_data_free (my_data);
//
// Note that the cancelled signal is emitted in the thread that the user
// cancelled from, which may be the main thread. So, the cancellable signal
// should not do something that can block.
func (v *Cancellable) ConnectCancelled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "cancelled", false, unsafe.Pointer(C._gotk4_gio2_Cancellable_ConnectCancelled), f)
}

// CancellableClass: instance of this type is always passed by reference.
type CancellableClass struct {
	*cancellableClass
}

// cancellableClass is the struct that's finalized.
type cancellableClass struct {
	native unsafe.Pointer
}

var GIRInfoCancellableClass = girepository.MustFind("Gio", "CancellableClass")
