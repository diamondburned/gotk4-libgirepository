// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_Drive_ConnectStopButton(gpointer, guintptr);
// extern void _gotk4_gio2_Drive_ConnectEjectButton(gpointer, guintptr);
// extern void _gotk4_gio2_Drive_ConnectDisconnected(gpointer, guintptr);
// extern void _gotk4_gio2_Drive_ConnectChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeDrive = coreglib.Type(girepository.MustFind("Gio", "Drive").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDrive, F: marshalDrive},
	})
}

// DriveOverrider contains methods that are overridable.
type DriveOverrider interface {
}

// Drive - this represent a piece of hardware connected to the machine. It's
// generally only created for removable hardware or hardware with removable
// media.
//
// #GDrive is a container class for #GVolume objects that stem from the same
// piece of media. As such, #GDrive abstracts a drive with (or without)
// removable media and provides operations for querying whether media is
// available, determining whether media change is automatically detected and
// ejecting the media.
//
// If the #GDrive reports that media isn't automatically detected, one can poll
// for media; typically one should not do this periodically as a poll for media
// operation is potentially expensive and may spin up the drive creating noise.
//
// #GDrive supports starting and stopping drives with authentication support for
// the former. This can be used to support a diverse set of use cases including
// connecting/disconnecting iSCSI devices, powering down external disk
// enclosures and starting/stopping multi-disk devices such as RAID devices.
// Note that the actual semantics and side-effects of starting/stopping a
// #GDrive may vary according to implementation. To choose the correct verbs in
// e.g. a file manager, use g_drive_get_start_stop_type().
//
// For porting from GnomeVFS note that there is no equivalent of #GDrive in that
// API.
//
// Drive wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Drive struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Drive)(nil)
)

// Driver describes Drive's interface methods.
type Driver interface {
	coreglib.Objector

	baseDrive() *Drive
}

var _ Driver = (*Drive)(nil)

func ifaceInitDriver(gifacePtr, data C.gpointer) {
}

func wrapDrive(obj *coreglib.Object) *Drive {
	return &Drive{
		Object: obj,
	}
}

func marshalDrive(p uintptr) (interface{}, error) {
	return wrapDrive(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Drive) baseDrive() *Drive {
	return v
}

// BaseDrive returns the underlying base object.
func BaseDrive(obj Driver) *Drive {
	return obj.baseDrive()
}

// ConnectChanged is emitted when the drive's state has changed.
func (v *Drive) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "changed", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectChanged), f)
}

// ConnectDisconnected: this signal is emitted when the #GDrive have been
// disconnected. If the recipient is holding references to the object they
// should release them so the object can be finalized.
func (v *Drive) ConnectDisconnected(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "disconnected", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectDisconnected), f)
}

// ConnectEjectButton is emitted when the physical eject button (if any) of a
// drive has been pressed.
func (v *Drive) ConnectEjectButton(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "eject-button", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectEjectButton), f)
}

// ConnectStopButton is emitted when the physical stop button (if any) of a
// drive has been pressed.
func (v *Drive) ConnectStopButton(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "stop-button", false, unsafe.Pointer(C._gotk4_gio2_Drive_ConnectStopButton), f)
}

// DriveIface: interface for creating #GDrive implementations.
//
// An instance of this type is always passed by reference.
type DriveIface struct {
	*driveIface
}

// driveIface is the struct that's finalized.
type driveIface struct {
	native unsafe.Pointer
}

var GIRInfoDriveIface = girepository.MustFind("Gio", "DriveIface")
