// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_atk1_Text_ConnectTextSelectionChanged(gpointer, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextRemove(gpointer, gint, gint, gchar*, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextInsert(gpointer, gint, gint, gchar*, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextChanged(gpointer, gint, gint, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextCaretMoved(gpointer, gint, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextAttributesChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeTextAttribute   = coreglib.Type(girepository.MustFind("Atk", "TextAttribute").RegisteredGType())
	GTypeTextBoundary    = coreglib.Type(girepository.MustFind("Atk", "TextBoundary").RegisteredGType())
	GTypeTextClipType    = coreglib.Type(girepository.MustFind("Atk", "TextClipType").RegisteredGType())
	GTypeTextGranularity = coreglib.Type(girepository.MustFind("Atk", "TextGranularity").RegisteredGType())
	GTypeText            = coreglib.Type(girepository.MustFind("Atk", "Text").RegisteredGType())
	GTypeTextRange       = coreglib.Type(girepository.MustFind("Atk", "TextRange").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTextAttribute, F: marshalTextAttribute},
		coreglib.TypeMarshaler{T: GTypeTextBoundary, F: marshalTextBoundary},
		coreglib.TypeMarshaler{T: GTypeTextClipType, F: marshalTextClipType},
		coreglib.TypeMarshaler{T: GTypeTextGranularity, F: marshalTextGranularity},
		coreglib.TypeMarshaler{T: GTypeText, F: marshalText},
		coreglib.TypeMarshaler{T: GTypeTextRange, F: marshalTextRange},
	})
}

// TextAttribute describes the text attributes supported.
type TextAttribute C.gint

const (
	// TextAttrInvalid: invalid attribute, like bad spelling or grammar.
	TextAttrInvalid TextAttribute = iota
	// TextAttrLeftMargin: pixel width of the left margin.
	TextAttrLeftMargin
	// TextAttrRightMargin: pixel width of the right margin.
	TextAttrRightMargin
	// TextAttrIndent: number of pixels that the text is indented.
	TextAttrIndent
	// TextAttrInvisible: either "true" or "false" indicating whether text is
	// visible or not.
	TextAttrInvisible
	// TextAttrEditable: either "true" or "false" indicating whether text is
	// editable or not.
	TextAttrEditable
	// TextAttrPixelsAboveLines pixels of blank space to leave above each
	// newline-terminated line.
	TextAttrPixelsAboveLines
	// TextAttrPixelsBelowLines pixels of blank space to leave below each
	// newline-terminated line.
	TextAttrPixelsBelowLines
	// TextAttrPixelsInsideWrap pixels of blank space to leave between wrapped
	// lines inside the same newline-terminated line (paragraph).
	TextAttrPixelsInsideWrap
	// TextAttrBgFullHeight: "true" or "false" whether to make the background
	// color for each character the height of the highest font used on the
	// current line, or the height of the font used for the current character.
	TextAttrBgFullHeight
	// TextAttrRise: number of pixels that the characters are risen above the
	// baseline. See also ATK_TEXT_ATTR_TEXT_POSITION.
	TextAttrRise
	// TextAttrUnderline: "none", "single", "double", "low", or "error".
	TextAttrUnderline
	// TextAttrStrikethrough: "true" or "false" whether the text is
	// strikethrough.
	TextAttrStrikethrough
	// TextAttrSize: size of the characters in points. eg: 10.
	TextAttrSize
	// TextAttrScale: scale of the characters. The value is a string
	// representation of a double.
	TextAttrScale
	// TextAttrWeight: weight of the characters.
	TextAttrWeight
	// TextAttrLanguage: language used.
	TextAttrLanguage
	// TextAttrFamilyName: font family name.
	TextAttrFamilyName
	// TextAttrBgColor: background color. The value is an RGB value of the
	// format "u,u,u".
	TextAttrBgColor
	// TextAttrFgColor: foreground color. The value is an RGB value of the
	// format "u,u,u".
	TextAttrFgColor
	// TextAttrBgStipple: "true" if a Bitmap is set for stippling the background
	// color.
	TextAttrBgStipple
	// TextAttrFgStipple: "true" if a Bitmap is set for stippling the foreground
	// color.
	TextAttrFgStipple
	// TextAttrWrapMode: wrap mode of the text, if any. Values are "none",
	// "char", "word", or "word_char".
	TextAttrWrapMode
	// TextAttrDirection: direction of the text, if set. Values are "none",
	// "ltr" or "rtl".
	TextAttrDirection
	// TextAttrJustification: justification of the text, if set. Values are
	// "left", "right", "center" or "fill".
	TextAttrJustification
	// TextAttrStretch: stretch of the text, if set. Values are
	// "ultra_condensed", "extra_condensed", "condensed", "semi_condensed",
	// "normal", "semi_expanded", "expanded", "extra_expanded" or
	// "ultra_expanded".
	TextAttrStretch
	// TextAttrVariant: capitalization variant of the text, if set. Values are
	// "normal" or "small_caps".
	TextAttrVariant
	// TextAttrStyle: slant style of the text, if set. Values are "normal",
	// "oblique" or "italic".
	TextAttrStyle
	// TextAttrTextPosition: vertical position with respect to the baseline.
	// Values are "baseline", "super", or "sub". Note that a super or sub text
	// attribute refers to position with respect to the baseline of the prior
	// character.
	TextAttrTextPosition
	// TextAttrLastDefined: not a valid text attribute, used for finding end of
	// enumeration.
	TextAttrLastDefined
)

func marshalTextAttribute(p uintptr) (interface{}, error) {
	return TextAttribute(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextAttribute.
func (t TextAttribute) String() string {
	switch t {
	case TextAttrInvalid:
		return "Invalid"
	case TextAttrLeftMargin:
		return "LeftMargin"
	case TextAttrRightMargin:
		return "RightMargin"
	case TextAttrIndent:
		return "Indent"
	case TextAttrInvisible:
		return "Invisible"
	case TextAttrEditable:
		return "Editable"
	case TextAttrPixelsAboveLines:
		return "PixelsAboveLines"
	case TextAttrPixelsBelowLines:
		return "PixelsBelowLines"
	case TextAttrPixelsInsideWrap:
		return "PixelsInsideWrap"
	case TextAttrBgFullHeight:
		return "BgFullHeight"
	case TextAttrRise:
		return "Rise"
	case TextAttrUnderline:
		return "Underline"
	case TextAttrStrikethrough:
		return "Strikethrough"
	case TextAttrSize:
		return "Size"
	case TextAttrScale:
		return "Scale"
	case TextAttrWeight:
		return "Weight"
	case TextAttrLanguage:
		return "Language"
	case TextAttrFamilyName:
		return "FamilyName"
	case TextAttrBgColor:
		return "BgColor"
	case TextAttrFgColor:
		return "FgColor"
	case TextAttrBgStipple:
		return "BgStipple"
	case TextAttrFgStipple:
		return "FgStipple"
	case TextAttrWrapMode:
		return "WrapMode"
	case TextAttrDirection:
		return "Direction"
	case TextAttrJustification:
		return "Justification"
	case TextAttrStretch:
		return "Stretch"
	case TextAttrVariant:
		return "Variant"
	case TextAttrStyle:
		return "Style"
	case TextAttrTextPosition:
		return "TextPosition"
	case TextAttrLastDefined:
		return "LastDefined"
	default:
		return fmt.Sprintf("TextAttribute(%d)", t)
	}
}

// TextBoundary: text boundary types used for specifying boundaries for regions
// of text. This enumeration is deprecated since 2.9.4 and should not be used.
// Use AtkTextGranularity with #atk_text_get_string_at_offset instead.
type TextBoundary C.gint

const (
	// TextBoundaryChar: boundary is the boundary between characters (including
	// non-printing characters).
	TextBoundaryChar TextBoundary = iota
	// TextBoundaryWordStart: boundary is the start (i.e. first character) of a
	// word.
	TextBoundaryWordStart
	// TextBoundaryWordEnd: boundary is the end (i.e. last character) of a word.
	TextBoundaryWordEnd
	// TextBoundarySentenceStart: boundary is the first character in a sentence.
	TextBoundarySentenceStart
	// TextBoundarySentenceEnd: boundary is the last (terminal) character in a
	// sentence; in languages which use "sentence stop" punctuation such as
	// English, the boundary is thus the '.', '?', or similar terminal
	// punctuation character.
	TextBoundarySentenceEnd
	// TextBoundaryLineStart: boundary is the initial character of the content
	// or a character immediately following a newline, linefeed, or return
	// character.
	TextBoundaryLineStart
	// TextBoundaryLineEnd: boundary is the linefeed, or return character.
	TextBoundaryLineEnd
)

func marshalTextBoundary(p uintptr) (interface{}, error) {
	return TextBoundary(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextBoundary.
func (t TextBoundary) String() string {
	switch t {
	case TextBoundaryChar:
		return "Char"
	case TextBoundaryWordStart:
		return "WordStart"
	case TextBoundaryWordEnd:
		return "WordEnd"
	case TextBoundarySentenceStart:
		return "SentenceStart"
	case TextBoundarySentenceEnd:
		return "SentenceEnd"
	case TextBoundaryLineStart:
		return "LineStart"
	case TextBoundaryLineEnd:
		return "LineEnd"
	default:
		return fmt.Sprintf("TextBoundary(%d)", t)
	}
}

// TextClipType describes the type of clipping required.
type TextClipType C.gint

const (
	// TextClipNone: no clipping to be done.
	TextClipNone TextClipType = iota
	// TextClipMin: text clipped by min coordinate is omitted.
	TextClipMin
	// TextClipMax: text clipped by max coordinate is omitted.
	TextClipMax
	// TextClipBoth: only text fully within mix/max bound is retained.
	TextClipBoth
)

func marshalTextClipType(p uintptr) (interface{}, error) {
	return TextClipType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextClipType.
func (t TextClipType) String() string {
	switch t {
	case TextClipNone:
		return "None"
	case TextClipMin:
		return "Min"
	case TextClipMax:
		return "Max"
	case TextClipBoth:
		return "Both"
	default:
		return fmt.Sprintf("TextClipType(%d)", t)
	}
}

// TextGranularity: text granularity types used for specifying the granularity
// of the region of text we are interested in.
type TextGranularity C.gint

const (
	// TextGranularityChar: granularity is defined by the boundaries between
	// characters (including non-printing characters).
	TextGranularityChar TextGranularity = iota
	// TextGranularityWord: granularity is defined by the boundaries of a word,
	// starting at the beginning of the current word and finishing at the
	// beginning of the following one, if present.
	TextGranularityWord
	// TextGranularitySentence: granularity is defined by the boundaries of a
	// sentence, starting at the beginning of the current sentence and finishing
	// at the beginning of the following one, if present.
	TextGranularitySentence
	// TextGranularityLine: granularity is defined by the boundaries of a line,
	// starting at the beginning of the current line and finishing at the
	// beginning of the following one, if present.
	TextGranularityLine
	// TextGranularityParagraph: granularity is defined by the boundaries of a
	// paragraph, starting at the beginning of the current paragraph and
	// finishing at the beginning of the following one, if present.
	TextGranularityParagraph
)

func marshalTextGranularity(p uintptr) (interface{}, error) {
	return TextGranularity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextGranularity.
func (t TextGranularity) String() string {
	switch t {
	case TextGranularityChar:
		return "Char"
	case TextGranularityWord:
		return "Word"
	case TextGranularitySentence:
		return "Sentence"
	case TextGranularityLine:
		return "Line"
	case TextGranularityParagraph:
		return "Paragraph"
	default:
		return fmt.Sprintf("TextGranularity(%d)", t)
	}
}

// TextOverrider contains methods that are overridable.
type TextOverrider interface {
}

// Text should be implemented by Objects on behalf of widgets that have text
// content which is either attributed or otherwise non-trivial. Objects whose
// text content is simple, unattributed, and very brief may expose that content
// via #atk_object_get_name instead; however if the text is editable,
// multi-line, typically longer than three or four words, attributed,
// selectable, or if the object already uses the 'name' ATK property for other
// information, the Text interface should be used to expose the text content. In
// the case of editable text content, EditableText (a subtype of the Text
// interface) should be implemented instead.
//
//    Text provides not only traversal facilities and change
//
// notification for text content, but also caret tracking and glyph bounding box
// calculations. Note that the text strings are exposed as UTF-8, and are
// therefore potentially multi-byte, and caret-to-byte offset mapping makes no
// assumptions about the character length; also bounding box glyph-to-offset
// mapping may be complex for languages which use ligatures.
//
// Text wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Text struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Text)(nil)
)

// Texter describes Text's interface methods.
type Texter interface {
	coreglib.Objector

	baseText() *Text
}

var _ Texter = (*Text)(nil)

func ifaceInitTexter(gifacePtr, data C.gpointer) {
}

func wrapText(obj *coreglib.Object) *Text {
	return &Text{
		Object: obj,
	}
}

func marshalText(p uintptr) (interface{}, error) {
	return wrapText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Text) baseText() *Text {
	return v
}

// BaseText returns the underlying base object.
func BaseText(obj Texter) *Text {
	return obj.baseText()
}

// ConnectTextAttributesChanged: "text-attributes-changed" signal is emitted
// when the text attributes of the text of an object which implements AtkText
// changes.
func (v *Text) ConnectTextAttributesChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "text-attributes-changed", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextAttributesChanged), f)
}

// ConnectTextCaretMoved: "text-caret-moved" signal is emitted when the caret
// position of the text of an object which implements AtkText changes.
func (v *Text) ConnectTextCaretMoved(f func(arg1 int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "text-caret-moved", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextCaretMoved), f)
}

// ConnectTextChanged: "text-changed" signal is emitted when the text of the
// object which implements the AtkText interface changes, This signal will have
// a detail which is either "insert" or "delete" which identifies whether the
// text change was an insertion or a deletion.
func (v *Text) ConnectTextChanged(f func(arg1, arg2 int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "text-changed", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextChanged), f)
}

// ConnectTextInsert: "text-insert" signal is emitted when a new text is
// inserted. If the signal was not triggered by the user (e.g. typing or pasting
// text), the "system" detail should be included.
func (v *Text) ConnectTextInsert(f func(arg1, arg2 int, arg3 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "text-insert", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextInsert), f)
}

// ConnectTextRemove: "text-remove" signal is emitted when a new text is
// removed. If the signal was not triggered by the user (e.g. typing or pasting
// text), the "system" detail should be included.
func (v *Text) ConnectTextRemove(f func(arg1, arg2 int, arg3 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "text-remove", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextRemove), f)
}

// ConnectTextSelectionChanged: "text-selection-changed" signal is emitted when
// the selected text of an object which implements AtkText changes.
func (v *Text) ConnectTextSelectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "text-selection-changed", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextSelectionChanged), f)
}

// TextIface: instance of this type is always passed by reference.
type TextIface struct {
	*textIface
}

// textIface is the struct that's finalized.
type textIface struct {
	native unsafe.Pointer
}

var GIRInfoTextIface = girepository.MustFind("Atk", "TextIface")

// TextRange: structure used to describe a text range.
//
// An instance of this type is always passed by reference.
type TextRange struct {
	*textRange
}

// textRange is the struct that's finalized.
type textRange struct {
	native unsafe.Pointer
}

var GIRInfoTextRange = girepository.MustFind("Atk", "TextRange")

func marshalTextRange(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TextRange{&textRange{(unsafe.Pointer)(b)}}, nil
}

// TextRectangle: structure used to store a rectangle used by AtkText.
//
// An instance of this type is always passed by reference.
type TextRectangle struct {
	*textRectangle
}

// textRectangle is the struct that's finalized.
type textRectangle struct {
	native unsafe.Pointer
}

var GIRInfoTextRectangle = girepository.MustFind("Atk", "TextRectangle")

// NewTextRectangle creates a new TextRectangle instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewTextRectangle(x, y, width, height int) TextRectangle {
	var f0 C.gint // out
	f0 = C.gint(x)
	var f1 C.gint // out
	f1 = C.gint(y)
	var f2 C.gint // out
	f2 = C.gint(width)
	var f3 C.gint // out
	f3 = C.gint(height)

	size := GIRInfoTextRectangle.StructSize()
	native := make([]byte, size)
	gextras.Sink(&native[0])

	offset0 := GIRInfoTextRectangle.StructFieldOffset("x")
	valptr0 := (*C.gint)(unsafe.Add(unsafe.Pointer(&native[0]), offset0))
	*valptr0 = f0

	offset1 := GIRInfoTextRectangle.StructFieldOffset("y")
	valptr1 := (*C.gint)(unsafe.Add(unsafe.Pointer(&native[0]), offset1))
	*valptr1 = f1

	offset2 := GIRInfoTextRectangle.StructFieldOffset("width")
	valptr2 := (*C.gint)(unsafe.Add(unsafe.Pointer(&native[0]), offset2))
	*valptr2 = f2

	offset3 := GIRInfoTextRectangle.StructFieldOffset("height")
	valptr3 := (*C.gint)(unsafe.Add(unsafe.Pointer(&native[0]), offset3))
	*valptr3 = f3

	return *(*TextRectangle)(gextras.NewStructNative(unsafe.Pointer(&native[0])))
}

// X: horizontal coordinate of a rectangle.
func (t *TextRectangle) X() int {
	offset := GIRInfoTextRectangle.StructFieldOffset("x")
	valptr := (*int)(unsafe.Add(t.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Y: vertical coordinate of a rectangle.
func (t *TextRectangle) Y() int {
	offset := GIRInfoTextRectangle.StructFieldOffset("y")
	valptr := (*int)(unsafe.Add(t.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width: width of a rectangle.
func (t *TextRectangle) Width() int {
	offset := GIRInfoTextRectangle.StructFieldOffset("width")
	valptr := (*int)(unsafe.Add(t.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height: height of a rectangle.
func (t *TextRectangle) Height() int {
	offset := GIRInfoTextRectangle.StructFieldOffset("height")
	valptr := (*int)(unsafe.Add(t.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// X: horizontal coordinate of a rectangle.
func (t *TextRectangle) SetX(x int) {
	offset := GIRInfoTextRectangle.StructFieldOffset("x")
	valptr := (*C.gint)(unsafe.Add(t.native, offset))
	*valptr = C.gint(x)
}

// Y: vertical coordinate of a rectangle.
func (t *TextRectangle) SetY(y int) {
	offset := GIRInfoTextRectangle.StructFieldOffset("y")
	valptr := (*C.gint)(unsafe.Add(t.native, offset))
	*valptr = C.gint(y)
}

// Width: width of a rectangle.
func (t *TextRectangle) SetWidth(width int) {
	offset := GIRInfoTextRectangle.StructFieldOffset("width")
	valptr := (*C.gint)(unsafe.Add(t.native, offset))
	*valptr = C.gint(width)
}

// Height: height of a rectangle.
func (t *TextRectangle) SetHeight(height int) {
	offset := GIRInfoTextRectangle.StructFieldOffset("height")
	valptr := (*C.gint)(unsafe.Add(t.native, offset))
	*valptr = C.gint(height)
}
