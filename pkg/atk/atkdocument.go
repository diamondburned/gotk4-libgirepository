// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_atk1_Document_ConnectReload(gpointer, guintptr);
// extern void _gotk4_atk1_Document_ConnectPageChanged(gpointer, gint, guintptr);
// extern void _gotk4_atk1_Document_ConnectLoadStopped(gpointer, guintptr);
// extern void _gotk4_atk1_Document_ConnectLoadComplete(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeDocument = coreglib.Type(girepository.MustFind("Atk", "Document").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDocument, F: marshalDocument},
	})
}

// DocumentOverrider contains methods that are overridable.
type DocumentOverrider interface {
}

// Document interface should be supported by any object whose content is a
// representation or view of a document. The AtkDocument interface should appear
// on the toplevel container for the document content; however AtkDocument
// instances may be nested (i.e. an AtkDocument may be a descendant of another
// AtkDocument) in those cases where one document contains "embedded content"
// which can reasonably be considered a document in its own right.
//
// Document wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Document struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Document)(nil)
)

// Documenter describes Document's interface methods.
type Documenter interface {
	coreglib.Objector

	baseDocument() *Document
}

var _ Documenter = (*Document)(nil)

func ifaceInitDocumenter(gifacePtr, data C.gpointer) {
}

func wrapDocument(obj *coreglib.Object) *Document {
	return &Document{
		Object: obj,
	}
}

func marshalDocument(p uintptr) (interface{}, error) {
	return wrapDocument(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Document) baseDocument() *Document {
	return v
}

// BaseDocument returns the underlying base object.
func BaseDocument(obj Documenter) *Document {
	return obj.baseDocument()
}

// ConnectLoadComplete: 'load-complete' signal is emitted when a pending load of
// a static document has completed. This signal is to be expected by ATK clients
// if and when AtkDocument implementors expose ATK_STATE_BUSY. If the state of
// an AtkObject which implements AtkDocument does not include ATK_STATE_BUSY, it
// should be safe for clients to assume that the AtkDocument's static contents
// are fully loaded into the container. (Dynamic document contents should be
// exposed via other signals.).
func (v *Document) ConnectLoadComplete(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "load-complete", false, unsafe.Pointer(C._gotk4_atk1_Document_ConnectLoadComplete), f)
}

// ConnectLoadStopped: 'load-stopped' signal is emitted when a pending load of
// document contents is cancelled, paused, or otherwise interrupted by the user
// or application logic. It should not however be emitted while waiting for a
// resource (for instance while blocking on a file or network read) unless a
// user-significant timeout has occurred.
func (v *Document) ConnectLoadStopped(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "load-stopped", false, unsafe.Pointer(C._gotk4_atk1_Document_ConnectLoadStopped), f)
}

// ConnectPageChanged: 'page-changed' signal is emitted when the current page of
// a document changes, e.g. pressing page up/down in a document viewer.
func (v *Document) ConnectPageChanged(f func(pageNumber int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-changed", false, unsafe.Pointer(C._gotk4_atk1_Document_ConnectPageChanged), f)
}

// ConnectReload: 'reload' signal is emitted when the contents of a document is
// refreshed from its source. Once 'reload' has been emitted, a matching
// 'load-complete' or 'load-stopped' signal should follow, which clients may
// await before interrogating ATK for the latest document content.
func (v *Document) ConnectReload(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "reload", false, unsafe.Pointer(C._gotk4_atk1_Document_ConnectReload), f)
}

// DocumentIface: instance of this type is always passed by reference.
type DocumentIface struct {
	*documentIface
}

// documentIface is the struct that's finalized.
type documentIface struct {
	native unsafe.Pointer
}

var GIRInfoDocumentIface = girepository.MustFind("Atk", "DocumentIface")
