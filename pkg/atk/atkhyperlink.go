// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_atk1_Hyperlink_ConnectLinkActivated(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeHyperlinkStateFlags = coreglib.Type(girepository.MustFind("Atk", "HyperlinkStateFlags").RegisteredGType())
	GTypeHyperlink           = coreglib.Type(girepository.MustFind("Atk", "Hyperlink").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeHyperlinkStateFlags, F: marshalHyperlinkStateFlags},
		coreglib.TypeMarshaler{T: GTypeHyperlink, F: marshalHyperlink},
	})
}

// HyperlinkStateFlags describes the type of link.
type HyperlinkStateFlags C.guint

const (
	// HyperlinkIsInline: link is inline.
	HyperlinkIsInline HyperlinkStateFlags = 0b1
)

func marshalHyperlinkStateFlags(p uintptr) (interface{}, error) {
	return HyperlinkStateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for HyperlinkStateFlags.
func (h HyperlinkStateFlags) String() string {
	if h == 0 {
		return "HyperlinkStateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(17)

	for h != 0 {
		next := h & (h - 1)
		bit := h - next

		switch bit {
		case HyperlinkIsInline:
			builder.WriteString("Inline|")
		default:
			builder.WriteString(fmt.Sprintf("HyperlinkStateFlags(0b%b)|", bit))
		}

		h = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if h contains other.
func (h HyperlinkStateFlags) Has(other HyperlinkStateFlags) bool {
	return (h & other) == other
}

// HyperlinkOverrides contains methods that are overridable.
type HyperlinkOverrides struct {
}

func defaultHyperlinkOverrides(v *Hyperlink) HyperlinkOverrides {
	return HyperlinkOverrides{}
}

// Hyperlink: ATK object which encapsulates a link or set of links (for instance
// in the case of client-side image maps) in a hypertext document. It may
// implement the AtkAction interface. AtkHyperlink may also be used to refer to
// inline embedded content, since it allows specification of a start and end
// offset within the host AtkHypertext object.
type Hyperlink struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Action
}

var (
	_ coreglib.Objector = (*Hyperlink)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Hyperlink, *HyperlinkClass, HyperlinkOverrides](
		GTypeHyperlink,
		initHyperlinkClass,
		wrapHyperlink,
		defaultHyperlinkOverrides,
	)
}

func initHyperlinkClass(gclass unsafe.Pointer, overrides HyperlinkOverrides, classInitFunc func(*HyperlinkClass)) {
	if classInitFunc != nil {
		class := (*HyperlinkClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapHyperlink(obj *coreglib.Object) *Hyperlink {
	return &Hyperlink{
		Object: obj,
		Action: Action{
			Object: obj,
		},
	}
}

func marshalHyperlink(p uintptr) (interface{}, error) {
	return wrapHyperlink(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectLinkActivated: signal link-activated is emitted when a link is
// activated.
func (v *Hyperlink) ConnectLinkActivated(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "link-activated", false, unsafe.Pointer(C._gotk4_atk1_Hyperlink_ConnectLinkActivated), f)
}

// HyperlinkClass: instance of this type is always passed by reference.
type HyperlinkClass struct {
	*hyperlinkClass
}

// hyperlinkClass is the struct that's finalized.
type hyperlinkClass struct {
	native unsafe.Pointer
}

var GIRInfoHyperlinkClass = girepository.MustFind("Atk", "HyperlinkClass")
