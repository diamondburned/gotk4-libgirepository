// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeStreamableContent = coreglib.Type(girepository.MustFind("Atk", "StreamableContent").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStreamableContent, F: marshalStreamableContent},
	})
}

// StreamableContentOverrider contains methods that are overridable.
type StreamableContentOverrider interface {
}

// StreamableContent: interface whereby an object allows its backing content to
// be streamed to clients. Typical implementors would be images or icons, HTML
// content, or multimedia display/rendering widgets.
//
// Negotiation of content type is allowed. Clients may examine the backing data
// and transform, convert, or parse the content in order to present it in an
// alternate form to end-users.
//
// The AtkStreamableContent interface is particularly useful for saving,
// printing, or post-processing entire documents, or for persisting alternate
// views of a document. If document content itself is being serialized, stored,
// or converted, then use of the AtkStreamableContent interface can help address
// performance issues. Unlike most ATK interfaces, this interface is not
// strongly tied to the current user-agent view of the a particular document,
// but may in some cases give access to the underlying model data.
//
// StreamableContent wraps an interface. This means the user can get the
// underlying type by calling Cast().
type StreamableContent struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StreamableContent)(nil)
)

// StreamableContenter describes StreamableContent's interface methods.
type StreamableContenter interface {
	coreglib.Objector

	baseStreamableContent() *StreamableContent
}

var _ StreamableContenter = (*StreamableContent)(nil)

func ifaceInitStreamableContenter(gifacePtr, data C.gpointer) {
}

func wrapStreamableContent(obj *coreglib.Object) *StreamableContent {
	return &StreamableContent{
		Object: obj,
	}
}

func marshalStreamableContent(p uintptr) (interface{}, error) {
	return wrapStreamableContent(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *StreamableContent) baseStreamableContent() *StreamableContent {
	return v
}

// BaseStreamableContent returns the underlying base object.
func BaseStreamableContent(obj StreamableContenter) *StreamableContent {
	return obj.baseStreamableContent()
}

// StreamableContentIface: instance of this type is always passed by reference.
type StreamableContentIface struct {
	*streamableContentIface
}

// streamableContentIface is the struct that's finalized.
type streamableContentIface struct {
	native unsafe.Pointer
}

var GIRInfoStreamableContentIface = girepository.MustFind("Atk", "StreamableContentIface")
