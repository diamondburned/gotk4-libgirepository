// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_atk1_Object_ConnectVisibleDataChanged(gpointer, guintptr);
// extern void _gotk4_atk1_Object_ConnectStateChange(gpointer, gchar*, gboolean, guintptr);
// extern void _gotk4_atk1_Object_ConnectPropertyChange(gpointer, void*, guintptr);
// extern void _gotk4_atk1_Object_ConnectFocusEvent(gpointer, gboolean, guintptr);
// extern void _gotk4_atk1_Object_ConnectChildrenChanged(gpointer, guint, void*, guintptr);
// extern void _gotk4_atk1_Object_ConnectActiveDescendantChanged(gpointer, void*, guintptr);
import "C"

// GType values.
var (
	GTypeLayer            = coreglib.Type(girepository.MustFind("Atk", "Layer").RegisteredGType())
	GTypeRole             = coreglib.Type(girepository.MustFind("Atk", "Role").RegisteredGType())
	GTypeImplementorIface = coreglib.Type(girepository.MustFind("Atk", "ImplementorIface").RegisteredGType())
	GTypeAtkObject        = coreglib.Type(girepository.MustFind("Atk", "Object").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeLayer, F: marshalLayer},
		coreglib.TypeMarshaler{T: GTypeRole, F: marshalRole},
		coreglib.TypeMarshaler{T: GTypeImplementorIface, F: marshalImplementorIface},
		coreglib.TypeMarshaler{T: GTypeAtkObject, F: marshalAtkObject},
	})
}

// AttributeSet: this is a singly-linked list (a List) of Attribute. It is used
// by atk_text_get_run_attributes(), atk_text_get_default_attributes(),
// atk_editable_text_set_run_attributes(), atk_document_get_attributes() and
// atk_object_get_attributes().
type AttributeSet = coreglib.SList

// Layer describes the layer of a component
//
// These enumerated "layer values" are used when determining which UI rendering
// layer a component is drawn into, which can help in making determinations of
// when components occlude one another.
type Layer C.gint

const (
	// LayerInvalid: object does not have a layer.
	LayerInvalid Layer = iota
	// LayerBackground: this layer is reserved for the desktop background.
	LayerBackground
	// LayerCanvas: this layer is used for Canvas components.
	LayerCanvas
	// LayerWidget: this layer is normally used for components.
	LayerWidget
	// LayerMDI: this layer is used for layered components.
	LayerMDI
	// LayerPopup: this layer is used for popup components, such as menus.
	LayerPopup
	// LayerOverlay: this layer is reserved for future use.
	LayerOverlay
	// LayerWindow: this layer is used for toplevel windows.
	LayerWindow
)

func marshalLayer(p uintptr) (interface{}, error) {
	return Layer(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Layer.
func (l Layer) String() string {
	switch l {
	case LayerInvalid:
		return "Invalid"
	case LayerBackground:
		return "Background"
	case LayerCanvas:
		return "Canvas"
	case LayerWidget:
		return "Widget"
	case LayerMDI:
		return "MDI"
	case LayerPopup:
		return "Popup"
	case LayerOverlay:
		return "Overlay"
	case LayerWindow:
		return "Window"
	default:
		return fmt.Sprintf("Layer(%d)", l)
	}
}

// Role describes the role of an object
//
// These are the built-in enumerated roles that UI components can have in ATK.
// Other roles may be added at runtime, so an AtkRole >= ATK_ROLE_LAST_DEFINED
// is not necessarily an error.
type Role C.gint

const (
	// RoleInvalid: invalid role.
	RoleInvalid Role = iota
	// RoleAccelLabel: label which represents an accelerator.
	RoleAccelLabel
	// RoleAlert: object which is an alert to the user. Assistive Technologies
	// typically respond to ATK_ROLE_ALERT by reading the entire onscreen
	// contents of containers advertising this role. Should be used for warning
	// dialogs, etc.
	RoleAlert
	// RoleAnimation: object which is an animated image.
	RoleAnimation
	// RoleArrow: arrow in one of the four cardinal directions.
	RoleArrow
	// RoleCalendar: object that displays a calendar and allows the user to
	// select a date.
	RoleCalendar
	// RoleCanvas: object that can be drawn into and is used to trap events.
	RoleCanvas
	// RoleCheckBox: choice that can be checked or unchecked and provides a
	// separate indicator for the current state.
	RoleCheckBox
	// RoleCheckMenuItem: menu item with a check box.
	RoleCheckMenuItem
	// RoleColorChooser: specialized dialog that lets the user choose a color.
	RoleColorChooser
	// RoleColumnHeader: header for a column of data.
	RoleColumnHeader
	// RoleComboBox: collapsible list of choices the user can select from.
	RoleComboBox
	// RoleDateEditor: object whose purpose is to allow a user to edit a date.
	RoleDateEditor
	// RoleDesktopIcon: inconifed internal frame within a DESKTOP_PANE.
	RoleDesktopIcon
	// RoleDesktopFrame: pane that supports internal frames and iconified
	// versions of those internal frames.
	RoleDesktopFrame
	// RoleDial: object whose purpose is to allow a user to set a value.
	RoleDial
	// RoleDialog: top level window with title bar and a border.
	RoleDialog
	// RoleDirectoryPane: pane that allows the user to navigate through and
	// select the contents of a directory.
	RoleDirectoryPane
	// RoleDrawingArea: object used for drawing custom user interface elements.
	RoleDrawingArea
	// RoleFileChooser: specialized dialog that lets the user choose a file.
	RoleFileChooser
	// RoleFiller: object that fills up space in a user interface.
	RoleFiller
	// RoleFontChooser: specialized dialog that lets the user choose a font.
	RoleFontChooser
	// RoleFrame: top level window with a title bar, border, menubar, etc.
	RoleFrame
	// RoleGlassPane: pane that is guaranteed to be painted on top of all panes
	// beneath it.
	RoleGlassPane
	// RoleHtmlContainer: document container for HTML, whose children represent
	// the document content.
	RoleHtmlContainer
	// RoleIcon: small fixed size picture, typically used to decorate
	// components.
	RoleIcon
	// RoleImage: object whose primary purpose is to display an image.
	RoleImage
	// RoleInternalFrame: frame-like object that is clipped by a desktop pane.
	RoleInternalFrame
	// RoleLabel: object used to present an icon or short string in an
	// interface.
	RoleLabel
	// RoleLayeredPane: specialized pane that allows its children to be drawn in
	// layers, providing a form of stacking order.
	RoleLayeredPane
	// RoleList: object that presents a list of objects to the user and allows
	// the user to select one or more of them.
	RoleList
	// RoleListItem: object that represents an element of a list.
	RoleListItem
	// RoleMenu: object usually found inside a menu bar that contains a list of
	// actions the user can choose from.
	RoleMenu
	// RoleMenuBar: object usually drawn at the top of the primary dialog box of
	// an application that contains a list of menus the user can choose from.
	RoleMenuBar
	// RoleMenuItem: object usually contained in a menu that presents an action
	// the user can choose.
	RoleMenuItem
	// RoleOptionPane: specialized pane whose primary use is inside a DIALOG.
	RoleOptionPane
	// RolePageTab: object that is a child of a page tab list.
	RolePageTab
	// RolePageTabList: object that presents a series of panels (or page tabs),
	// one at a time, through some mechanism provided by the object.
	RolePageTabList
	// RolePanel: generic container that is often used to group objects.
	RolePanel
	// RolePasswordText: text object uses for passwords, or other places where
	// the text content is not shown visibly to the user.
	RolePasswordText
	// RolePopupMenu: temporary window that is usually used to offer the user a
	// list of choices, and then hides when the user selects one of those
	// choices.
	RolePopupMenu
	// RoleProgressBar: object used to indicate how much of a task has been
	// completed.
	RoleProgressBar
	// RolePushButton: object the user can manipulate to tell the application to
	// do something.
	RolePushButton
	// RoleRadioButton: specialized check box that will cause other radio
	// buttons in the same group to become unchecked when this one is checked.
	RoleRadioButton
	// RoleRadioMenuItem: check menu item which belongs to a group. At each
	// instant exactly one of the radio menu items from a group is selected.
	RoleRadioMenuItem
	// RoleRootPane: specialized pane that has a glass pane and a layered pane
	// as its children.
	RoleRootPane
	// RoleRowHeader: header for a row of data.
	RoleRowHeader
	// RoleScrollBar: object usually used to allow a user to incrementally view
	// a large amount of data.
	RoleScrollBar
	// RoleScrollPane: object that allows a user to incrementally view a large
	// amount of information.
	RoleScrollPane
	// RoleSeparator: object usually contained in a menu to provide a visible
	// and logical separation of the contents in a menu.
	RoleSeparator
	// RoleSlider: object that allows the user to select from a bounded range.
	RoleSlider
	// RoleSplitPane: specialized panel that presents two other panels at the
	// same time.
	RoleSplitPane
	// RoleSpinButton: object used to get an integer or floating point number
	// from the user.
	RoleSpinButton
	// RoleStatusbar: object which reports messages of minor importance to the
	// user.
	RoleStatusbar
	// RoleTable: object used to represent information in terms of rows and
	// columns.
	RoleTable
	// RoleTableCell: cell in a table.
	RoleTableCell
	// RoleTableColumnHeader: header for a column of a table.
	RoleTableColumnHeader
	// RoleTableRowHeader: header for a row of a table.
	RoleTableRowHeader
	// RoleTearOffMenuItem: menu item used to tear off and reattach its menu.
	RoleTearOffMenuItem
	// RoleTerminal: object that represents an accessible terminal. (Since:
	// 0.6).
	RoleTerminal
	// RoleText: interactive widget that supports multiple lines of text and
	// optionally accepts user input, but whose purpose is not to solicit user
	// input. Thus ATK_ROLE_TEXT is appropriate for the text view in a plain
	// text editor but inappropriate for an input field in a dialog box or web
	// form. For widgets whose purpose is to solicit input from the user, see
	// ATK_ROLE_ENTRY and ATK_ROLE_PASSWORD_TEXT. For generic objects which
	// display a brief amount of textual information, see ATK_ROLE_STATIC.
	RoleText
	// RoleToggleButton: specialized push button that can be checked or
	// unchecked, but does not provide a separate indicator for the current
	// state.
	RoleToggleButton
	// RoleToolBar: bar or palette usually composed of push buttons or toggle
	// buttons.
	RoleToolBar
	// RoleToolTip: object that provides information about another object.
	RoleToolTip
	// RoleTree: object used to represent hierarchical information to the user.
	RoleTree
	// RoleTreeTable: object capable of expanding and collapsing rows as well as
	// showing multiple columns of data. (Since: 0.7).
	RoleTreeTable
	// RoleUnknown: object contains some Accessible information, but its role is
	// not known.
	RoleUnknown
	// RoleViewport: object usually used in a scroll pane.
	RoleViewport
	// RoleWindow: top level window with no title or border.
	RoleWindow
	// RoleHeader: object that serves as a document header. (Since: 1.1.1).
	RoleHeader
	// RoleFooter: object that serves as a document footer. (Since: 1.1.1).
	RoleFooter
	// RoleParagraph: object which is contains a paragraph of text content.
	// (Since: 1.1.1).
	RoleParagraph
	// RoleRuler: object which describes margins and tab stops, etc. for text
	// objects which it controls (should have CONTROLLER_FOR relation to such).
	// (Since: 1.1.1).
	RoleRuler
	// RoleApplication: object is an application object, which may contain
	// ATK_ROLE_FRAME objects or other types of accessibles. The root accessible
	// of any application's ATK hierarchy should have ATK_ROLE_APPLICATION.
	// (Since: 1.1.4).
	RoleApplication
	// RoleAutocomplete: object is a dialog or list containing items for
	// insertion into an entry widget, for instance a list of words for
	// completion of a text entry. (Since: 1.3).
	RoleAutocomplete
	// RoleEditbar: object is an editable text object in a toolbar. (Since:
	// 1.5).
	RoleEditbar
	// RoleEmbedded: object is an embedded container within a document or panel.
	// This role is a grouping "hint" indicating that the contained objects
	// share a context. (Since: 1.7.2).
	RoleEmbedded
	// RoleEntry: object is a component whose textual content may be entered or
	// modified by the user, provided ATK_STATE_EDITABLE is present. (Since:
	// 1.11).
	RoleEntry
	// RoleChart: object is a graphical depiction of quantitative data. It may
	// contain multiple subelements whose attributes and/or description may be
	// queried to obtain both the quantitative data and information about how
	// the data is being presented. The LABELLED_BY relation is particularly
	// important in interpreting objects of this type, as is the
	// accessible-description property. (Since: 1.11).
	RoleChart
	// RoleCaption: object contains descriptive information, usually textual,
	// about another user interface element such as a table, chart, or image.
	// (Since: 1.11).
	RoleCaption
	// RoleDocumentFrame: object is a visual frame or container which contains a
	// view of document content. Document frames may occur within another
	// Document instance, in which case the second document may be said to be
	// embedded in the containing instance. HTML frames are often
	// ROLE_DOCUMENT_FRAME. Either this object, or a singleton descendant,
	// should implement the Document interface. (Since: 1.11).
	RoleDocumentFrame
	// RoleHeading: object serves as a heading for content which follows it in a
	// document. The 'heading level' of the heading, if availabe, may be
	// obtained by querying the object's attributes.
	RoleHeading
	// RolePage: object is a containing instance which encapsulates a page of
	// information. ATK_ROLE_PAGE is used in documents and content which support
	// a paginated navigation model. (Since: 1.11).
	RolePage
	// RoleSection: object is a containing instance of document content which
	// constitutes a particular 'logical' section of the document. The type of
	// content within a section, and the nature of the section division itself,
	// may be obtained by querying the object's attributes. Sections may be
	// nested. (Since: 1.11).
	RoleSection
	// RoleRedundantObject: object is redundant with another object in the
	// hierarchy, and is exposed for purely technical reasons. Objects of this
	// role should normally be ignored by clients. (Since: 1.11).
	RoleRedundantObject
	// RoleForm: object is a container for form controls, for instance as part
	// of a web form or user-input form within a document. This role is
	// primarily a tag/convenience for clients when navigating complex
	// documents, it is not expected that ordinary GUI containers will always
	// have ATK_ROLE_FORM. (Since: 1.12.0).
	RoleForm
	// RoleLink: object is a hypertext anchor, i.e. a "link" in a hypertext
	// document. Such objects are distinct from 'inline' content which may also
	// use the Hypertext/Hyperlink interfaces to indicate the range/location
	// within a text object where an inline or embedded object lies. (Since:
	// 1.12.1).
	RoleLink
	// RoleInputMethodWindow: object is a window or similar viewport which is
	// used to allow composition or input of a 'complex character', in other
	// words it is an "input method window." (Since: 1.12.1).
	RoleInputMethodWindow
	// RoleTableRow: row in a table. (Since: 2.1.0).
	RoleTableRow
	// RoleTreeItem: object that represents an element of a tree. (Since:
	// 2.1.0).
	RoleTreeItem
	// RoleDocumentSpreadsheet: document frame which contains a spreadsheet.
	// (Since: 2.1.0).
	RoleDocumentSpreadsheet
	// RoleDocumentPresentation: document frame which contains a presentation or
	// slide content. (Since: 2.1.0).
	RoleDocumentPresentation
	// RoleDocumentText: document frame which contains textual content, such as
	// found in a word processing application. (Since: 2.1.0).
	RoleDocumentText
	// RoleDocumentWeb: document frame which contains HTML or other markup
	// suitable for display in a web browser. (Since: 2.1.0).
	RoleDocumentWeb
	// RoleDocumentEmail: document frame which contains email content to be
	// displayed or composed either in plain text or HTML. (Since: 2.1.0).
	RoleDocumentEmail
	// RoleComment: object found within a document and designed to present a
	// comment, note, or other annotation. In some cases, this object might not
	// be visible until activated. (Since: 2.1.0).
	RoleComment
	// RoleListBox: non-collapsible list of choices the user can select from.
	// (Since: 2.1.0).
	RoleListBox
	// RoleGrouping: group of related widgets. This group typically has a label.
	// (Since: 2.1.0).
	RoleGrouping
	// RoleImageMap: image map object. Usually a graphic with multiple hotspots,
	// where each hotspot can be activated resulting in the loading of another
	// document or section of a document. (Since: 2.1.0).
	RoleImageMap
	// RoleNotification: transitory object designed to present a message to the
	// user, typically at the desktop level rather than inside a particular
	// application. (Since: 2.1.0).
	RoleNotification
	// RoleInfoBar: object designed to present a message to the user within an
	// existing window. (Since: 2.1.0).
	RoleInfoBar
	// RoleLevelBar: bar that serves as a level indicator to, for instance, show
	// the strength of a password or the state of a battery. (Since: 2.7.3).
	RoleLevelBar
	// RoleTitleBar: bar that serves as the title of a window or a dialog.
	// (Since: 2.12).
	RoleTitleBar
	// RoleBlockQuote: object which contains a text section that is quoted from
	// another source. (Since: 2.12).
	RoleBlockQuote
	// RoleAudio: object which represents an audio element. (Since: 2.12).
	RoleAudio
	// RoleVideo: object which represents a video element. (Since: 2.12).
	RoleVideo
	// RoleDefinition: definition of a term or concept. (Since: 2.12).
	RoleDefinition
	// RoleArticle: section of a page that consists of a composition that forms
	// an independent part of a document, page, or site. Examples: A blog entry,
	// a news story, a forum post. (Since: 2.12).
	RoleArticle
	// RoleLandmark: region of a web page intended as a navigational landmark.
	// This is designed to allow Assistive Technologies to provide quick
	// navigation among key regions within a document. (Since: 2.12).
	RoleLandmark
	// RoleLog: text widget or container holding log content, such as chat
	// history and error logs. In this role there is a relationship between the
	// arrival of new items in the log and the reading order. The log contains a
	// meaningful sequence and new information is added only to the end of the
	// log, not at arbitrary points. (Since: 2.12).
	RoleLog
	// RoleMarquee: container where non-essential information changes
	// frequently. Common usages of marquee include stock tickers and ad
	// banners. The primary difference between a marquee and a log is that logs
	// usually have a meaningful order or sequence of important content changes.
	// (Since: 2.12).
	RoleMarquee
	// RoleMath: text widget or container that holds a mathematical expression.
	// (Since: 2.12).
	RoleMath
	// RoleRating: widget whose purpose is to display a rating, such as the
	// number of stars associated with a song in a media player. Objects of this
	// role should also implement AtkValue. (Since: 2.12).
	RoleRating
	// RoleTimer: object containing a numerical counter which indicates an
	// amount of elapsed time from a start point, or the time remaining until an
	// end point. (Since: 2.12).
	RoleTimer
	// RoleDescriptionList: object that represents a list of term-value groups.
	// A term-value group represents a individual description and consist of one
	// or more names (ATK_ROLE_DESCRIPTION_TERM) followed by one or more values
	// (ATK_ROLE_DESCRIPTION_VALUE). For each list, there should not be more
	// than one group with the same term name. (Since: 2.12).
	RoleDescriptionList
	// RoleDescriptionTerm: object that represents a term or phrase with a
	// corresponding definition. (Since: 2.12).
	RoleDescriptionTerm
	// RoleDescriptionValue: object that represents the description, definition
	// or value of a term. (Since: 2.12).
	RoleDescriptionValue
	// RoleStatic: generic non-container object whose purpose is to display a
	// brief amount of information to the user and whose role is known by the
	// implementor but lacks semantic value for the user. Examples in which
	// ATK_ROLE_STATIC is appropriate include the message displayed in a message
	// box and an image used as an alternative means to display text.
	// ATK_ROLE_STATIC should not be applied to widgets which are traditionally
	// interactive, objects which display a significant amount of content, or
	// any object which has an accessible relation pointing to another object.
	// Implementors should expose the displayed information through the
	// accessible name of the object. If doing so seems inappropriate, it may
	// indicate that a different role should be used. For labels which describe
	// another widget, see ATK_ROLE_LABEL. For text views, see ATK_ROLE_TEXT.
	// For generic containers, see ATK_ROLE_PANEL. For objects whose role is not
	// known by the implementor, see ATK_ROLE_UNKNOWN. (Since: 2.16).
	RoleStatic
	// RoleMathFraction: object that represents a mathematical fraction. (Since:
	// 2.16).
	RoleMathFraction
	// RoleMathRoot: object that represents a mathematical expression displayed
	// with a radical. (Since: 2.16).
	RoleMathRoot
	// RoleSubscript: object that contains text that is displayed as a
	// subscript. (Since: 2.16).
	RoleSubscript
	// RoleSuperscript: object that contains text that is displayed as a
	// superscript. (Since: 2.16).
	RoleSuperscript
	// RoleFootnote: object that contains the text of a footnote. (Since: 2.26).
	RoleFootnote
	// RoleContentDeletion: content previously deleted or proposed to be
	// deleted, e.g. in revision history or a content view providing suggestions
	// from reviewers. (Since: 2.34).
	RoleContentDeletion
	// RoleContentInsertion: content previously inserted or proposed to be
	// inserted, e.g. in revision history or a content view providing
	// suggestions from reviewers. (Since: 2.34).
	RoleContentInsertion
	// RoleMark: run of content that is marked or highlighted, such as for
	// reference purposes, or to call it out as having a special purpose. If the
	// marked content has an associated section in the document elaborating on
	// the reason for the mark, then ATK_RELATION_DETAILS should be used on the
	// mark to point to that associated section. In addition, the reciprocal
	// relation ATK_RELATION_DETAILS_FOR should be used on the associated
	// content section to point back to the mark. (Since: 2.36).
	RoleMark
	// RoleSuggestion: container for content that is called out as a proposed
	// change from the current version of the document, such as by a reviewer of
	// the content. This role should include either ATK_ROLE_CONTENT_DELETION
	// and/or ATK_ROLE_CONTENT_INSERTION children, in any order, to indicate
	// what the actual change is. (Since: 2.36).
	RoleSuggestion
	// RoleLastDefined: not a valid role, used for finding end of the
	// enumeration.
	RoleLastDefined
)

func marshalRole(p uintptr) (interface{}, error) {
	return Role(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Role.
func (r Role) String() string {
	switch r {
	case RoleInvalid:
		return "Invalid"
	case RoleAccelLabel:
		return "AcceleratorLabel"
	case RoleAlert:
		return "Alert"
	case RoleAnimation:
		return "Animation"
	case RoleArrow:
		return "Arrow"
	case RoleCalendar:
		return "Calendar"
	case RoleCanvas:
		return "Canvas"
	case RoleCheckBox:
		return "CheckBox"
	case RoleCheckMenuItem:
		return "CheckMenuItem"
	case RoleColorChooser:
		return "ColorChooser"
	case RoleColumnHeader:
		return "ColumnHeader"
	case RoleComboBox:
		return "ComboBox"
	case RoleDateEditor:
		return "DateEditor"
	case RoleDesktopIcon:
		return "DesktopIcon"
	case RoleDesktopFrame:
		return "DesktopFrame"
	case RoleDial:
		return "Dial"
	case RoleDialog:
		return "Dialog"
	case RoleDirectoryPane:
		return "DirectoryPane"
	case RoleDrawingArea:
		return "DrawingArea"
	case RoleFileChooser:
		return "FileChooser"
	case RoleFiller:
		return "Filler"
	case RoleFontChooser:
		return "FontChooser"
	case RoleFrame:
		return "Frame"
	case RoleGlassPane:
		return "GlassPane"
	case RoleHtmlContainer:
		return "HtmlContainer"
	case RoleIcon:
		return "Icon"
	case RoleImage:
		return "Image"
	case RoleInternalFrame:
		return "InternalFrame"
	case RoleLabel:
		return "Label"
	case RoleLayeredPane:
		return "LayeredPane"
	case RoleList:
		return "List"
	case RoleListItem:
		return "ListItem"
	case RoleMenu:
		return "Menu"
	case RoleMenuBar:
		return "MenuBar"
	case RoleMenuItem:
		return "MenuItem"
	case RoleOptionPane:
		return "OptionPane"
	case RolePageTab:
		return "PageTab"
	case RolePageTabList:
		return "PageTabList"
	case RolePanel:
		return "Panel"
	case RolePasswordText:
		return "PasswordText"
	case RolePopupMenu:
		return "PopupMenu"
	case RoleProgressBar:
		return "ProgressBar"
	case RolePushButton:
		return "PushButton"
	case RoleRadioButton:
		return "RadioButton"
	case RoleRadioMenuItem:
		return "RadioMenuItem"
	case RoleRootPane:
		return "RootPane"
	case RoleRowHeader:
		return "RowHeader"
	case RoleScrollBar:
		return "ScrollBar"
	case RoleScrollPane:
		return "ScrollPane"
	case RoleSeparator:
		return "Separator"
	case RoleSlider:
		return "Slider"
	case RoleSplitPane:
		return "SplitPane"
	case RoleSpinButton:
		return "SpinButton"
	case RoleStatusbar:
		return "Statusbar"
	case RoleTable:
		return "Table"
	case RoleTableCell:
		return "TableCell"
	case RoleTableColumnHeader:
		return "TableColumnHeader"
	case RoleTableRowHeader:
		return "TableRowHeader"
	case RoleTearOffMenuItem:
		return "TearOffMenuItem"
	case RoleTerminal:
		return "Terminal"
	case RoleText:
		return "Text"
	case RoleToggleButton:
		return "ToggleButton"
	case RoleToolBar:
		return "ToolBar"
	case RoleToolTip:
		return "ToolTip"
	case RoleTree:
		return "Tree"
	case RoleTreeTable:
		return "TreeTable"
	case RoleUnknown:
		return "Unknown"
	case RoleViewport:
		return "Viewport"
	case RoleWindow:
		return "Window"
	case RoleHeader:
		return "Header"
	case RoleFooter:
		return "Footer"
	case RoleParagraph:
		return "Paragraph"
	case RoleRuler:
		return "Ruler"
	case RoleApplication:
		return "Application"
	case RoleAutocomplete:
		return "Autocomplete"
	case RoleEditbar:
		return "EditBar"
	case RoleEmbedded:
		return "Embedded"
	case RoleEntry:
		return "Entry"
	case RoleChart:
		return "Chart"
	case RoleCaption:
		return "Caption"
	case RoleDocumentFrame:
		return "DocumentFrame"
	case RoleHeading:
		return "Heading"
	case RolePage:
		return "Page"
	case RoleSection:
		return "Section"
	case RoleRedundantObject:
		return "RedundantObject"
	case RoleForm:
		return "Form"
	case RoleLink:
		return "Link"
	case RoleInputMethodWindow:
		return "InputMethodWindow"
	case RoleTableRow:
		return "TableRow"
	case RoleTreeItem:
		return "TreeItem"
	case RoleDocumentSpreadsheet:
		return "DocumentSpreadsheet"
	case RoleDocumentPresentation:
		return "DocumentPresentation"
	case RoleDocumentText:
		return "DocumentText"
	case RoleDocumentWeb:
		return "DocumentWeb"
	case RoleDocumentEmail:
		return "DocumentEmail"
	case RoleComment:
		return "Comment"
	case RoleListBox:
		return "ListBox"
	case RoleGrouping:
		return "Grouping"
	case RoleImageMap:
		return "ImageMap"
	case RoleNotification:
		return "Notification"
	case RoleInfoBar:
		return "InfoBar"
	case RoleLevelBar:
		return "LevelBar"
	case RoleTitleBar:
		return "TitleBar"
	case RoleBlockQuote:
		return "BlockQuote"
	case RoleAudio:
		return "Audio"
	case RoleVideo:
		return "Video"
	case RoleDefinition:
		return "Definition"
	case RoleArticle:
		return "Article"
	case RoleLandmark:
		return "Landmark"
	case RoleLog:
		return "Log"
	case RoleMarquee:
		return "Marquee"
	case RoleMath:
		return "Math"
	case RoleRating:
		return "Rating"
	case RoleTimer:
		return "Timer"
	case RoleDescriptionList:
		return "DescriptionList"
	case RoleDescriptionTerm:
		return "DescriptionTerm"
	case RoleDescriptionValue:
		return "DescriptionValue"
	case RoleStatic:
		return "Static"
	case RoleMathFraction:
		return "MathFraction"
	case RoleMathRoot:
		return "MathRoot"
	case RoleSubscript:
		return "Subscript"
	case RoleSuperscript:
		return "Superscript"
	case RoleFootnote:
		return "Footnote"
	case RoleContentDeletion:
		return "ContentDeletion"
	case RoleContentInsertion:
		return "ContentInsertion"
	case RoleMark:
		return "Mark"
	case RoleSuggestion:
		return "Suggestion"
	case RoleLastDefined:
		return "LastDefined"
	default:
		return fmt.Sprintf("Role(%d)", r)
	}
}

// Function is a function definition used for padding which has been added to
// class and interface structures to allow for expansion in the future.
type Function func() (ok bool)

// ImplementorIface: atkImplementor interface is implemented by objects for
// which AtkObject peers may be obtained via calls to
// iface->(ref_accessible)(implementor);.
//
// ImplementorIface wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ImplementorIface struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ImplementorIface)(nil)
)

// ImplementorIfacer describes ImplementorIface's interface methods.
type ImplementorIfacer interface {
	coreglib.Objector

	baseImplementorIface() *ImplementorIface
}

var _ ImplementorIfacer = (*ImplementorIface)(nil)

func wrapImplementorIface(obj *coreglib.Object) *ImplementorIface {
	return &ImplementorIface{
		Object: obj,
	}
}

func marshalImplementorIface(p uintptr) (interface{}, error) {
	return wrapImplementorIface(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ImplementorIface) baseImplementorIface() *ImplementorIface {
	return v
}

// BaseImplementorIface returns the underlying base object.
func BaseImplementorIface(obj ImplementorIfacer) *ImplementorIface {
	return obj.baseImplementorIface()
}

// AtkObjectOverrides contains methods that are overridable.
type AtkObjectOverrides struct {
}

func defaultAtkObjectOverrides(v *AtkObject) AtkObjectOverrides {
	return AtkObjectOverrides{}
}

// AtkObject: this class is the primary class for accessibility support via the
// Accessibility ToolKit (ATK). Objects which are instances of Object (or
// instances of AtkObject-derived types) are queried for properties which relate
// basic (and generic) properties of a UI component such as name and
// description. Instances of Object may also be queried as to whether they
// implement other ATK interfaces (e.g. Action, Component, etc.), as appropriate
// to the role which a given UI component plays in a user interface.
//
// All UI components in an application which provide useful information or
// services to the user must provide corresponding Object instances on request
// (in GTK+, for instance, usually on a call to #gtk_widget_get_accessible ()),
// either via ATK support built into the toolkit for the widget class or
// ancestor class, or in the case of custom widgets, if the inherited Object
// implementation is insufficient, via instances of a new Object subclass.
//
// See also: ObjectFactory, Registry. (GTK+ users see also Accessible).
type AtkObject struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AtkObject)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AtkObject, *ObjectClass, AtkObjectOverrides](
		GTypeAtkObject,
		initObjectClass,
		wrapObject,
		defaultAtkObjectOverrides,
	)
}

func initObjectClass(gclass unsafe.Pointer, overrides AtkObjectOverrides, classInitFunc func(*ObjectClass)) {
	if classInitFunc != nil {
		class := (*ObjectClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapObject(obj *coreglib.Object) *AtkObject {
	return &AtkObject{
		Object: obj,
	}
}

func marshalAtkObject(p uintptr) (interface{}, error) {
	return wrapObject(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActiveDescendantChanged: "active-descendant-changed" signal is emitted
// by an object which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
// object in the object changes. For instance, a table will emit the signal when
// the cell in the table which has focus changes.
func (v *AtkObject) ConnectActiveDescendantChanged(f func(arg1 *AtkObject)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "active-descendant-changed", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectActiveDescendantChanged), f)
}

// ConnectChildrenChanged: signal "children-changed" is emitted when a child is
// added or removed form an object. It supports two details: "add" and "remove".
func (v *AtkObject) ConnectChildrenChanged(f func(arg1 uint, arg2 *AtkObject)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "children-changed", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectChildrenChanged), f)
}

// ConnectFocusEvent: signal "focus-event" is emitted when an object gained or
// lost focus.
func (v *AtkObject) ConnectFocusEvent(f func(arg1 bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "focus-event", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectFocusEvent), f)
}

// ConnectPropertyChange: signal "property-change" is emitted when an object's
// property value changes. arg1 contains an PropertyValues with the name and the
// new value of the property whose value has changed. Note that, as with GObject
// notify, getting this signal does not guarantee that the value of the property
// has actually changed; it may also be emitted when the setter of the property
// is called to reinstate the previous value.
//
// Toolkit implementor note: ATK implementors should use g_object_notify() to
// emit property-changed notifications. Object::property-changed is needed by
// the implementation of atk_add_global_event_listener() because GObject notify
// doesn't support emission hooks.
func (v *AtkObject) ConnectPropertyChange(f func(arg1 *PropertyValues)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "property-change", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectPropertyChange), f)
}

// ConnectStateChange: "state-change" signal is emitted when an object's state
// changes. The detail value identifies the state type which has changed.
func (v *AtkObject) ConnectStateChange(f func(arg1 string, arg2 bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "state-change", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectStateChange), f)
}

// ConnectVisibleDataChanged: "visible-data-changed" signal is emitted when the
// visual appearance of the object changed.
func (v *AtkObject) ConnectVisibleDataChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "visible-data-changed", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectVisibleDataChanged), f)
}

// Attribute is a string name/value pair representing a generic attribute. This
// can be used to expose additional information from an accessible object as a
// whole (see atk_object_get_attributes()) or an document (see
// atk_document_get_attributes()). In the case of text attributes (see
// atk_text_get_default_attributes()), TextAttribute enum defines all the
// possible text attribute names. You can use atk_text_attribute_get_name() to
// get the string name from the enum value. See also
// atk_text_attribute_for_name() and atk_text_attribute_get_value() for more
// information.
//
// A string name/value pair representing a generic attribute.
//
// An instance of this type is always passed by reference.
type Attribute struct {
	*attribute
}

// attribute is the struct that's finalized.
type attribute struct {
	native unsafe.Pointer
}

var GIRInfoAttribute = girepository.MustFind("Atk", "Attribute")

// Name: attribute name.
func (a *Attribute) Name() string {
	offset := GIRInfoAttribute.StructFieldOffset("name")
	valptr := (*string)(unsafe.Add(a.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Value: value of the attribute, represented as a string.
func (a *Attribute) Value() string {
	offset := GIRInfoAttribute.StructFieldOffset("value")
	valptr := (*string)(unsafe.Add(a.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ObjectClass: instance of this type is always passed by reference.
type ObjectClass struct {
	*objectClass
}

// objectClass is the struct that's finalized.
type objectClass struct {
	native unsafe.Pointer
}

var GIRInfoObjectClass = girepository.MustFind("Atk", "ObjectClass")

// PropertyValues: note: old_value field of PropertyValues will not contain a
// valid value. This is a field defined with the purpose of contain the previous
// value of the property, but is not used anymore.
//
// An instance of this type is always passed by reference.
type PropertyValues struct {
	*propertyValues
}

// propertyValues is the struct that's finalized.
type propertyValues struct {
	native unsafe.Pointer
}

var GIRInfoPropertyValues = girepository.MustFind("Atk", "PropertyValues")

// PropertyName: name of the ATK property which has changed.
func (p *PropertyValues) PropertyName() string {
	offset := GIRInfoPropertyValues.StructFieldOffset("property_name")
	valptr := (*string)(unsafe.Add(p.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}
