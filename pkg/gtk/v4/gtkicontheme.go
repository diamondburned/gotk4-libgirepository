// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_IconTheme_ConnectChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeIconThemeError  = coreglib.Type(girepository.MustFind("Gtk", "IconThemeError").RegisteredGType())
	GTypeIconLookupFlags = coreglib.Type(girepository.MustFind("Gtk", "IconLookupFlags").RegisteredGType())
	GTypeIconPaintable   = coreglib.Type(girepository.MustFind("Gtk", "IconPaintable").RegisteredGType())
	GTypeIconTheme       = coreglib.Type(girepository.MustFind("Gtk", "IconTheme").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIconThemeError, F: marshalIconThemeError},
		coreglib.TypeMarshaler{T: GTypeIconLookupFlags, F: marshalIconLookupFlags},
		coreglib.TypeMarshaler{T: GTypeIconPaintable, F: marshalIconPaintable},
		coreglib.TypeMarshaler{T: GTypeIconTheme, F: marshalIconTheme},
	})
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError C.gint

const (
	// IconThemeNotFound: icon specified does not exist in the theme.
	IconThemeNotFound IconThemeError = iota
	// IconThemeFailed: unspecified error occurred.
	IconThemeFailed
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconThemeError.
func (i IconThemeError) String() string {
	switch i {
	case IconThemeNotFound:
		return "NotFound"
	case IconThemeFailed:
		return "Failed"
	default:
		return fmt.Sprintf("IconThemeError(%d)", i)
	}
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon().
type IconLookupFlags C.guint

const (
	// IconLookupForceRegular: try to always load regular icons, even when
	// symbolic icon names are given.
	IconLookupForceRegular IconLookupFlags = 0b1
	// IconLookupForceSymbolic: try to always load symbolic icons, even when
	// regular icon names are given.
	IconLookupForceSymbolic IconLookupFlags = 0b10
	// IconLookupPreload starts loading the texture in the background so it is
	// ready when later needed.
	IconLookupPreload IconLookupFlags = 0b100
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IconLookupFlags.
func (i IconLookupFlags) String() string {
	if i == 0 {
		return "IconLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IconLookupForceRegular:
			builder.WriteString("ForceRegular|")
		case IconLookupForceSymbolic:
			builder.WriteString("ForceSymbolic|")
		case IconLookupPreload:
			builder.WriteString("Preload|")
		default:
			builder.WriteString(fmt.Sprintf("IconLookupFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IconLookupFlags) Has(other IconLookupFlags) bool {
	return (i & other) == other
}

// IconPaintable contains information found when looking up an icon in
// GtkIconTheme.
//
// GtkIconPaintable implements GdkPaintable.
type IconPaintable struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gdk.Paintable
}

var (
	_ coreglib.Objector = (*IconPaintable)(nil)
)

func wrapIconPaintable(obj *coreglib.Object) *IconPaintable {
	return &IconPaintable{
		Object: obj,
		Paintable: gdk.Paintable{
			Object: obj,
		},
	}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	return wrapIconPaintable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IconTheme: GtkIconTheme provides a facility for loading themed icons.
//
// The main reason for using a name rather than simply providing a filename is
// to allow different icons to be used depending on what “icon theme” is
// selected by the user. The operation of icon themes on Linux and Unix follows
// the Icon Theme Specification
// (http://www.freedesktop.org/Standards/icon-theme-spec) There is a fallback
// icon theme, named hicolor, where applications should install their icons, but
// additional icon themes can be installed as operating system vendors and users
// choose.
//
// In many cases, named themes are used indirectly, via gtk.Image rather than
// directly, but looking up icons directly is also simple. The GtkIconTheme
// object acts as a database of all the icons in the current theme. You can
// create new GtkIconTheme objects, but it’s much more efficient to use the
// standard icon theme of the GtkWidget so that the icon information is shared
// with other people looking up icons.
//
//    GtkIconTheme *icon_theme;
//    GtkIconPaintable *icon;
//    GdkPaintable *paintable;
//
//    icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display (my_widget));
//    icon = gtk_icon_theme_lookup_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       1,  // scale
//                                       0,  // flags);
//    paintable = GDK_PAINTABLE (icon);
//    // Use the paintable
//    g_object_unref (icon);.
type IconTheme struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IconTheme)(nil)
)

func wrapIconTheme(obj *coreglib.Object) *IconTheme {
	return &IconTheme{
		Object: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	return wrapIconTheme(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the icon theme changes.
//
// This can happen becuase current icon theme is switched or because GTK detects
// that a change has occurred in the contents of the current icon theme.
func (v *IconTheme) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "changed", false, unsafe.Pointer(C._gotk4_gtk4_IconTheme_ConnectChanged), f)
}
