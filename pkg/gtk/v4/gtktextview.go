// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_TextView_ConnectToggleOverwrite(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectToggleCursorVisible(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectSetAnchor(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectSelectAll(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectBackspace(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeTextExtendSelection = coreglib.Type(girepository.MustFind("Gtk", "TextExtendSelection").RegisteredGType())
	GTypeTextViewLayer       = coreglib.Type(girepository.MustFind("Gtk", "TextViewLayer").RegisteredGType())
	GTypeTextWindowType      = coreglib.Type(girepository.MustFind("Gtk", "TextWindowType").RegisteredGType())
	GTypeTextView            = coreglib.Type(girepository.MustFind("Gtk", "TextView").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTextExtendSelection, F: marshalTextExtendSelection},
		coreglib.TypeMarshaler{T: GTypeTextViewLayer, F: marshalTextViewLayer},
		coreglib.TypeMarshaler{T: GTypeTextWindowType, F: marshalTextWindowType},
		coreglib.TypeMarshaler{T: GTypeTextView, F: marshalTextView},
	})
}

// TEXT_VIEW_PRIORITY_VALIDATE: priority at which the text view validates
// onscreen lines in an idle job in the background.
const TEXT_VIEW_PRIORITY_VALIDATE = 125

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection C.gint

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = iota
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextExtendSelection.
func (t TextExtendSelection) String() string {
	switch t {
	case TextExtendSelectionWord:
		return "Word"
	case TextExtendSelectionLine:
		return "Line"
	default:
		return fmt.Sprintf("TextExtendSelection(%d)", t)
	}
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer C.gint

const (
	// TextViewLayerBelowText: layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = iota
	// TextViewLayerAboveText: layer rendered above the text.
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextViewLayer.
func (t TextViewLayer) String() string {
	switch t {
	case TextViewLayerBelowText:
		return "BelowText"
	case TextViewLayerAboveText:
		return "AboveText"
	default:
		return fmt.Sprintf("TextViewLayer(%d)", t)
	}
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType C.gint

const (
	// TextWindowWidget: window that floats over scrolling areas.
	TextWindowWidget TextWindowType = 1
	// TextWindowText: scrollable text window.
	TextWindowText TextWindowType = 2
	// TextWindowLeft: left side border window.
	TextWindowLeft TextWindowType = 3
	// TextWindowRight: right side border window.
	TextWindowRight TextWindowType = 4
	// TextWindowTop: top border window.
	TextWindowTop TextWindowType = 5
	// TextWindowBottom: bottom border window.
	TextWindowBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextWindowType.
func (t TextWindowType) String() string {
	switch t {
	case TextWindowWidget:
		return "Widget"
	case TextWindowText:
		return "Text"
	case TextWindowLeft:
		return "Left"
	case TextWindowRight:
		return "Right"
	case TextWindowTop:
		return "Top"
	case TextWindowBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("TextWindowType(%d)", t)
	}
}

// TextViewOverrides contains methods that are overridable.
type TextViewOverrides struct {
}

func defaultTextViewOverrides(v *TextView) TextViewOverrides {
	return TextViewOverrides{}
}

// TextView: widget that displays the contents of a gtk.TextBuffer.
//
// !An example GtkTextview (multiline-text.png)
//
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// GtkTextView uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*TextView)(nil)
	_ coreglib.Objector = (*TextView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextView, *TextViewClass, TextViewOverrides](
		GTypeTextView,
		initTextViewClass,
		wrapTextView,
		defaultTextViewOverrides,
	)
}

func initTextViewClass(gclass unsafe.Pointer, overrides TextViewOverrides, classInitFunc func(*TextViewClass)) {
	if classInitFunc != nil {
		class := (*TextViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextView(obj *coreglib.Object) *TextView {
	return &TextView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	return wrapTextView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectBackspace gets emitted when the user asks for it.
//
// The ::backspace signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Backspace</kbd> and
// <kbd>Shift</kbd>-<kbd>Backspace</kbd>.
func (v *TextView) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "backspace", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectBackspace), f)
}

// ConnectCopyClipboard gets emitted to copy the selection to the clipboard.
//
// The ::copy-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>c</kbd> and
// <kbd>Ctrl</kbd>-<kbd>Insert</kbd>.
func (v *TextView) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectCopyClipboard), f)
}

// ConnectCutClipboard gets emitted to cut the selection to the clipboard.
//
// The ::cut-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>x</kbd> and
// <kbd>Shift</kbd>-<kbd>Delete</kbd>.
func (v *TextView) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectCutClipboard), f)
}

// ConnectInsertAtCursor gets emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// The ::insert-at-cursor signal is a keybinding signal
// (class.SignalAction.html).
//
// This signal has no default bindings.
func (v *TextView) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectInsertAtCursor), f)
}

// ConnectInsertEmoji gets emitted to present the Emoji chooser for the
// text_view.
//
// The ::insert-emoji signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>.</kbd> and
// <kbd>Ctrl</kbd>-<kbd>;</kbd>.
func (v *TextView) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectInsertEmoji), f)
}

// ConnectPasteClipboard gets emitted to paste the contents of the clipboard
// into the text view.
//
// The ::paste-clipboard signal is a keybinding signal
// (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>v</kbd> and
// <kbd>Shift</kbd>-<kbd>Insert</kbd>.
func (v *TextView) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectPasteClipboard), f)
}

// ConnectPreeditChanged is emitted when preedit text of the active IM changes.
//
// If an input method is used, the typed text will not immediately be committed
// to the buffer. So if you are interested in the text, connect to this signal.
//
// This signal is only emitted if the text at the given position is actually
// editable.
func (v *TextView) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectPreeditChanged), f)
}

// ConnectSelectAll gets emitted to select or unselect the complete contents of
// the text view.
//
// The ::select-all signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>a</kbd> and
// <kbd>Ctrl</kbd>-<kbd>/</kbd> for selecting and
// <kbd>Shift</kbd>-<kbd>Ctrl</kbd>-<kbd>a</kbd> and
// <kbd>Ctrl</kbd>-<kbd>\</kbd> for unselecting.
func (v *TextView) ConnectSelectAll(f func(sel bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectSelectAll), f)
}

// ConnectSetAnchor gets emitted when the user initiates settings the "anchor"
// mark.
//
// The ::set-anchor signal is a keybinding signal (class.SignalAction.html)
// which gets emitted when the user initiates setting the "anchor" mark. The
// "anchor" mark gets placed at the same position as the "insert" mark.
//
// This signal has no default bindings.
func (v *TextView) ConnectSetAnchor(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "set-anchor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectSetAnchor), f)
}

// ConnectToggleCursorVisible gets emitted to toggle the cursor-visible
// property.
//
// The ::toggle-cursor-visible signal is a keybinding signal
// (class.SignalAction.html).
//
// The default binding for this signal is <kbd>F7</kbd>.
func (v *TextView) ConnectToggleCursorVisible(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-cursor-visible", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectToggleCursorVisible), f)
}

// ConnectToggleOverwrite gets emitted to toggle the overwrite mode of the text
// view.
//
// The ::toggle-overwrite signal is a keybinding signal
// (class.SignalAction.html).
//
// The default binding for this signal is <kbd>Insert</kbd>.
func (v *TextView) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectToggleOverwrite), f)
}

// TextViewClass: instance of this type is always passed by reference.
type TextViewClass struct {
	*textViewClass
}

// textViewClass is the struct that's finalized.
type textViewClass struct {
	native unsafe.Pointer
}

var GIRInfoTextViewClass = girepository.MustFind("Gtk", "TextViewClass")
