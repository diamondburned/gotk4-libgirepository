// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_TreeModel_ConnectRowsReordered(gpointer, void*, void*, gpointer, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowInserted(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowHasChildToggled(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowDeleted(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowChanged(gpointer, void*, void*, guintptr);
import "C"

// GType values.
var (
	GTypeTreeModelFlags   = coreglib.Type(girepository.MustFind("Gtk", "TreeModelFlags").RegisteredGType())
	GTypeTreeModel        = coreglib.Type(girepository.MustFind("Gtk", "TreeModel").RegisteredGType())
	GTypeTreeIter         = coreglib.Type(girepository.MustFind("Gtk", "TreeIter").RegisteredGType())
	GTypeTreePath         = coreglib.Type(girepository.MustFind("Gtk", "TreePath").RegisteredGType())
	GTypeTreeRowReference = coreglib.Type(girepository.MustFind("Gtk", "TreeRowReference").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTreeModelFlags, F: marshalTreeModelFlags},
		coreglib.TypeMarshaler{T: GTypeTreeModel, F: marshalTreeModel},
		coreglib.TypeMarshaler{T: GTypeTreeIter, F: marshalTreeIter},
		coreglib.TypeMarshaler{T: GTypeTreePath, F: marshalTreePath},
		coreglib.TypeMarshaler{T: GTypeTreeRowReference, F: marshalTreeRowReference},
	})
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags C.guint

const (
	// TreeModelItersPersist iterators survive all signals emitted by the tree.
	TreeModelItersPersist TreeModelFlags = 0b1
	// TreeModelListOnly: model is a list only, and never has children.
	TreeModelListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TreeModelFlags.
func (t TreeModelFlags) String() string {
	if t == 0 {
		return "TreeModelFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(39)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TreeModelItersPersist:
			builder.WriteString("ItersPersist|")
		case TreeModelListOnly:
			builder.WriteString("ListOnly|")
		default:
			builder.WriteString(fmt.Sprintf("TreeModelFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TreeModelFlags) Has(other TreeModelFlags) bool {
	return (t & other) == other
}

// TreeModelForEachFunc: type of the callback passed to gtk_tree_model_foreach()
// to iterate over the rows in a tree model.
type TreeModelForEachFunc func(model TreeModeller, path *TreePath, iter *TreeIter) (ok bool)

// TreeModelOverrider contains methods that are overridable.
type TreeModelOverrider interface {
}

// TreeModel: tree interface used by GtkTreeView
//
// The TreeModel interface defines a generic tree interface for use by the
// TreeView widget. It is an abstract interface, and is designed to be usable
// with any appropriate data structure. The programmer just has to implement
// this interface on their own data type for it to be viewable by a TreeView
// widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the gtk.TreePath and the gtk.TreeIter (“iter” is short for iterator).
// Most of the interface consists of operations on a gtk.TreeIter.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. A gtk.TreePath
// can be converted into either an array of unsigned integers or a string. The
// string form is a list of numbers separated by a colon. Each number refers to
// the offset at that level. Thus, the path 0 refers to the root node and the
// path 2:4 refers to the fifth child of the third node.
//
// By contrast, a gtk.TreeIter is a reference to a specific node on a specific
// model. It is a generic struct with an integer and three generic pointers.
// These are filled in by the model in a model-specific way. One can convert a
// path to an iterator by calling gtk_tree_model_get_iter(). These iterators are
// the primary way of accessing a model and are similar to the iterators used by
// TextBuffer. They are generally statically allocated on the stack and only
// used for a short time. The model interface defines a set of operations using
// them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location 3:2:5.
// While the first method shown is easier, the second is much more common, as
// you often get paths from callbacks.
//
// Acquiring a GtkTreeIter
//
//    // Three ways of getting the iter pointing to the location
//    GtkTreePath *path;
//    GtkTreeIter iter;
//    GtkTreeIter parent_iter;
//
//    // get the iterator from a string
//    gtk_tree_model_get_iter_from_string (model,
//                                         &iter,
//                                         "3:2:5");
//
//    // get the iterator from a path
//    path = gtk_tree_path_new_from_string ("3:2:5");
//    gtk_tree_model_get_iter (model, &iter, path);
//    gtk_tree_path_free (path);
//
//    // walk the tree to find the iterator
//    gtk_tree_model_iter_nth_child (model, &iter,
//                                   NULL, 3);
//    parent_iter = iter;
//    gtk_tree_model_iter_nth_child (model, &iter,
//                                   &parent_iter, 2);
//    parent_iter = iter;
//    gtk_tree_model_iter_nth_child (model, &iter,
//                                   &parent_iter, 5);
//
//
// This second example shows a quick way of iterating through a list and getting
// a string and an integer from each row. The populate_model() function used
// below is not shown, as it is specific to the ListStore. For information on
// how to write such a function, see the ListStore documentation.
//
// Reading data from a GtkTreeModel
//
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
//
//    ...
//
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    int row_count = 0;
//
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
//
//    // Fill the list store with data
//    populate_model (list_store);
//
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
//
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       char *str_data;
//       int    int_data;
//
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
//
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
//
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
//
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
//
// TreeModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TreeModel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TreeModel)(nil)
)

// TreeModeller describes TreeModel's interface methods.
type TreeModeller interface {
	coreglib.Objector

	baseTreeModel() *TreeModel
}

var _ TreeModeller = (*TreeModel)(nil)

func ifaceInitTreeModeller(gifacePtr, data C.gpointer) {
}

func wrapTreeModel(obj *coreglib.Object) *TreeModel {
	return &TreeModel{
		Object: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	return wrapTreeModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *TreeModel) baseTreeModel() *TreeModel {
	return v
}

// BaseTreeModel returns the underlying base object.
func BaseTreeModel(obj TreeModeller) *TreeModel {
	return obj.baseTreeModel()
}

// ConnectRowChanged: this signal is emitted when a row in the model has
// changed.
func (v *TreeModel) ConnectRowChanged(f func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowChanged), f)
}

// ConnectRowDeleted: this signal is emitted when a row has been deleted.
//
// Note that no iterator is passed to the signal handler, since the row is
// already deleted.
//
// This should be called by models after a row has been removed. The location
// pointed to by path should be the location that the row previously was at. It
// may not be a valid location anymore.
func (v *TreeModel) ConnectRowDeleted(f func(path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-deleted", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowDeleted), f)
}

// ConnectRowHasChildToggled: this signal is emitted when a row has gotten the
// first child row or lost its last child row.
func (v *TreeModel) ConnectRowHasChildToggled(f func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-has-child-toggled", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowHasChildToggled), f)
}

// ConnectRowInserted: this signal is emitted when a new row has been inserted
// in the model.
//
// Note that the row may still be empty at this point, since it is a common
// pattern to first insert an empty row, and then fill it with the desired
// values.
func (v *TreeModel) ConnectRowInserted(f func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-inserted", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowInserted), f)
}

// ConnectRowsReordered: this signal is emitted when the children of a node in
// the TreeModel have been reordered.
//
// Note that this signal is not emitted when rows are reordered by DND, since
// this is implemented by removing and then reinserting the row.
func (v *TreeModel) ConnectRowsReordered(f func(path *TreePath, iter *TreeIter, newOrder unsafe.Pointer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "rows-reordered", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowsReordered), f)
}

// TreeIter is the primary structure for accessing a TreeModel. Models are
// expected to put a unique integer in the stamp member, and put model-specific
// data in the three user_data members.
//
// An instance of this type is always passed by reference.
type TreeIter struct {
	*treeIter
}

// treeIter is the struct that's finalized.
type treeIter struct {
	native unsafe.Pointer
}

var GIRInfoTreeIter = girepository.MustFind("Gtk", "TreeIter")

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreeIter{&treeIter{(unsafe.Pointer)(b)}}, nil
}

// Stamp: unique stamp to catch invalid iterators.
func (t *TreeIter) Stamp() int {
	offset := GIRInfoTreeIter.StructFieldOffset("stamp")
	valptr := (*int)(unsafe.Add(t.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// UserData: model-specific data.
func (t *TreeIter) UserData() unsafe.Pointer {
	offset := GIRInfoTreeIter.StructFieldOffset("user_data")
	valptr := (*unsafe.Pointer)(unsafe.Add(t.native, offset))
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// UserData2: model-specific data.
func (t *TreeIter) UserData2() unsafe.Pointer {
	offset := GIRInfoTreeIter.StructFieldOffset("user_data2")
	valptr := (*unsafe.Pointer)(unsafe.Add(t.native, offset))
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// UserData3: model-specific data.
func (t *TreeIter) UserData3() unsafe.Pointer {
	offset := GIRInfoTreeIter.StructFieldOffset("user_data3")
	valptr := (*unsafe.Pointer)(unsafe.Add(t.native, offset))
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Stamp: unique stamp to catch invalid iterators.
func (t *TreeIter) SetStamp(stamp int) {
	offset := GIRInfoTreeIter.StructFieldOffset("stamp")
	valptr := (*C.int)(unsafe.Add(t.native, offset))
	*valptr = C.int(stamp)
}

// TreeModelIface: instance of this type is always passed by reference.
type TreeModelIface struct {
	*treeModelIface
}

// treeModelIface is the struct that's finalized.
type treeModelIface struct {
	native unsafe.Pointer
}

var GIRInfoTreeModelIface = girepository.MustFind("Gtk", "TreeModelIface")

// TreePath: opaque structure representing a path to a row in a model.
//
// An instance of this type is always passed by reference.
type TreePath struct {
	*treePath
}

// treePath is the struct that's finalized.
type treePath struct {
	native unsafe.Pointer
}

var GIRInfoTreePath = girepository.MustFind("Gtk", "TreePath")

func marshalTreePath(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreePath{&treePath{(unsafe.Pointer)(b)}}, nil
}

// TreeRowReference tracks model changes so that it always refers to the same
// row (a TreePath refers to a position, not a fixed row). Create a new
// GtkTreeRowReference with gtk_tree_row_reference_new().
//
// An instance of this type is always passed by reference.
type TreeRowReference struct {
	*treeRowReference
}

// treeRowReference is the struct that's finalized.
type treeRowReference struct {
	native unsafe.Pointer
}

var GIRInfoTreeRowReference = girepository.MustFind("Gtk", "TreeRowReference")

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreeRowReference{&treeRowReference{(unsafe.Pointer)(b)}}, nil
}
