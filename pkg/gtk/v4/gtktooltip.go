// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeTooltip = coreglib.Type(girepository.MustFind("Gtk", "Tooltip").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTooltip, F: marshalTooltip},
	})
}

// Tooltip: GtkTooltip is an object representing a widget tooltip.
//
// Basic tooltips can be realized simply by using gtk.Widget.SetTooltipText() or
// gtk.Widget.SetTooltipMarkup() without any explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per GtkTreeView row
// or cell, you will have to do a little more work:
//
// - Set the gtk.Widget:has-tooltip property to TRUE. This will make GTK monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
//
// - Connect to the gtk.Widget::query-tooltip signal. This signal will be
// emitted when a tooltip is supposed to be shown. One of the arguments passed
// to the signal handler is a GtkTooltip object. This is the object that we are
// about to display as a tooltip, and can be manipulated in your callback using
// functions like gtk.Tooltip.SetIcon(). There are functions for setting the
// tooltipâ€™s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
// - Return TRUE from your ::query-tooltip handler. This causes the tooltip to
// be show. If you return FALSE, it will not be shown.
type Tooltip struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Tooltip)(nil)
)

func wrapTooltip(obj *coreglib.Object) *Tooltip {
	return &Tooltip{
		Object: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	return wrapTooltip(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
