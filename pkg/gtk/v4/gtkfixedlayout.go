// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFixedLayout      = coreglib.Type(girepository.MustFind("Gtk", "FixedLayout").RegisteredGType())
	GTypeFixedLayoutChild = coreglib.Type(girepository.MustFind("Gtk", "FixedLayoutChild").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFixedLayout, F: marshalFixedLayout},
		coreglib.TypeMarshaler{T: GTypeFixedLayoutChild, F: marshalFixedLayoutChild},
	})
}

// FixedLayoutOverrides contains methods that are overridable.
type FixedLayoutOverrides struct {
}

func defaultFixedLayoutOverrides(v *FixedLayout) FixedLayoutOverrides {
	return FixedLayoutOverrides{}
}

// FixedLayout: GtkFixedLayout is a layout manager which can place child widgets
// at fixed positions.
//
// Most applications should never use this layout manager; fixed positioning and
// sizing requires constant recalculations on where children need to be
// positioned and sized. Other layout managers perform this kind of work
// internally so that application developers don't need to do it. Specifically,
// widgets positioned in a fixed layout manager will need to take into account:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, GtkFixedLayout does not pay attention to text direction and thus
// may produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately depending on the text direction, e.g. to put labels to the
// right of the thing they label when using an RTL language; GtkFixedLayout
// won't be able to do that for you.
//
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
type FixedLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*FixedLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FixedLayout, *FixedLayoutClass, FixedLayoutOverrides](
		GTypeFixedLayout,
		initFixedLayoutClass,
		wrapFixedLayout,
		defaultFixedLayoutOverrides,
	)
}

func initFixedLayoutClass(gclass unsafe.Pointer, overrides FixedLayoutOverrides, classInitFunc func(*FixedLayoutClass)) {
	if classInitFunc != nil {
		class := (*FixedLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFixedLayout(obj *coreglib.Object) *FixedLayout {
	return &FixedLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalFixedLayout(p uintptr) (interface{}, error) {
	return wrapFixedLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FixedLayoutChildOverrides contains methods that are overridable.
type FixedLayoutChildOverrides struct {
}

func defaultFixedLayoutChildOverrides(v *FixedLayoutChild) FixedLayoutChildOverrides {
	return FixedLayoutChildOverrides{}
}

// FixedLayoutChild: GtkLayoutChild subclass for children in a GtkFixedLayout.
type FixedLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*FixedLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FixedLayoutChild, *FixedLayoutChildClass, FixedLayoutChildOverrides](
		GTypeFixedLayoutChild,
		initFixedLayoutChildClass,
		wrapFixedLayoutChild,
		defaultFixedLayoutChildOverrides,
	)
}

func initFixedLayoutChildClass(gclass unsafe.Pointer, overrides FixedLayoutChildOverrides, classInitFunc func(*FixedLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*FixedLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFixedLayoutChild(obj *coreglib.Object) *FixedLayoutChild {
	return &FixedLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalFixedLayoutChild(p uintptr) (interface{}, error) {
	return wrapFixedLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FixedLayoutChildClass: instance of this type is always passed by reference.
type FixedLayoutChildClass struct {
	*fixedLayoutChildClass
}

// fixedLayoutChildClass is the struct that's finalized.
type fixedLayoutChildClass struct {
	native unsafe.Pointer
}

var GIRInfoFixedLayoutChildClass = girepository.MustFind("Gtk", "FixedLayoutChildClass")

// FixedLayoutClass: instance of this type is always passed by reference.
type FixedLayoutClass struct {
	*fixedLayoutClass
}

// fixedLayoutClass is the struct that's finalized.
type fixedLayoutClass struct {
	native unsafe.Pointer
}

var GIRInfoFixedLayoutClass = girepository.MustFind("Gtk", "FixedLayoutClass")
