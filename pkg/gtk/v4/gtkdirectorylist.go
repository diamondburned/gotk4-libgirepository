// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeDirectoryList = coreglib.Type(girepository.MustFind("Gtk", "DirectoryList").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDirectoryList, F: marshalDirectoryList},
	})
}

// DirectoryListOverrides contains methods that are overridable.
type DirectoryListOverrides struct {
}

func defaultDirectoryListOverrides(v *DirectoryList) DirectoryListOverrides {
	return DirectoryListOverrides{}
}

// DirectoryList: GtkDirectoryList is a list model that wraps
// g_file_enumerate_children_async().
//
// It presents a GListModel and fills it asynchronously with the GFileInfos
// returned from that function.
//
// Enumeration will start automatically when a the gtk.DirectoryList:file
// property is set.
//
// While the GtkDirectoryList is being filled, the gtk.DirectoryList:loading
// property will be set to TRUE. You can listen to that property if you want to
// show information like a GtkSpinner or a "Loading..." text.
//
// If loading fails at any point, the gtk.DirectoryList:error property will be
// set to give more indication about the failure.
//
// The GFileInfos returned from a GtkDirectoryList have the "standard::file"
// attribute set to the GFile they refer to. This way you can get at the file
// that is referred to in the same way you would via
// g_file_enumerator_get_child(). This means you do not need access to the
// GtkDirectoryList, but can access the GFile directly from the GFileInfo when
// operating with a GtkListView or similar.
type DirectoryList struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*DirectoryList)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DirectoryList, *DirectoryListClass, DirectoryListOverrides](
		GTypeDirectoryList,
		initDirectoryListClass,
		wrapDirectoryList,
		defaultDirectoryListOverrides,
	)
}

func initDirectoryListClass(gclass unsafe.Pointer, overrides DirectoryListOverrides, classInitFunc func(*DirectoryListClass)) {
	if classInitFunc != nil {
		class := (*DirectoryListClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDirectoryList(obj *coreglib.Object) *DirectoryList {
	return &DirectoryList{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalDirectoryList(p uintptr) (interface{}, error) {
	return wrapDirectoryList(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DirectoryListClass: instance of this type is always passed by reference.
type DirectoryListClass struct {
	*directoryListClass
}

// directoryListClass is the struct that's finalized.
type directoryListClass struct {
	native unsafe.Pointer
}

var GIRInfoDirectoryListClass = girepository.MustFind("Gtk", "DirectoryListClass")
