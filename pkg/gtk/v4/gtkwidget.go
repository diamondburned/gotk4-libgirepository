// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_Widget_ConnectUnrealize(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectUnmap(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectMap(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectDestroy(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_Widget_ConnectQueryTooltip(gpointer, gint, gint, gboolean, void*, guintptr);
// extern gboolean _gotk4_gtk4_Widget_ConnectMnemonicActivate(gpointer, gboolean, guintptr);
import "C"

// GType values.
var (
	GTypeWidget      = coreglib.Type(girepository.MustFind("Gtk", "Widget").RegisteredGType())
	GTypeRequisition = coreglib.Type(girepository.MustFind("Gtk", "Requisition").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWidget, F: marshalWidget},
		coreglib.TypeMarshaler{T: GTypeRequisition, F: marshalRequisition},
	})
}

// Allocation: rectangle representing the area allocated for a widget by its
// parent.
type Allocation = gdk.Rectangle

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widgetter, frameClock gdk.FrameClocker) (ok bool)

// WidgetOverrides contains methods that are overridable.
type WidgetOverrides struct {
}

func defaultWidgetOverrides(v *Widget) WidgetOverrides {
	return WidgetOverrides{}
}

// Widget: base class for all widgets.
//
// GtkWidget is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - gtk.Widget.GetRequestMode()
//
// - gtk.Widget.Measure()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct GtkWidget subclass that supports height-for-width
// or width-for-height geometry management for itself or its child widgets, the
// gtk.Widget.GetRequestMode() virtual function must be implemented as well and
// return the widget's preferred request mode. The default implementation of
// this virtual function returns GTK_SIZE_REQUEST_CONSTANT_SIZE, which means
// that the widget will only ever get -1 passed as the for_size value to its
// gtk.Widget.Measure() implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the gtk.SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode:
//
// First, the default minimum and natural width for each widget in the interface
// will be computed using gtk_widget_measure with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// gtk_widget_measure with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk.Window.SetDefaultSize()). During the recursive allocation
// process it’s important to note that request cycles will be recursively
// executed while widgets allocate their children. Each widget, once allocated a
// size, will go on to first share the space in one orientation among its
// children and then request each child's height for its target allocated width
// or its width for allocated height, depending. In this way a GtkWidget will
// typically be requested its size a number of times before actually being
// allocated a size. The size a widget is finally allocated can of course differ
// from the size it has requested. For this reason, GtkWidget caches a small
// number of results to avoid re-querying for the same sizes in one allocation
// cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both GtkSizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a gtk.Label that does height-for-width word wrapping will not
// expect to have gtk.Widget.Measure() with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
//    static void
//    foo_widget_measure (GtkWidget      *widget,
//                        GtkOrientation  orientation,
//                        int             for_size,
//                        int            *minimum_size,
//                        int            *natural_size,
//                        int            *minimum_baseline,
//                        int            *natural_baseline)
//    {
//      if (orientation == GTK_ORIENTATION_HORIZONTAL)
//        {
//          // Calculate minimum and natural width
//        }
//      else // VERTICAL
//        {
//          if (i_am_in_height_for_width_mode)
//            {
//              int min_width, dummy;
//
//              // First, get the minimum width of our widget
//              GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//                                                      &min_width, &dummy, &dummy, &dummy);
//
//              // Now use the minimum width to retrieve the minimum and natural height to display
//              // that width.
//              GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//                                                      minimum_size, natural_size, &dummy, &dummy);
//            }
//          else
//            {
//              // ... some widgets do both.
//            }
//        }
//    }
//
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
//
// It will not work to use the wrapper function gtk.Widget.Measure() inside your
// own gtk.Widget.SizeAllocate() implementation. These return a request adjusted
// by gtk.SizeGroup, the widget's align and expand flags, as well as its CSS
// style.
//
// If a widget used the wrappers inside its virtual method implementations, then
// the adjustments (such as widget margins) would be applied twice. GTK
// therefore does not allow this and will warn if you try to do it.
//
// Of course if you are getting the size request for another widget, such as a
// child widget, you must use gtk_widget_measure; otherwise, you would not
// properly consider widget margins, gtk.SizeGroup, and so forth.
//
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in the
// same row are aligned. This happens if a widget supports baselines, has a
// vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural “row” that it aligns to the baseline, or
// a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// gtk.Widget.Measure() virtual function. It allows you to report both a minimum
// and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via gtk_widget_get_allocated_baseline. If the baseline has a value
// other than -1 you need to align the widget such that the baseline appears at
// the position.
//
//
// GtkWidget as GtkBuildable
//
// The GtkWidget implementation of the GtkBuildable interface supports various
// custom elements to specify additional aspects of widgets that are not
// directly expressed as properties.
//
// If the widget uses a gtk.LayoutManager, GtkWidget supports a custom <layout>
// element, used to define layout properties:
//
//    <object class="GtkGrid" id="my_grid">
//      <child>
//        <object class="GtkLabel" id="label1">
//          <property name="label">Description</property>
//          <layout>
//            <property name="column">0</property>
//            <property name="row">0</property>
//            <property name="row-span">1</property>
//            <property name="column-span">1</property>
//          </layout>
//        </object>
//      </child>
//      <child>
//        <object class="GtkEntry" id="description_entry">
//          <layout>
//            <property name="column">1</property>
//            <property name="row">0</property>
//            <property name="row-span">1</property>
//            <property name="column-span">1</property>
//          </layout>
//        </object>
//      </child>
//    </object>
//
//
// GtkWidget allows style information such as style classes to be associated
// with widgets, using the custom <style> element:
//
//    <object class="GtkButton" id="button1">
//      <style>
//        <class name="my-special-button-class"/>
//        <class name="dark-button"/>
//      </style>
//    </object>
//
//
// GtkWidget allows defining accessibility information, such as properties,
// relations, and states, using the custom <accessibility> element:
//
//    <object class="GtkButton" id="button1">
//      <accessibility>
//        <property name="label">Download</property>
//        <relation name="labelled-by">label1</relation>
//      </accessibility>
//    </object>
//
//
//
// Building composite widgets from template XML
//
// GtkWidget exposes some facilities to automate the procedure of creating
// composite widgets using "templates".
//
// To create composite widgets with GtkBuilder XML, one must associate the
// interface description with the widget class at class initialization time
// using gtk.WidgetClass.SetTemplate().
//
// The interface description semantics expected in composite template
// descriptions is slightly different from regular gtk.Builder XML.
//
// Unlike regular interface descriptions, gtk.WidgetClass.SetTemplate() will
// expect a <template> tag as a direct child of the toplevel <interface> tag.
// The <template> tag must specify the “class” attribute which must be the type
// name of the widget. Optionally, the “parent” attribute may be specified to
// specify the direct parent type of the widget type, this is ignored by
// GtkBuilder but required for UI design tools like Glade
// (https://glade.gnome.org/) to introspect what kind of properties and internal
// children exist for a given type when the actual type does not exist.
//
// The XML which is contained inside the <template> tag behaves as if it were
// added to the <object> tag defining the widget itself. You may set properties
// on a widget by inserting <property> tags into the <template> tag, and also
// add <child> tags to add children and extend a widget in the normal way you
// would with <object> tags.
//
// Additionally, <object> tags can also be added before and after the initial
// <template> tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// <template> tag.
//
// An example of a template definition:
//
//    <interface>
//      <template class="FooWidget" parent="GtkBox">
//        <property name="orientation">horizontal</property>
//        <property name="spacing">4</property>
//        <child>
//          <object class="GtkButton" id="hello_button">
//            <property name="label">Hello World</property>
//            <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
//          </object>
//        </child>
//        <child>
//          <object class="GtkButton" id="goodbye_button">
//            <property name="label">Goodbye World</property>
//          </object>
//        </child>
//      </template>
//    </interface>
//
//
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using GResource. In order to load the template, you need
// to call gtk.WidgetClass.SetTemplateFromResource() from the class
// initialization of your GtkWidget type:
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//    }
//
//
// You will also need to call gtk.Widget.InitTemplate() from the instance
// initialization function:
//
//    static void
//    foo_widget_init (FooWidget *self)
//    {
//      // ...
//      gtk_widget_init_template (GTK_WIDGET (self));
//    }
//
//
// You can access widgets defined in the template using the
// gtk_widget_get_template_child function, but you will typically declare a
// pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// gtk.WidgetClass.BindTemplateChildFull() (or one of its wrapper macros
// gtk.WidgetClassBindTemplateChild() and
// gtk.WidgetClassBindTemplateChildPrivate()) with that name, e.g.
//
//    typedef struct {
//      GtkWidget *hello_button;
//      GtkWidget *goodbye_button;
//    } FooWidgetPrivate;
//
//    G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//                                                    FooWidget, hello_button);
//      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//                                                    FooWidget, goodbye_button);
//    }
//
//    static void
//    foo_widget_init (FooWidget *widget)
//    {
//
//    }
//
//
// You can also use gtk.WidgetClass.BindTemplateCallbackFull() (or is wrapper
// macro gtk.WidgetClassBindTemplateCallback()) to connect a signal callback
// defined in the template with a function visible in the scope of the class,
// e.g.
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }.
type Widget struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	Accessible
	Buildable
	ConstraintTarget
}

var (
	_ coreglib.Objector = (*Widget)(nil)
)

// Widgetter describes types inherited from class Widget.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Widgetter interface {
	coreglib.Objector
	baseWidget() *Widget
}

var _ Widgetter = (*Widget)(nil)

func init() {
	coreglib.RegisterClassInfo[*Widget, *WidgetClass, WidgetOverrides](
		GTypeWidget,
		initWidgetClass,
		wrapWidget,
		defaultWidgetOverrides,
	)
}

func initWidgetClass(gclass unsafe.Pointer, overrides WidgetOverrides, classInitFunc func(*WidgetClass)) {
	if classInitFunc != nil {
		class := (*WidgetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWidget(obj *coreglib.Object) *Widget {
	return &Widget{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		Accessible: Accessible{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		ConstraintTarget: ConstraintTarget{
			Object: obj,
		},
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	return wrapWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Widget) baseWidget() *Widget {
	return v
}

// BaseWidget returns the underlying base object.
func BaseWidget(obj Widgetter) *Widget {
	return obj.baseWidget()
}

// ConnectDestroy signals that all holders of a reference to the widget should
// release the reference that they hold.
//
// May result in finalization of the widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (v *Widget) ConnectDestroy(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "destroy", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectDestroy), f)
}

// ConnectHide is emitted when widget is hidden.
func (v *Widget) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "hide", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectHide), f)
}

// ConnectMap is emitted when widget is going to be mapped.
//
// A widget is mapped when the widget is visible (which is controlled with
// gtk.Widget:visible) and all its parents up to the toplevel widget are also
// visible.
//
// The ::map signal can be used to determine whether a widget will be drawn, for
// instance it can resume an animation that was stopped during the emission of
// gtk.Widget::unmap.
func (v *Widget) ConnectMap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "map", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMap), f)
}

// ConnectMnemonicActivate is emitted when a widget is activated via a mnemonic.
//
// The default handler for this signal activates widget if group_cycling is
// FALSE, or just makes widget grab focus if group_cycling is TRUE.
func (v *Widget) ConnectMnemonicActivate(f func(groupCycling bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "mnemonic-activate", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMnemonicActivate), f)
}

// ConnectQueryTooltip is emitted when the widgets tooltip is about to be shown.
//
// This happens when the gtk.Widget:has-tooltip property is TRUE and the hover
// timeout has expired with the cursor hovering "above" widget; or emitted when
// widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for widget. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
func (v *Widget) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectQueryTooltip), f)
}

// ConnectRealize is emitted when widget is associated with a GdkSurface.
//
// This means that gtk.Widget.Realize() has been called or the widget has been
// mapped (that is, it is going to be drawn).
func (v *Widget) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "realize", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectRealize), f)
}

// ConnectShow is emitted when widget is shown.
func (v *Widget) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectShow), f)
}

// ConnectUnmap is emitted when widget is going to be unmapped.
//
// A widget is unmapped when either it or any of its parents up to the toplevel
// widget have been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer, it can be
// used to, for example, stop an animation on the widget.
func (v *Widget) ConnectUnmap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unmap", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectUnmap), f)
}

// ConnectUnrealize is emitted when the GdkSurface associated with widget is
// destroyed.
//
// This means that gtk.Widget.Unrealize() has been called or the widget has been
// unmapped (that is, it is going to be hidden).
func (v *Widget) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unrealize", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectUnrealize), f)
}

// Requisition represents the desired size of a widget. See [GtkWidget’s
// geometry management section][geometry-management] for more information.
//
// An instance of this type is always passed by reference.
type Requisition struct {
	*requisition
}

// requisition is the struct that's finalized.
type requisition struct {
	native unsafe.Pointer
}

var GIRInfoRequisition = girepository.MustFind("Gtk", "Requisition")

func marshalRequisition(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Requisition{&requisition{(unsafe.Pointer)(b)}}, nil
}

// Width widget’s desired width.
func (r *Requisition) Width() int {
	offset := GIRInfoRequisition.StructFieldOffset("width")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height widget’s desired height.
func (r *Requisition) Height() int {
	offset := GIRInfoRequisition.StructFieldOffset("height")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width widget’s desired width.
func (r *Requisition) SetWidth(width int) {
	offset := GIRInfoRequisition.StructFieldOffset("width")
	valptr := (*C.int)(unsafe.Add(r.native, offset))
	*valptr = C.int(width)
}

// Height widget’s desired height.
func (r *Requisition) SetHeight(height int) {
	offset := GIRInfoRequisition.StructFieldOffset("height")
	valptr := (*C.int)(unsafe.Add(r.native, offset))
	*valptr = C.int(height)
}

// WidgetClass: instance of this type is always passed by reference.
type WidgetClass struct {
	*widgetClass
}

// widgetClass is the struct that's finalized.
type widgetClass struct {
	native unsafe.Pointer
}

var GIRInfoWidgetClass = girepository.MustFind("Gtk", "WidgetClass")
