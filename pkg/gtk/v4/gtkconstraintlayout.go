// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeConstraintLayout      = coreglib.Type(girepository.MustFind("Gtk", "ConstraintLayout").RegisteredGType())
	GTypeConstraintLayoutChild = coreglib.Type(girepository.MustFind("Gtk", "ConstraintLayoutChild").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeConstraintLayout, F: marshalConstraintLayout},
		coreglib.TypeMarshaler{T: GTypeConstraintLayoutChild, F: marshalConstraintLayoutChild},
	})
}

// ConstraintLayoutOverrides contains methods that are overridable.
type ConstraintLayoutOverrides struct {
}

func defaultConstraintLayoutOverrides(v *ConstraintLayout) ConstraintLayoutOverrides {
	return ConstraintLayoutOverrides{}
}

// ConstraintLayout: layout manager using constraints to describe relations
// between widgets.
//
// GtkConstraintLayout is a layout manager that uses relations between widget
// attributes, expressed via gtk.Constraint instances, to measure and allocate
// widgets.
//
//
// How do constraints work
//
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the gtk.Constraint class to have a
// more in depth definition.
//
// By taking multiple constraints and applying them to the children of a widget
// using GtkConstraintLayout, it's possible to describe complex layout policies;
// each constraint applied to a child or to the parent widgets contributes to
// the full description of the layout, in terms of parameters for resolving the
// value of each attribute.
//
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
//
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
//
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
//
// A constraint-based layout with conflicting constraints may be unsolvable, and
// lead to an unstable layout. You can use the gtk.Constraint:strength property
// of gtk.Constraint to "nudge" the layout towards a solution.
//
//
// GtkConstraintLayout as GtkBuildable
//
// GtkConstraintLayout implements the gtk.Buildable interface and has a custom
// "constraints" element which allows describing constraints in a gtk.Builder UI
// file.
//
// An example of a UI definition fragment specifying a constraint:
//
//      <object class="GtkConstraintLayout">
//        <constraints>
//          <constraint target="button" target-attribute="start"
//                      relation="eq"
//                      source="super" source-attribute="start"
//                      constant="12"
//                      strength="required" />
//          <constraint target="button" target-attribute="width"
//                      relation="ge"
//                      constant="250"
//                      strength="strong" />
//        </constraints>
//      </object>
//
//
// The definition above will add two constraints to the GtkConstraintLayout:
//
//    - a required constraint between the leading edge of "button" and
//      the leading edge of the widget using the constraint layout, plus
//      12 pixels
//    - a strong, constant constraint making the width of "button" greater
//      than, or equal to 250 pixels
//
// The "target" and "target-attribute" attributes are required.
//
// The "source" and "source-attribute" attributes of the "constraint" element
// are optional; if they are not specified, the constraint is assumed to be a
// constant.
//
// The "relation" attribute is optional; if not specified, the constraint is
// assumed to be an equality.
//
// The "strength" attribute is optional; if not specified, the constraint is
// assumed to be required.
//
// The "source" and "target" attributes can be set to "super" to indicate that
// the constraint target is the widget using the GtkConstraintLayout.
//
// There can be "constant" and "multiplier" attributes.
//
// Additionally, the "constraints" element can also contain a description of the
// ConstraintGuides used by the layout:
//
//      <constraints>
//        <guide min-width="100" max-width="500" name="hspace"/>
//        <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
//      </constraints>
//
//
// The "guide" element has the following optional attributes:
//
//    - "min-width", "nat-width", and "max-width", describe the minimum,
//      natural, and maximum width of the guide, respectively
//    - "min-height", "nat-height", and "max-height", describe the minimum,
//      natural, and maximum height of the guide, respectively
//    - "strength" describes the strength of the constraint on the natural
//      size of the guide; if not specified, the constraint is assumed to
//      have a medium strength
//    - "name" describes a name for the guide, useful when debugging
//
//
// Using the Visual Format Language
//
// Complex constraints can be described using a compact syntax called VFL, or
// *Visual Format Language*.
//
// The Visual Format Language describes all the constraints on a row or column,
// typically starting from the leading edge towards the trailing one. Each
// element of the layout is composed by "views", which identify a
// gtk.ConstraintTarget.
//
// For instance:
//
//      [button]-[textField]
//
//
// Describes a constraint that binds the trailing edge of "button" to the
// leading edge of "textField", leaving a default space between the two.
//
// Using VFL is also possible to specify predicates that describe constraints on
// attributes like width and height:
//
//      // Width must be greater than, or equal to 50
//      [button(>=50)]
//
//      // Width of button1 must be equal to width of button2
//      [button1(==button2)]
//
//
// The default orientation for a VFL description is horizontal, unless otherwise
// specified:
//
//      // horizontal orientation, default attribute: width
//      H:[button(>=150)]
//
//      // vertical orientation, default attribute: height
//      V:[button1(==button2)]
//
//
// It's also possible to specify multiple predicates, as well as their strength:
//
//      // minimum width of button must be 150
//      // natural width of button can be 250
//      [button(>=150required, ==250medium)]
//
//
// Finally, it's also possible to use simple arithmetic operators:
//
//    // width of button1 must be equal to width of button2
//    // divided by 2 plus 12
//    [button1(button2 / 2 + 12)].
type ConstraintLayout struct {
	_ [0]func() // equal guard
	LayoutManager

	*coreglib.Object
	Buildable
}

var (
	_ LayoutManagerer   = (*ConstraintLayout)(nil)
	_ coreglib.Objector = (*ConstraintLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConstraintLayout, *ConstraintLayoutClass, ConstraintLayoutOverrides](
		GTypeConstraintLayout,
		initConstraintLayoutClass,
		wrapConstraintLayout,
		defaultConstraintLayoutOverrides,
	)
}

func initConstraintLayoutClass(gclass unsafe.Pointer, overrides ConstraintLayoutOverrides, classInitFunc func(*ConstraintLayoutClass)) {
	if classInitFunc != nil {
		class := (*ConstraintLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraintLayout(obj *coreglib.Object) *ConstraintLayout {
	return &ConstraintLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalConstraintLayout(p uintptr) (interface{}, error) {
	return wrapConstraintLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConstraintLayoutChildOverrides contains methods that are overridable.
type ConstraintLayoutChildOverrides struct {
}

func defaultConstraintLayoutChildOverrides(v *ConstraintLayoutChild) ConstraintLayoutChildOverrides {
	return ConstraintLayoutChildOverrides{}
}

// ConstraintLayoutChild: GtkLayoutChild subclass for children in a
// GtkConstraintLayout.
type ConstraintLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*ConstraintLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConstraintLayoutChild, *ConstraintLayoutChildClass, ConstraintLayoutChildOverrides](
		GTypeConstraintLayoutChild,
		initConstraintLayoutChildClass,
		wrapConstraintLayoutChild,
		defaultConstraintLayoutChildOverrides,
	)
}

func initConstraintLayoutChildClass(gclass unsafe.Pointer, overrides ConstraintLayoutChildOverrides, classInitFunc func(*ConstraintLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*ConstraintLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraintLayoutChild(obj *coreglib.Object) *ConstraintLayoutChild {
	return &ConstraintLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
	return wrapConstraintLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConstraintLayoutChildClass: instance of this type is always passed by
// reference.
type ConstraintLayoutChildClass struct {
	*constraintLayoutChildClass
}

// constraintLayoutChildClass is the struct that's finalized.
type constraintLayoutChildClass struct {
	native unsafe.Pointer
}

var GIRInfoConstraintLayoutChildClass = girepository.MustFind("Gtk", "ConstraintLayoutChildClass")

// ConstraintLayoutClass: instance of this type is always passed by reference.
type ConstraintLayoutClass struct {
	*constraintLayoutClass
}

// constraintLayoutClass is the struct that's finalized.
type constraintLayoutClass struct {
	native unsafe.Pointer
}

var GIRInfoConstraintLayoutClass = girepository.MustFind("Gtk", "ConstraintLayoutClass")
