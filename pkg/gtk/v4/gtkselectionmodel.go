// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_SelectionModel_ConnectSelectionChanged(gpointer, guint, guint, guintptr);
import "C"

// GType values.
var (
	GTypeSelectionModel = coreglib.Type(girepository.MustFind("Gtk", "SelectionModel").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSelectionModel, F: marshalSelectionModel},
	})
}

// SelectionModelOverrider contains methods that are overridable.
type SelectionModelOverrider interface {
}

// SelectionModel: GtkSelectionModel is an interface that add support for
// selection to list models.
//
// This support is then used by widgets using list models to add the ability to
// select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as gtk.SingleSelection, so you will only need to implement this interface if
// you want detailed control about how selections should be handled.
//
// A GtkSelectionModel supports a single boolean per item indicating if an item
// is selected or not. This can be queried via gtk.SelectionModel.IsSelected().
// When the selected state of one or more items changes, the model will emit the
// gtk.SelectionModel::selection-changed signal by calling the
// gtk.SelectionModel.SelectionChanged() function. The positions given in that
// signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the ::items-changed signal
// are selected or not is up to the implementation.
//
// Note that items added via ::items-changed may already be selected and no
// [Gtk.SelectionModel::selection-changed] will be emitted for them. So to track
// which items are selected, it is necessary to listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, GtkSelectionModels are free to
// only implement them partially or not at all. In that case the widgets will
// not support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate
// selection.
//
// SelectionModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type SelectionModel struct {
	_ [0]func() // equal guard
	gio.ListModel
}

var ()

// SelectionModeller describes SelectionModel's interface methods.
type SelectionModeller interface {
	coreglib.Objector

	baseSelectionModel() *SelectionModel
}

var _ SelectionModeller = (*SelectionModel)(nil)

func ifaceInitSelectionModeller(gifacePtr, data C.gpointer) {
}

func wrapSelectionModel(obj *coreglib.Object) *SelectionModel {
	return &SelectionModel{
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalSelectionModel(p uintptr) (interface{}, error) {
	return wrapSelectionModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *SelectionModel) baseSelectionModel() *SelectionModel {
	return v
}

// BaseSelectionModel returns the underlying base object.
func BaseSelectionModel(obj SelectionModeller) *SelectionModel {
	return obj.baseSelectionModel()
}

// ConnectSelectionChanged is emitted when the selection state of some of the
// items in model changes.
//
// Note that this signal does not specify the new selection state of the items,
// they need to be queried manually. It is also not necessary for a model to
// change the selection state of any of the items in the selection model, though
// it would be rather useless to emit such a signal.
func (v *SelectionModel) ConnectSelectionChanged(f func(position, nItems uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk4_SelectionModel_ConnectSelectionChanged), f)
}

// SelectionModelInterface: list of virtual functions for the SelectionModel
// interface. No function must be implemented, but unless
// SelectionModel::is_selected() is implemented, it will not be possible to
// select items in the set.
//
// The model does not need to implement any functions to support either
// selecting or unselecting items. Of course, if the model does not do that, it
// means that users cannot select or unselect items in a list widget using the
// model.
//
// All selection functions fall back to SelectionModel::set_selection() so it is
// sufficient to implement just that function for full selection support.
//
// An instance of this type is always passed by reference.
type SelectionModelInterface struct {
	*selectionModelInterface
}

// selectionModelInterface is the struct that's finalized.
type selectionModelInterface struct {
	native unsafe.Pointer
}

var GIRInfoSelectionModelInterface = girepository.MustFind("Gtk", "SelectionModelInterface")
