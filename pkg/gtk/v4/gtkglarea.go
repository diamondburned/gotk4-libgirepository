// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void* _gotk4_gtk4_GLArea_ConnectCreateContext(gpointer, guintptr);
// extern void _gotk4_gtk4_GLArea_ConnectResize(gpointer, gint, gint, guintptr);
// extern gboolean _gotk4_gtk4_GLArea_ConnectRender(gpointer, void*, guintptr);
import "C"

// GType values.
var (
	GTypeGLArea = coreglib.Type(girepository.MustFind("Gtk", "GLArea").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLArea, F: marshalGLArea},
	})
}

// GLAreaOverrides contains methods that are overridable.
type GLAreaOverrides struct {
}

func defaultGLAreaOverrides(v *GLArea) GLAreaOverrides {
	return GLAreaOverrides{}
}

// GLArea: GtkGLArea is a widget that allows drawing with OpenGL.
//
// !An example GtkGLArea (glarea.png)
//
// GtkGLArea sets up its own gdk.GLContext, and creates a custom GL framebuffer
// that the widget will do GL rendering onto. It also ensures that this
// framebuffer is the default GL rendering target when rendering.
//
// In order to draw, you have to connect to the gtk.GLArea::render signal, or
// subclass GtkGLArea and override the GtkGLAreaClass.render virtual function.
//
// The GtkGLArea widget ensures that the GdkGLContext is associated with the
// widget's drawing area, and it is kept updated when the size and position of
// the drawing area changes.
//
//
// Drawing with GtkGLArea
//
// The simplest way to draw using OpenGL commands in a GtkGLArea is to create a
// widget instance and connect to the gtk.GLArea::render signal:
//
// The render() function will be called when the GtkGLArea is ready for you to
// draw its content:
//
//    static gboolean
//    render (GtkGLArea *area, GdkGLContext *context)
//    {
//      // inside this function it's safe to use GL; the given
//      // GLContext has been made current to the drawable
//      // surface used by the GtkGLArea and the viewport has
//      // already been set to be the size of the allocation
//
//      // we can start by clearing the buffer
//      glClearColor (0, 0, 0, 0);
//      glClear (GL_COLOR_BUFFER_BIT);
//
//      // draw your object
//      // draw_an_object ();
//
//      // we completed our drawing; the draw commands will be
//      // flushed at the end of the signal emission chain, and
//      // the buffers will be drawn on the window
//      return TRUE;
//    }
//
//    void setup_glarea (void)
//    {
//      // create a GtkGLArea instance
//      GtkWidget *gl_area = gtk_gl_area_new ();
//
//      // connect to the "render" signal
//      g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
//    }
//
//
// If you need to initialize OpenGL state, e.g. buffer objects or shaders, you
// should use the gtk.Widget::realize signal; you can use the
// gtk.Widget::unrealize signal to clean up. Since the GdkGLContext creation and
// initialization may fail, you will need to check for errors, using
// gtk.GLArea.GetError().
//
// An example of how to safely initialize the GL state is:
//
//    static void
//    on_realize (GtkGLarea *area)
//    {
//      // We need to make the context current if we want to
//      // call GL API
//      gtk_gl_area_make_current (area);
//
//      // If there were errors during the initialization or
//      // when trying to make the context current, this
//      // function will return a #GError for you to catch
//      if (gtk_gl_area_get_error (area) != NULL)
//        return;
//
//      // You can also use gtk_gl_area_set_error() in order
//      // to show eventual initialization errors on the
//      // GtkGLArea widget itself
//      GError *internal_error = NULL;
//      init_buffer_objects (&error);
//      if (error != NULL)
//        {
//          gtk_gl_area_set_error (area, error);
//          g_error_free (error);
//          return;
//        }
//
//      init_shaders (&error);
//      if (error != NULL)
//        {
//          gtk_gl_area_set_error (area, error);
//          g_error_free (error);
//          return;
//        }
//    }
//
//
// If you need to change the options for creating the GdkGLContext you should
// use the gtk.GLArea::create-context signal.
type GLArea struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*GLArea)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLArea, *GLAreaClass, GLAreaOverrides](
		GTypeGLArea,
		initGLAreaClass,
		wrapGLArea,
		defaultGLAreaOverrides,
	)
}

func initGLAreaClass(gclass unsafe.Pointer, overrides GLAreaOverrides, classInitFunc func(*GLAreaClass)) {
	if classInitFunc != nil {
		class := (*GLAreaClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLArea(obj *coreglib.Object) *GLArea {
	return &GLArea{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalGLArea(p uintptr) (interface{}, error) {
	return wrapGLArea(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateContext is emitted when the widget is being realized.
//
// This allows you to override how the GL context is created. This is useful
// when you want to reuse an existing GL context, or if you want to try creating
// different kinds of GL options.
//
// If context creation fails then the signal handler can use
// gtk.GLArea.SetError() to register a more detailed error of how the
// construction failed.
func (v *GLArea) ConnectCreateContext(f func() (glContext gdk.GLContexter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "create-context", false, unsafe.Pointer(C._gotk4_gtk4_GLArea_ConnectCreateContext), f)
}

// ConnectRender is emitted every time the contents of the GtkGLArea should be
// redrawn.
//
// The context is bound to the area prior to emitting this function, and the
// buffers are painted to the window once the emission terminates.
func (v *GLArea) ConnectRender(f func(context gdk.GLContexter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "render", false, unsafe.Pointer(C._gotk4_gtk4_GLArea_ConnectRender), f)
}

// ConnectResize is emitted once when the widget is realized, and then each time
// the widget is changed while realized.
//
// This is useful in order to keep GL state up to date with the widget size,
// like for instance camera properties which may depend on the width/height
// ratio.
//
// The GL context for the area is guaranteed to be current when this signal is
// emitted.
//
// The default handler sets up the GL viewport.
func (v *GLArea) ConnectResize(f func(width, height int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "resize", false, unsafe.Pointer(C._gotk4_gtk4_GLArea_ConnectResize), f)
}

// GLAreaClass: GtkGLAreaClass structure contains only private data.
//
// An instance of this type is always passed by reference.
type GLAreaClass struct {
	*glAreaClass
}

// glAreaClass is the struct that's finalized.
type glAreaClass struct {
	native unsafe.Pointer
}

var GIRInfoGLAreaClass = girepository.MustFind("Gtk", "GLAreaClass")
