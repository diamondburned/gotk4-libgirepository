// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeApplicationWindow = coreglib.Type(girepository.MustFind("Gtk", "ApplicationWindow").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeApplicationWindow, F: marshalApplicationWindow},
	})
}

// ApplicationWindowOverrides contains methods that are overridable.
type ApplicationWindowOverrides struct {
}

func defaultApplicationWindowOverrides(v *ApplicationWindow) ApplicationWindowOverrides {
	return ApplicationWindowOverrides{}
}

// ApplicationWindow: GtkApplicationWindow is a GtkWindow subclass that
// integrates with GtkApplication.
//
// Notably, GtkApplicationWindow can handle an application menubar.
//
// This class implements the GActionGroup and GActionMap interfaces, to let you
// add window-specific actions that will be exported by the associated
// gtk.Application, together with its application-wide actions. Window-specific
// actions are prefixed with the “win.” prefix and application-wide actions are
// prefixed with the “app.” prefix. Actions must be addressed with the prefixed
// name when referring to them from a GMenuModel.
//
// Note that widgets that are placed inside a GtkApplicationWindow can also
// activate these actions, if they implement the gtk.Actionable interface.
//
// The settings gtk.Settings:gtk-shell-shows-app-menu and
// gtk.Settings:gtk-shell-shows-menubar tell GTK whether the desktop environment
// is showing the application menu and menubar models outside the application as
// part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be.
//
// If the desktop environment does not display the menubar, then
// GtkApplicationWindow will automatically show a menubar for it. This behaviour
// can be overridden with the gtk.ApplicationWindow:show-menubar property. If
// the desktop environment does not display the application menu, then it will
// automatically be included in the menubar or in the windows client-side
// decorations.
//
// See gtk.PopoverMenu for information about the XML language used by GtkBuilder
// for menu models.
//
// See also: gtk.Application.SetMenubar().
//
//
// A GtkApplicationWindow with a menubar
//
// The code sample below shows how to set up a GtkApplicationWindow with a menu
// bar defined on the gtk.Application:
//
//    GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
//    GtkBuilder *builder = gtk_builder_new_from_string (
//        "<interface>"
//        "  <menu id='menubar'>"
//        "    <submenu>"
//        "      <attribute name='label' translatable='yes'>_Edit</attribute>"
//        "      <item>"
//        "        <attribute name='label' translatable='yes'>_Copy</attribute>"
//        "        <attribute name='action'>win.copy</attribute>"
//        "      </item>"
//        "      <item>"
//        "        <attribute name='label' translatable='yes'>_Paste</attribute>"
//        "        <attribute name='action'>win.paste</attribute>"
//        "      </item>"
//        "    </submenu>"
//        "  </menu>"
//        "</interface>",
//        -1);
//
//    GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder, "menubar"));
//    gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//    g_object_unref (builder);
//
//    // ...
//
//    GtkWidget *window = gtk_application_window_new (app);.
type ApplicationWindow struct {
	_ [0]func() // equal guard
	Window

	*coreglib.Object
	gio.ActionGroup
	gio.ActionMap
}

var (
	_ coreglib.Objector = (*ApplicationWindow)(nil)
	_ Widgetter         = (*ApplicationWindow)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ApplicationWindow, *ApplicationWindowClass, ApplicationWindowOverrides](
		GTypeApplicationWindow,
		initApplicationWindowClass,
		wrapApplicationWindow,
		defaultApplicationWindowOverrides,
	)
}

func initApplicationWindowClass(gclass unsafe.Pointer, overrides ApplicationWindowOverrides, classInitFunc func(*ApplicationWindowClass)) {
	if classInitFunc != nil {
		class := (*ApplicationWindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplicationWindow(obj *coreglib.Object) *ApplicationWindow {
	return &ApplicationWindow{
		Window: Window{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Root: Root{
				NativeSurface: NativeSurface{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: Accessible{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
						ConstraintTarget: ConstraintTarget{
							Object: obj,
						},
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
		Object: obj,
		ActionGroup: gio.ActionGroup{
			Object: obj,
		},
		ActionMap: gio.ActionMap{
			Object: obj,
		},
	}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	return wrapApplicationWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ApplicationWindowClass: instance of this type is always passed by reference.
type ApplicationWindowClass struct {
	*applicationWindowClass
}

// applicationWindowClass is the struct that's finalized.
type applicationWindowClass struct {
	native unsafe.Pointer
}

var GIRInfoApplicationWindowClass = girepository.MustFind("Gtk", "ApplicationWindowClass")
