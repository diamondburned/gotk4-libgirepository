// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeMenuButton = coreglib.Type(girepository.MustFind("Gtk", "MenuButton").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMenuButton, F: marshalMenuButton},
	})
}

// MenuButtonCreatePopupFunc: user-provided callback function to create a popup
// for a GtkMenuButton on demand.
//
// This function is called when the popup of menu_button is shown, but none has
// been provided via gtk.MenuButton.SetPopover() or
// gtk.MenuButton.SetMenuModel().
type MenuButtonCreatePopupFunc func(menuButton *MenuButton)

// MenuButton: GtkMenuButton widget is used to display a popup when clicked.
//
// !An example GtkMenuButton (menu-button.png)
//
// This popup can be provided either as a GtkPopover or as an abstract
// GMenuModel.
//
// The GtkMenuButton widget can show either an icon (set with the
// gtk.MenuButton:icon-name property) or a label (set with the
// gtk.MenuButton:label property). If neither is explicitly set, a gtk.Image is
// automatically created, using an arrow image oriented according to
// gtk.MenuButton:direction or the generic “open-menu-symbolic” icon if the
// direction is not set.
//
// The positioning of the popup is determined by the gtk.MenuButton:direction
// property of the menu button.
//
// For menus, the gtk.Widget:halign and gtk.Widget:valign properties of the menu
// are also taken into account. For example, when the direction is
// GTK_ARROW_DOWN and the horizontal alignment is GTK_ALIGN_START, the menu will
// be positioned below the button, with the starting edge (depending on the text
// direction) of the menu aligned with the starting edge of the button. If there
// is not enough space below the button, the menu is popped up above the button
// instead. If the alignment would move part of the menu offscreen, it is
// “pushed in”.
//
// | | start | center | end | | - | --- | --- | --- | | **down** | !
// (down-start.png) | ! (down-center.png) | ! (down-end.png) | | **up** | !
// (up-start.png) | ! (up-center.png) | ! (up-end.png) | | **left** | !
// (left-start.png) | ! (left-center.png) | ! (left-end.png) | | **right** | !
// (right-start.png) | ! (right-center.png) | ! (right-end.png) |
//
// CSS nodes
//
//    menubutton
//    ╰── button.toggle
//        ╰── <content>
//             ╰── [arrow]
//
//
// GtkMenuButton has a single CSS node with name menubutton which contains a
// button node with a .toggle style class.
//
// Inside the toggle button content, there is an arrow node for the indicator,
// which will carry one of the .none, .up, .down, .left or .right style classes
// to indicate the direction that the menu will appear in. The CSS is expected
// to provide a suitable image for each of these cases using the
// -gtk-icon-source property.
//
// Optionally, the menubutton node can carry the .circular style class to
// request a round appearance.
//
//
// Accessibility
//
// GtkMenuButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*MenuButton)(nil)
)

func wrapMenuButton(obj *coreglib.Object) *MenuButton {
	return &MenuButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	return wrapMenuButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
