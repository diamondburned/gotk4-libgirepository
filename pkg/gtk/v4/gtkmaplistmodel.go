// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeMapListModel = coreglib.Type(girepository.MustFind("Gtk", "MapListModel").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMapListModel, F: marshalMapListModel},
	})
}

// MapListModelMapFunc: user function that is called to map an item of the
// original model to an item expected by the map model.
//
// The returned items must conform to the item type of the model they are used
// with.
type MapListModelMapFunc func(item *coreglib.Object) (object *coreglib.Object)

// MapListModelOverrides contains methods that are overridable.
type MapListModelOverrides struct {
}

func defaultMapListModelOverrides(v *MapListModel) MapListModelOverrides {
	return MapListModelOverrides{}
}

// MapListModel: GtkMapListModel maps the items in a list model to different
// items.
//
// GtkMapListModel uses a gtk.MapListModelMapFunc.
//
// Example: Create a list of GtkEventControllers
//
//    static gpointer
//    map_to_controllers (gpointer widget,
//                        gpointer data)
//    {
//      gpointer result = gtk_widget_observe_controllers (widget);
//      g_object_unref (widget);
//      return result;
//    }
//
//    widgets = gtk_widget_observe_children (widget);
//
//    controllers = gtk_map_list_model_new (G_TYPE_LIST_MODEL,
//                                          widgets,
//                                          map_to_controllers,
//                                          NULL, NULL);
//
//    model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER,
//                                        controllers);
//
//
// GtkMapListModel will attempt to discard the mapped objects as soon as they
// are no longer needed and recreate them if necessary.
type MapListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*MapListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MapListModel, *MapListModelClass, MapListModelOverrides](
		GTypeMapListModel,
		initMapListModelClass,
		wrapMapListModel,
		defaultMapListModelOverrides,
	)
}

func initMapListModelClass(gclass unsafe.Pointer, overrides MapListModelOverrides, classInitFunc func(*MapListModelClass)) {
	if classInitFunc != nil {
		class := (*MapListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMapListModel(obj *coreglib.Object) *MapListModel {
	return &MapListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalMapListModel(p uintptr) (interface{}, error) {
	return wrapMapListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// MapListModelClass: instance of this type is always passed by reference.
type MapListModelClass struct {
	*mapListModelClass
}

// mapListModelClass is the struct that's finalized.
type mapListModelClass struct {
	native unsafe.Pointer
}

var GIRInfoMapListModelClass = girepository.MustFind("Gtk", "MapListModelClass")
