// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeConstraintTarget = coreglib.Type(girepository.MustFind("Gtk", "ConstraintTarget").RegisteredGType())
	GTypeConstraint       = coreglib.Type(girepository.MustFind("Gtk", "Constraint").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeConstraintTarget, F: marshalConstraintTarget},
		coreglib.TypeMarshaler{T: GTypeConstraint, F: marshalConstraint},
	})
}

// ConstraintTarget: GtkConstraintTarget interface is implemented by objects
// that can be used as source or target in GtkConstraints.
//
// Besides GtkWidget, it is also implemented by GtkConstraintGuide.
//
// ConstraintTarget wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ConstraintTarget struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ConstraintTarget)(nil)
)

// ConstraintTargetter describes ConstraintTarget's interface methods.
type ConstraintTargetter interface {
	coreglib.Objector

	baseConstraintTarget() *ConstraintTarget
}

var _ ConstraintTargetter = (*ConstraintTarget)(nil)

func wrapConstraintTarget(obj *coreglib.Object) *ConstraintTarget {
	return &ConstraintTarget{
		Object: obj,
	}
}

func marshalConstraintTarget(p uintptr) (interface{}, error) {
	return wrapConstraintTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ConstraintTarget) baseConstraintTarget() *ConstraintTarget {
	return v
}

// BaseConstraintTarget returns the underlying base object.
func BaseConstraintTarget(obj ConstraintTargetter) *ConstraintTarget {
	return obj.baseConstraintTarget()
}

// ConstraintOverrides contains methods that are overridable.
type ConstraintOverrides struct {
}

func defaultConstraintOverrides(v *Constraint) ConstraintOverrides {
	return ConstraintOverrides{}
}

// Constraint: GtkConstraint describes a constraint between attributes of two
// widgets, expressed as a linear equation.
//
// The typical equation for a constraint is:
//
//      target.target_attr = source.source_attr Ã— multiplier + constant
//
//
// Each GtkConstraint is part of a system that will be solved by a
// gtk.ConstraintLayout in order to allocate and position each child widget or
// guide.
//
// The source and target, as well as their attributes, of a GtkConstraint
// instance are immutable after creation.
type Constraint struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Constraint)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Constraint, *ConstraintClass, ConstraintOverrides](
		GTypeConstraint,
		initConstraintClass,
		wrapConstraint,
		defaultConstraintOverrides,
	)
}

func initConstraintClass(gclass unsafe.Pointer, overrides ConstraintOverrides, classInitFunc func(*ConstraintClass)) {
	if classInitFunc != nil {
		class := (*ConstraintClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraint(obj *coreglib.Object) *Constraint {
	return &Constraint{
		Object: obj,
	}
}

func marshalConstraint(p uintptr) (interface{}, error) {
	return wrapConstraint(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConstraintClass: instance of this type is always passed by reference.
type ConstraintClass struct {
	*constraintClass
}

// constraintClass is the struct that's finalized.
type constraintClass struct {
	native unsafe.Pointer
}

var GIRInfoConstraintClass = girepository.MustFind("Gtk", "ConstraintClass")
