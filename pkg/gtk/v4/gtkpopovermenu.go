// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypePopoverMenuFlags = coreglib.Type(girepository.MustFind("Gtk", "PopoverMenuFlags").RegisteredGType())
	GTypePopoverMenu      = coreglib.Type(girepository.MustFind("Gtk", "PopoverMenu").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePopoverMenuFlags, F: marshalPopoverMenuFlags},
		coreglib.TypeMarshaler{T: GTypePopoverMenu, F: marshalPopoverMenu},
	})
}

// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags C.guint

const (
	// PopoverMenuNested: create submenus as nested popovers. Without this flag,
	// submenus are created as sliding pages that replace the main menu.
	PopoverMenuNested PopoverMenuFlags = 0b1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PopoverMenuFlags.
func (p PopoverMenuFlags) String() string {
	if p == 0 {
		return "PopoverMenuFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(17)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PopoverMenuNested:
			builder.WriteString("Nested|")
		default:
			builder.WriteString(fmt.Sprintf("PopoverMenuFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PopoverMenuFlags) Has(other PopoverMenuFlags) bool {
	return (p & other) == other
}

// PopoverMenu: GtkPopoverMenu is a subclass of GtkPopover that implements menu
// behavior.
//
// !An example GtkPopoverMenu (menu.png)
//
// GtkPopoverMenu treats its children like menus and allows switching between
// them. It can open submenus as traditional, nested submenus, or in a more
// touch-friendly sliding fashion.
//
// GtkPopoverMenu is meant to be used primarily with menu models, using
// gtk.PopoverMenu.NewFromModel. If you need to put other widgets such as a
// GtkSpinButton or a GtkSwitch into a popover, you can use
// gtk.PopoverMenu.AddChild().
//
// For more dialog-like behavior, use a plain GtkPopover.
//
//
// Menu models
//
// The XML format understood by GtkBuilder for GMenuModel consists of a toplevel
// <menu> element, which contains one or more <item> elements. Each <item>
// element contains <attribute> and <link> elements with a mandatory name
// attribute. <link> elements have the same content model as <menu>. Instead of
// <link name="submenu> or <link name="section">, you can use <submenu> or
// <section> elements.
//
//    <menu id='app-menu'>
//      <section>
//        <item>
//          <attribute name='label' translatable='yes'>_New Window</attribute>
//          <attribute name='action'>app.new</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_About Sunny</attribute>
//          <attribute name='action'>app.about</attribute>
//        </item>
//        <item>
//          <attribute name='label' translatable='yes'>_Quit</attribute>
//          <attribute name='action'>app.quit</attribute>
//        </item>
//      </section>
//    </menu>
//
//
// Attribute values can be translated using gettext, like other GtkBuilder
// content. <attribute> elements can be marked for translation with a
// translatable="yes" attribute. It is also possible to specify message context
// and translator comments, using the context and comments attributes. To make
// use of this, the Builder must have been given the gettext domain to use.
//
// The following attributes are used when constructing menu items:
//
// - "label": a user-visible string to display
//
// - "action": the prefixed name of the action to trigger
//
// - "target": the parameter to use when activating the action
//
// - "icon" and "verb-icon": names of icons that may be displayed
//
// - "submenu-action": name of an action that may be used to determine if a
// submenu can be opened
//
// - "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
// This is mainly useful for exported menus, see gtk.Application.SetMenubar().
//
// - "custom": a string used to match against the ID of a custom child added
// with gtk.PopoverMenu.AddChild(), gtk.PopoverMenuBar.AddChild(), or in the ui
// file with <child type="ID">.
//
// The following attributes are used when constructing sections:
//
// - "label": a user-visible string to use as section heading
//
// - "display-hint": a string used to determine special formatting for the
// section. Possible values include "horizontal-buttons", "circular-buttons" and
// "inline-buttons". They all indicate that section should be displayed as a
// horizontal row of buttons.
//
// - "text-direction": a string used to determine the GtkTextDirection to use
// when "display-hint" is set to "horizontal-buttons". Possible values include
// "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus:
//
// - "label": a user-visible string to display
//
// - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually associated with
// actions via gtk.Application.SetAccelsForAction(),
// gtk_widget_class_add_binding_action or gtk.ShortcutController.AddShortcut().
//
//
// CSS Nodes
//
// GtkPopoverMenu is just a subclass of GtkPopover that adds custom content to
// it, therefore it has the same CSS nodes. It is one of the cases that add a
// .menu style class to the popover's main node.
//
//
// Accessibility
//
// GtkPopoverMenu uses the GTK_ACCESSIBLE_ROLE_MENU role, and its items use the
// GTK_ACCESSIBLE_ROLE_MENU_ITEM, GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu struct {
	_ [0]func() // equal guard
	Popover
}

var (
	_ Widgetter         = (*PopoverMenu)(nil)
	_ coreglib.Objector = (*PopoverMenu)(nil)
)

func wrapPopoverMenu(obj *coreglib.Object) *PopoverMenu {
	return &PopoverMenu{
		Popover: Popover{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			NativeSurface: NativeSurface{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	return wrapPopoverMenu(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
