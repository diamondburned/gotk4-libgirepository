// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeCClosureExpression = coreglib.Type(girepository.MustFind("Gtk", "CClosureExpression").RegisteredGType())
	GTypeClosureExpression  = coreglib.Type(girepository.MustFind("Gtk", "ClosureExpression").RegisteredGType())
	GTypeConstantExpression = coreglib.Type(girepository.MustFind("Gtk", "ConstantExpression").RegisteredGType())
	GTypeExpression         = coreglib.Type(girepository.MustFind("Gtk", "Expression").RegisteredGType())
	GTypeObjectExpression   = coreglib.Type(girepository.MustFind("Gtk", "ObjectExpression").RegisteredGType())
	GTypePropertyExpression = coreglib.Type(girepository.MustFind("Gtk", "PropertyExpression").RegisteredGType())
	GTypeExpressionWatch    = coreglib.Type(girepository.MustFind("Gtk", "ExpressionWatch").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCClosureExpression, F: marshalCClosureExpression},
		coreglib.TypeMarshaler{T: GTypeClosureExpression, F: marshalClosureExpression},
		coreglib.TypeMarshaler{T: GTypeConstantExpression, F: marshalConstantExpression},
		coreglib.TypeMarshaler{T: GTypeExpression, F: marshalExpression},
		coreglib.TypeMarshaler{T: GTypeObjectExpression, F: marshalObjectExpression},
		coreglib.TypeMarshaler{T: GTypePropertyExpression, F: marshalPropertyExpression},
		coreglib.TypeMarshaler{T: GTypeExpressionWatch, F: marshalExpressionWatch},
	})
}

// ExpressionNotify: callback called by gtk_expression_watch() when the
// expression value changes.
type ExpressionNotify func()

// CClosureExpression: variant of GtkClosureExpression using a C closure.
type CClosureExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*CClosureExpression)(nil)
)

func wrapCClosureExpression(obj *coreglib.Object) *CClosureExpression {
	return &CClosureExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalCClosureExpression(p uintptr) (interface{}, error) {
	return wrapCClosureExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ClosureExpression: expression using a custom GClosure to compute the value
// from its parameters.
type ClosureExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*ClosureExpression)(nil)
)

func wrapClosureExpression(obj *coreglib.Object) *ClosureExpression {
	return &ClosureExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalClosureExpression(p uintptr) (interface{}, error) {
	return wrapClosureExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConstantExpression: constant value in a GtkExpression.
type ConstantExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*ConstantExpression)(nil)
)

func wrapConstantExpression(obj *coreglib.Object) *ConstantExpression {
	return &ConstantExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalConstantExpression(p uintptr) (interface{}, error) {
	return wrapConstantExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Expression: GtkExpression provides a way to describe references to values.
//
// An important aspect of expressions is that the value can be obtained from a
// source that is several steps away. For example, an expression may describe
// ‘the value of property A of object1, which is itself the value of a property
// of object2’. And object1 may not even exist yet at the time that the
// expression is created. This is contrast to GObject property bindings, which
// can only create direct connections between the properties of two objects that
// must both exist for the duration of the binding.
//
// An expression needs to be "evaluated" to obtain the value that it currently
// refers to. An evaluation always happens in the context of a current object
// called this (it mirrors the behavior of object-oriented languages), which may
// or may not influence the result of the evaluation. Use
// gtk.Expression.Evaluate() for evaluating an expression.
//
// Various methods for defining expressions exist, from simple constants via
// gtk.ConstantExpression.New to looking up properties in a GObject (even
// recursively) via gtk.PropertyExpression.New or providing custom functions to
// transform and combine expressions via gtk.ClosureExpression.New.
//
// Here is an example of a complex expression:
//
//      color_expr = gtk_property_expression_new (GTK_TYPE_LIST_ITEM,
//                                                NULL, "item");
//      expression = gtk_property_expression_new (GTK_TYPE_COLOR,
//                                                color_expr, "name");
//
//
// when evaluated with this being a GtkListItem, it will obtain the "item"
// property from the GtkListItem, and then obtain the "name" property from the
// resulting object (which is assumed to be of type GTK_TYPE_COLOR).
//
// A more concise way to describe this would be
//
//      this->item->name
//
//
// The most likely place where you will encounter expressions is in the context
// of list models and list widgets using them. For example, GtkDropDown is
// evaluating a GtkExpression to obtain strings from the items in its model that
// it can then use to match against the contents of its search entry.
// GtkStringFilter is using a GtkExpression for similar reasons.
//
// By default, expressions are not paying attention to changes and evaluation is
// just a snapshot of the current state at a given time. To get informed about
// changes, an expression needs to be "watched" via a gtk.ExpressionWatch, which
// will cause a callback to be called whenever the value of the expression may
// have changed; gtk.Expression.Watch() starts watching an expression, and
// gtk.ExpressionWatch.Unwatch() stops.
//
// Watches can be created for automatically updating the property of an object,
// similar to GObject's GBinding mechanism, by using gtk.Expression.Bind().
//
//
// GtkExpression in GObject properties
//
// In order to use a GtkExpression as a GObject property, you must use the
// gtk_param_spec_expression when creating a GParamSpec to install in the
// GObject class being defined; for instance:
//
//    obj_props[PROP_EXPRESSION] =
//      gtk_param_spec_expression ("expression",
//                                 "Expression",
//                                 "The expression used by the widget",
//                                 G_PARAM_READWRITE |
//                                 G_PARAM_STATIC_STRINGS |
//                                 G_PARAM_EXPLICIT_NOTIFY);
//
//
// When implementing the GObjectClass.set_property and GObjectClass.get_property
// virtual functions, you must use gtk_value_get_expression, to retrieve the
// stored GtkExpression from the GValue container, and gtk_value_set_expression,
// to store the GtkExpression into the GValue; for instance:
//
//      // in set_property()...
//      case PROP_EXPRESSION:
//        foo_widget_set_expression (foo, gtk_value_get_expression (value));
//        break;
//
//      // in get_property()...
//      case PROP_EXPRESSION:
//        gtk_value_set_expression (value, foo->expression);
//        break;
//
//
//
// GtkExpression in .ui files
//
// GtkBuilder has support for creating expressions. The syntax here can be used
// where a GtkExpression object is needed like in a <property> tag for an
// expression property, or in a <binding> tag to bind a property to an
// expression.
//
// To create an property expression, use the <lookup> element. It can have a
// type attribute to specify the object type, and a name attribute to specify
// the property to look up. The content of <lookup> can either be an element
// specfiying the expression to use the object, or a string that specifies the
// name of the object to use.
//
// Example:
//
//      <lookup name='search'>string_filter</lookup>
//
//
// To create a constant expression, use the <constant> element. If the type
// attribute is specified, the element content is interpreted as a value of that
// type. Otherwise, it is assumed to be an object. For instance:
//
//      <constant>string_filter</constant>
//      <constant type='gchararray'>Hello, world</constant>
//
//
// To create a closure expression, use the <closure> element. The type and
// function attributes specify what function to use for the closure, the content
// of the element contains the expressions for the parameters. For instance:
//
//    <closure type='gchararray' function='combine_args_somehow'>
//      <constant type='gchararray'>File size:</constant>
//      <lookup type='GFile' name='size'>myfile</lookup>
//    </closure>.
type Expression struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Expression)(nil)
)

// Expressioner describes types inherited from class Expression.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Expressioner interface {
	coreglib.Objector
	baseExpression() *Expression
}

var _ Expressioner = (*Expression)(nil)

func wrapExpression(obj *coreglib.Object) *Expression {
	return &Expression{
		Object: obj,
	}
}

func marshalExpression(p uintptr) (interface{}, error) {
	return wrapExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Expression) baseExpression() *Expression {
	return v
}

// BaseExpression returns the underlying base object.
func BaseExpression(obj Expressioner) *Expression {
	return obj.baseExpression()
}

// ObjectExpression: GObject value in a GtkExpression.
type ObjectExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*ObjectExpression)(nil)
)

func wrapObjectExpression(obj *coreglib.Object) *ObjectExpression {
	return &ObjectExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalObjectExpression(p uintptr) (interface{}, error) {
	return wrapObjectExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// PropertyExpression: GObject property value in a GtkExpression.
type PropertyExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*PropertyExpression)(nil)
)

func wrapPropertyExpression(obj *coreglib.Object) *PropertyExpression {
	return &PropertyExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalPropertyExpression(p uintptr) (interface{}, error) {
	return wrapPropertyExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ExpressionWatch: opaque structure representing a watched GtkExpression.
//
// The contents of GtkExpressionWatch should only be accessed through the
// provided API.
//
// An instance of this type is always passed by reference.
type ExpressionWatch struct {
	*expressionWatch
}

// expressionWatch is the struct that's finalized.
type expressionWatch struct {
	native unsafe.Pointer
}

var GIRInfoExpressionWatch = girepository.MustFind("Gtk", "ExpressionWatch")

func marshalExpressionWatch(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ExpressionWatch{&expressionWatch{(unsafe.Pointer)(b)}}, nil
}
