// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void* _gotk4_gtk4_Notebook_ConnectCreateWindow(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectSwitchPage(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectPageReordered(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectPageRemoved(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectPageAdded(gpointer, void*, guint, guintptr);
// extern gboolean _gotk4_gtk4_Notebook_ConnectSelectPage(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Notebook_ConnectChangeCurrentPage(gpointer, gint, guintptr);
import "C"

// GType values.
var (
	GTypeNotebookTab  = coreglib.Type(girepository.MustFind("Gtk", "NotebookTab").RegisteredGType())
	GTypeNotebook     = coreglib.Type(girepository.MustFind("Gtk", "Notebook").RegisteredGType())
	GTypeNotebookPage = coreglib.Type(girepository.MustFind("Gtk", "NotebookPage").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNotebookTab, F: marshalNotebookTab},
		coreglib.TypeMarshaler{T: GTypeNotebook, F: marshalNotebook},
		coreglib.TypeMarshaler{T: GTypeNotebookPage, F: marshalNotebookPage},
	})
}

// NotebookTab: parameter used in the action signals of GtkNotebook.
type NotebookTab C.gint

const (
	// NotebookTabFirst: first tab in the notebook.
	NotebookTabFirst NotebookTab = iota
	// NotebookTabLast: last tab in the notebook.
	NotebookTabLast
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotebookTab.
func (n NotebookTab) String() string {
	switch n {
	case NotebookTabFirst:
		return "First"
	case NotebookTabLast:
		return "Last"
	default:
		return fmt.Sprintf("NotebookTab(%d)", n)
	}
}

// Notebook: GtkNotebook is a container whose children are pages switched
// between using tabs.
//
// !An example GtkNotebook (notebook.png)
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk.Notebook.SetTabPos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk.Notebook.SetScrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk.Notebook.PopupEnable()).
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the GtkBuildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//
//
// CSS nodes
//
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
//
// GtkNotebook has a main CSS node with name notebook, a subnode with name
// header and below that a subnode with name tabs which contains one subnode per
// tab with name tab.
//
// If action widgets are present, their CSS nodes are placed next to the tabs
// node. If the notebook is scrollable, CSS nodes with name arrow are placed as
// first and last child of the tabs node.
//
// The main node gets the .frame style class when the notebook has a border (see
// gtk.Notebook.SetShowBorder()).
//
// The header node gets one of the style class .top, .bottom, .left or .right,
// depending on where the tabs are placed. For reorderable pages, the tab node
// gets the .reorderable-page class.
//
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
//
// Accessibility
//
// GtkNotebook uses the following roles:
//
//    - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//    - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//    - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//    - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page.
type Notebook struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Notebook)(nil)
)

func wrapNotebook(obj *coreglib.Object) *Notebook {
	return &Notebook{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	return wrapNotebook(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Notebook) ConnectChangeCurrentPage(f func(object int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "change-current-page", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectChangeCurrentPage), f)
}

// ConnectCreateWindow signal is emitted when a detachable tab is dropped on the
// root window.
//
// A handler for this signal can create a window containing a notebook where the
// tab will be attached. It is also responsible for moving/resizing the window
// and adding the necessary properties to the notebook (e.g. the
// GtkNotebook:group-name ).
func (v *Notebook) ConnectCreateWindow(f func(page Widgetter) (notebook *Notebook)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "create-window", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectCreateWindow), f)
}

// ConnectPageAdded signal is emitted in the notebook right after a page is
// added to the notebook.
func (v *Notebook) ConnectPageAdded(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-added", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectPageAdded), f)
}

// ConnectPageRemoved signal is emitted in the notebook right after a page is
// removed from the notebook.
func (v *Notebook) ConnectPageRemoved(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-removed", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectPageRemoved), f)
}

// ConnectPageReordered signal is emitted in the notebook right after a page has
// been reordered.
func (v *Notebook) ConnectPageReordered(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-reordered", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectPageReordered), f)
}

func (v *Notebook) ConnectSelectPage(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select-page", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectSelectPage), f)
}

// ConnectSwitchPage is emitted when the user or a function changes the current
// page.
func (v *Notebook) ConnectSwitchPage(f func(page Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "switch-page", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectSwitchPage), f)
}

// NotebookPage: GtkNotebookPage is an auxiliary object used by GtkNotebook.
type NotebookPage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*NotebookPage)(nil)
)

func wrapNotebookPage(obj *coreglib.Object) *NotebookPage {
	return &NotebookPage{
		Object: obj,
	}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	return wrapNotebookPage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
