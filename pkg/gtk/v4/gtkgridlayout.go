// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeGridLayout      = coreglib.Type(girepository.MustFind("Gtk", "GridLayout").RegisteredGType())
	GTypeGridLayoutChild = coreglib.Type(girepository.MustFind("Gtk", "GridLayoutChild").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGridLayout, F: marshalGridLayout},
		coreglib.TypeMarshaler{T: GTypeGridLayoutChild, F: marshalGridLayoutChild},
	})
}

// GridLayoutOverrides contains methods that are overridable.
type GridLayoutOverrides struct {
}

func defaultGridLayoutOverrides(v *GridLayout) GridLayoutOverrides {
	return GridLayoutOverrides{}
}

// GridLayout: GtkGridLayout is a layout manager which arranges child widgets in
// rows and columns.
//
// Children have an "attach point" defined by the horizontal and vertical index
// of the cell they occupy; children can span multiple rows or columns. The
// layout properties for setting the attach points and spans are set using the
// gtk.GridLayoutChild associated to each child widget.
//
// The behaviour of GtkGridLayout when several children occupy the same grid
// cell is undefined.
//
// GtkGridLayout can be used like a GtkBoxLayout if all children are attached to
// the same row or column; however, if you only ever need a single row or
// column, you should consider using GtkBoxLayout.
type GridLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*GridLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GridLayout, *GridLayoutClass, GridLayoutOverrides](
		GTypeGridLayout,
		initGridLayoutClass,
		wrapGridLayout,
		defaultGridLayoutOverrides,
	)
}

func initGridLayoutClass(gclass unsafe.Pointer, overrides GridLayoutOverrides, classInitFunc func(*GridLayoutClass)) {
	if classInitFunc != nil {
		class := (*GridLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGridLayout(obj *coreglib.Object) *GridLayout {
	return &GridLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalGridLayout(p uintptr) (interface{}, error) {
	return wrapGridLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GridLayoutChildOverrides contains methods that are overridable.
type GridLayoutChildOverrides struct {
}

func defaultGridLayoutChildOverrides(v *GridLayoutChild) GridLayoutChildOverrides {
	return GridLayoutChildOverrides{}
}

// GridLayoutChild: GtkLayoutChild subclass for children in a GtkGridLayout.
type GridLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*GridLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GridLayoutChild, *GridLayoutChildClass, GridLayoutChildOverrides](
		GTypeGridLayoutChild,
		initGridLayoutChildClass,
		wrapGridLayoutChild,
		defaultGridLayoutChildOverrides,
	)
}

func initGridLayoutChildClass(gclass unsafe.Pointer, overrides GridLayoutChildOverrides, classInitFunc func(*GridLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*GridLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGridLayoutChild(obj *coreglib.Object) *GridLayoutChild {
	return &GridLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalGridLayoutChild(p uintptr) (interface{}, error) {
	return wrapGridLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GridLayoutChildClass: instance of this type is always passed by reference.
type GridLayoutChildClass struct {
	*gridLayoutChildClass
}

// gridLayoutChildClass is the struct that's finalized.
type gridLayoutChildClass struct {
	native unsafe.Pointer
}

var GIRInfoGridLayoutChildClass = girepository.MustFind("Gtk", "GridLayoutChildClass")

// GridLayoutClass: instance of this type is always passed by reference.
type GridLayoutClass struct {
	*gridLayoutClass
}

// gridLayoutClass is the struct that's finalized.
type gridLayoutClass struct {
	native unsafe.Pointer
}

var GIRInfoGridLayoutClass = girepository.MustFind("Gtk", "GridLayoutClass")
