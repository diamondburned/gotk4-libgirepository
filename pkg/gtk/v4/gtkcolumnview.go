// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_ColumnView_ConnectActivate(gpointer, guint, guintptr);
import "C"

// GType values.
var (
	GTypeColumnView = coreglib.Type(girepository.MustFind("Gtk", "ColumnView").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeColumnView, F: marshalColumnView},
	})
}

// ColumnView: GtkColumnView presents a large dynamic list of items using
// multiple columns with headers.
//
// GtkColumnView uses the factories of its columns to generate a cell widget for
// each column, for each visible item and displays them together as the row for
// this item.
//
// The gtk.ColumnView:show-row-separators and
// [propertyGtk.ColumnView:show-column-separators] properties offer a simple way
// to display separators between the rows or columns.
//
// GtkColumnView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on *rubberband selection*, using
// gtk.ColumnView:enable-rubberband.
//
// The column view supports sorting that can be customized by the user by
// clicking on column headers. To set this up, the GtkSorter returned by
// gtk.ColumnView.GetSorter() must be attached to a sort model for the data that
// the view is showing, and the columns must have sorters attached to them by
// calling gtk.ColumnViewColumn.SetSorter(). The initial sort order can be set
// with gtk.ColumnView.SortByColumn().
//
// The column view also supports interactive resizing and reordering of columns,
// via Drag-and-Drop of the column headers. This can be enabled or disabled with
// the gtk.ColumnView:reorderable and gtk.ColumnViewColumn:resizable properties.
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
// CSS nodes
//
//    columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ├── listview
//    │
//    ┊
//    ╰── [rubberband]
//
//
// GtkColumnView uses a single CSS node named columnview. It may carry the
// .column-separators style class, when gtk.ColumnView:show-column-separators
// property is set. Header widgets appear below a node with name header. The
// rows are contained in a GtkListView widget, so there is a listview node with
// the same structure as for a standalone GtkListView widget. If
// gtk.ColumnView:show-row-separators is set, it will be passed on to the list
// view, causing its CSS node to carry the .separators style class. For
// rubberband selection, a node with name rubberband is used.
//
// The main columnview node may also carry style classes to select the style of
// list presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
//
// Accessibility
//
// GtkColumnView uses the GTK_ACCESSIBLE_ROLE_TREE_GRID role, header title
// widgets are using the GTK_ACCESSIBLE_ROLE_COLUMN_HEADER role. The row widgets
// are using the GTK_ACCESSIBLE_ROLE_ROW role, and individual cells are using
// the GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type ColumnView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*ColumnView)(nil)
	_ coreglib.Objector = (*ColumnView)(nil)
)

func wrapColumnView(obj *coreglib.Object) *ColumnView {
	return &ColumnView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalColumnView(p uintptr) (interface{}, error) {
	return wrapColumnView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when a row has been activated by the user, usually
// via activating the GtkListBase|list.activate-item action.
//
// This allows for a convenient way to handle activation in a columnview. See
// gtk.ListItem.SetActivatable() for details on how to use this signal.
func (v *ColumnView) ConnectActivate(f func(position uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gtk4_ColumnView_ConnectActivate), f)
}
