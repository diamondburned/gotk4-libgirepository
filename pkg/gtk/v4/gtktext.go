// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_Text_ConnectToggleOverwrite(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_Text_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_Text_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectActivate(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeText = coreglib.Type(girepository.MustFind("Gtk", "Text").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeText, F: marshalText},
	})
}

// Text: GtkText widget is a single-line text entry widget.
//
// GtkText is the common implementation of single-line text editing that is
// shared between GtkEntry, GtkPasswordEntry, GtkSpinButton and other widgets.
// In all of these, GtkText` is used as the delegate for the gtk.Editable
// implementation.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk.Text.SetVisibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk.Text.SetInvisibleChar().
//
// If you are looking to add icons or progress display in an entry, look at
// GtkEntry. There other alternatives for more specialized use cases, such as
// GtkSearchEntry.
//
// If you need multi-line editable text, look at GtkTextView.
//
// CSS nodes
//
//    text[.read-only]
//    ├── placeholder
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [block-cursor]
//    ╰── [window.popup]
//
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// GtkText uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be skipped
// for accessibility. This is because GtkText is expected to be used as a
// delegate for a GtkEditable implementation that will be represented to
// accessibility.
type Text struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Editable
}

var (
	_ Widgetter         = (*Text)(nil)
	_ coreglib.Objector = (*Text)(nil)
)

func wrapText(obj *coreglib.Object) *Text {
	return &Text{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Editable: Editable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalText(p uintptr) (interface{}, error) {
	return wrapText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the user hits the Enter key.
//
// The default bindings for this signal are all forms of the <kbd>Enter</kbd>
// key.
func (v *Text) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectActivate), f)
}

// ConnectBackspace is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Backspace</kbd> and
// <kbd>Shift</kbd>-<kbd>Backspace</kbd>.
func (v *Text) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "backspace", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectBackspace), f)
}

// ConnectCopyClipboard is emitted to copy the selection to the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>c</kbd> and
// <kbd>Ctrl</kbd>-<kbd>Insert</kbd>.
func (v *Text) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectCopyClipboard), f)
}

// ConnectCutClipboard is emitted to cut the selection to the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>x</kbd> and
// <kbd>Shift</kbd>-<kbd>Delete</kbd>.
func (v *Text) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectCutClipboard), f)
}

// ConnectInsertAtCursor is emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This signal has no default bindings.
func (v *Text) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectInsertAtCursor), f)
}

// ConnectInsertEmoji is emitted to present the Emoji chooser for the self.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>.</kbd> and
// <kbd>Ctrl</kbd>-<kbd>;</kbd>.
func (v *Text) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectInsertEmoji), f)
}

// ConnectPasteClipboard is emitted to paste the contents of the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>v</kbd> and
// <kbd>Shift</kbd>-<kbd>Insert</kbd>.
func (v *Text) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectPasteClipboard), f)
}

// ConnectPreeditChanged is emitted when the preedit text changes.
//
// If an input method is used, the typed text will not immediately be committed
// to the buffer. So if you are interested in the text, connect to this signal.
func (v *Text) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectPreeditChanged), f)
}

// ConnectToggleOverwrite is emitted to toggle the overwrite mode of the
// GtkText.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal is <kbd>Insert</kbd>.
func (v *Text) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectToggleOverwrite), f)
}
