// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeShortcut = coreglib.Type(girepository.MustFind("Gtk", "Shortcut").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeShortcut, F: marshalShortcut},
	})
}

// ShortcutOverrides contains methods that are overridable.
type ShortcutOverrides struct {
}

func defaultShortcutOverrides(v *Shortcut) ShortcutOverrides {
	return ShortcutOverrides{}
}

// Shortcut: GtkShortcut describes a keyboard shortcut.
//
// It contains a description of how to trigger the shortcut via a
// gtk.ShortcutTrigger and a way to activate the shortcut on a widget via a
// gtk.ShortcutAction.
//
// The actual work is usually done via gtk.ShortcutController, which decides if
// and when to activate a shortcut. Using that controller directly however is
// rarely necessary as various higher level convenience APIs exist on Widgets
// that make it easier to use shortcuts in GTK.
//
// GtkShortcut does provide functionality to make it easy for users to work with
// shortcuts, either by providing informational strings for display purposes or
// by allowing shortcuts to be configured.
type Shortcut struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Shortcut)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Shortcut, *ShortcutClass, ShortcutOverrides](
		GTypeShortcut,
		initShortcutClass,
		wrapShortcut,
		defaultShortcutOverrides,
	)
}

func initShortcutClass(gclass unsafe.Pointer, overrides ShortcutOverrides, classInitFunc func(*ShortcutClass)) {
	if classInitFunc != nil {
		class := (*ShortcutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapShortcut(obj *coreglib.Object) *Shortcut {
	return &Shortcut{
		Object: obj,
	}
}

func marshalShortcut(p uintptr) (interface{}, error) {
	return wrapShortcut(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ShortcutClass: instance of this type is always passed by reference.
type ShortcutClass struct {
	*shortcutClass
}

// shortcutClass is the struct that's finalized.
type shortcutClass struct {
	native unsafe.Pointer
}

var GIRInfoShortcutClass = girepository.MustFind("Gtk", "ShortcutClass")
