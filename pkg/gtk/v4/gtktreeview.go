// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_TreeView_ConnectRowExpanded(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectRowCollapsed(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectRowActivated(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectCursorChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectColumnsChanged(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectUnselectAll(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectToggleCursorRow(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectTestExpandRow(gpointer, void*, void*, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectTestCollapseRow(gpointer, void*, void*, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectStartInteractiveSearch(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectSelectCursorRow(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectSelectCursorParent(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectSelectAll(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectExpandCollapseCursorRow(gpointer, gboolean, gboolean, gboolean, guintptr);
import "C"

// GType values.
var (
	GTypeTreeViewDropPosition = coreglib.Type(girepository.MustFind("Gtk", "TreeViewDropPosition").RegisteredGType())
	GTypeTreeView             = coreglib.Type(girepository.MustFind("Gtk", "TreeView").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTreeViewDropPosition, F: marshalTreeViewDropPosition},
		coreglib.TypeMarshaler{T: GTypeTreeView, F: marshalTreeView},
	})
}

// TreeViewDropPosition: enum for determining where a dropped row goes.
type TreeViewDropPosition C.gint

const (
	// TreeViewDropBefore: dropped row is inserted before.
	TreeViewDropBefore TreeViewDropPosition = iota
	// TreeViewDropAfter: dropped row is inserted after.
	TreeViewDropAfter
	// TreeViewDropIntoOrBefore: dropped row becomes a child or is inserted
	// before.
	TreeViewDropIntoOrBefore
	// TreeViewDropIntoOrAfter: dropped row becomes a child or is inserted
	// after.
	TreeViewDropIntoOrAfter
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewDropPosition.
func (t TreeViewDropPosition) String() string {
	switch t {
	case TreeViewDropBefore:
		return "Before"
	case TreeViewDropAfter:
		return "After"
	case TreeViewDropIntoOrBefore:
		return "IntoOrBefore"
	case TreeViewDropIntoOrAfter:
		return "IntoOrAfter"
	default:
		return fmt.Sprintf("TreeViewDropPosition(%d)", t)
	}
}

// TreeViewColumnDropFunc: function type for determining whether column can be
// dropped in a particular spot (as determined by prev_column and next_column).
// In left to right locales, prev_column is on the left of the potential drop
// spot, and next_column is on the right. In right to left mode, this is
// reversed. This function should return TRUE if the spot is a valid drop spot.
// Please note that returning TRUE does not actually indicate that the column
// drop was made, but is meant only to indicate a possible drop spot to the
// user.
type TreeViewColumnDropFunc func(treeView *TreeView, column, prevColumn, nextColumn *TreeViewColumn) (ok bool)

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView *TreeView, path *TreePath)

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModeller, iter *TreeIter) (ok bool)

// TreeViewSearchEqualFunc: function used for checking whether a row in model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModeller, column int, key string, iter *TreeIter) (ok bool)

// TreeViewOverrides contains methods that are overridable.
type TreeViewOverrides struct {
}

func defaultTreeViewOverrides(v *TreeView) TreeViewOverrides {
	return TreeViewOverrides{}
}

// TreeView: widget for displaying both trees and lists
//
// Widget that displays any object that implements the gtk.TreeModel interface.
//
// Please refer to the tree widget conceptual overview
// (section-tree-widget.html) for an overview of all the objects and data types
// related to the tree widget and how they work together.
//
//
// Coordinate systems in GtkTreeView API
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// - Widget coordinates: Coordinates relative to the widget (usually
// widget->window).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk.TreeView.ConvertWidgetToBinWindowCoords() (and vice
// versa), for the latter gtk.TreeView.ConvertBinWindowToTreeCoords() (and vice
// versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// gtk.TreeViewColumn objects as <child> elements and exposes the internal
// gtk.TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//
//
// CSS nodes
//
//    treeview.view
//    ├── header
//    │   ├── button
//    │   │   ╰── [sort-indicator]
//    ┊   ┊
//    │   ╰── button
//    │       ╰── [sort-indicator]
//    │
//    ├── [rubberband]
//    ╰── [dndtarget]
//
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes.
//
// Each column header consists of a button, which among other content, has a
// child with name sort-indicator, which carries the .ascending or .descending
// style classes when the column header should show a sort indicator. The CSS is
// expected to provide a suitable image using the -gtk-icon-source property.
//
// For rubberband selection, a subnode with name rubberband is used.
//
// For the drop target location during DND, a subnode with name dndtarget is
// used.
type TreeView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*TreeView)(nil)
	_ coreglib.Objector = (*TreeView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeView, *TreeViewClass, TreeViewOverrides](
		GTypeTreeView,
		initTreeViewClass,
		wrapTreeView,
		defaultTreeViewOverrides,
	)
}

func initTreeViewClass(gclass unsafe.Pointer, overrides TreeViewOverrides, classInitFunc func(*TreeViewClass)) {
	if classInitFunc != nil {
		class := (*TreeViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeView(obj *coreglib.Object) *TreeView {
	return &TreeView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	return wrapTreeView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectColumnsChanged: number of columns of the treeview has changed.
func (v *TreeView) ConnectColumnsChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "columns-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectColumnsChanged), f)
}

// ConnectCursorChanged: position of the cursor (focused cell) has changed.
func (v *TreeView) ConnectCursorChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "cursor-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectCursorChanged), f)
}

func (v *TreeView) ConnectExpandCollapseCursorRow(f func(object, p0, p1 bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "expand-collapse-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectExpandCollapseCursorRow), f)
}

// ConnectRowActivated: "row-activated" signal is emitted when the method
// gtk_tree_view_row_activated() is called, when the user double clicks a
// treeview row with the "activate-on-single-click" property set to FALSE, or
// when the user single clicks a row when the "activate-on-single-click"
// property set to TRUE. It is also emitted when a non-editable row is selected
// and one of the keys: Space, Shift+Space, Return or Enter is pressed.
//
// For selection handling refer to the [tree widget conceptual
// overview][TreeWidget] as well as TreeSelection.
func (v *TreeView) ConnectRowActivated(f func(path *TreePath, column *TreeViewColumn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-activated", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectRowActivated), f)
}

// ConnectRowCollapsed: given row has been collapsed (child nodes are hidden).
func (v *TreeView) ConnectRowCollapsed(f func(iter *TreeIter, path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-collapsed", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectRowCollapsed), f)
}

// ConnectRowExpanded: given row has been expanded (child nodes are shown).
func (v *TreeView) ConnectRowExpanded(f func(iter *TreeIter, path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "row-expanded", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectRowExpanded), f)
}

func (v *TreeView) ConnectSelectAll(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectSelectAll), f)
}

func (v *TreeView) ConnectSelectCursorParent(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select-cursor-parent", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectSelectCursorParent), f)
}

func (v *TreeView) ConnectSelectCursorRow(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectSelectCursorRow), f)
}

func (v *TreeView) ConnectStartInteractiveSearch(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "start-interactive-search", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectStartInteractiveSearch), f)
}

// ConnectTestCollapseRow: given row is about to be collapsed (hide its children
// nodes). Use this signal if you need to control the collapsibility of
// individual rows.
func (v *TreeView) ConnectTestCollapseRow(f func(iter *TreeIter, path *TreePath) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "test-collapse-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectTestCollapseRow), f)
}

// ConnectTestExpandRow: given row is about to be expanded (show its children
// nodes). Use this signal if you need to control the expandability of
// individual rows.
func (v *TreeView) ConnectTestExpandRow(f func(iter *TreeIter, path *TreePath) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "test-expand-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectTestExpandRow), f)
}

func (v *TreeView) ConnectToggleCursorRow(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectToggleCursorRow), f)
}

func (v *TreeView) ConnectUnselectAll(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectUnselectAll), f)
}

// TreeViewClass: instance of this type is always passed by reference.
type TreeViewClass struct {
	*treeViewClass
}

// treeViewClass is the struct that's finalized.
type treeViewClass struct {
	native unsafe.Pointer
}

var GIRInfoTreeViewClass = girepository.MustFind("Gtk", "TreeViewClass")
