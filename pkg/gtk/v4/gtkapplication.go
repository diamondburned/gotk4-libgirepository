// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_Application_ConnectWindowRemoved(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_Application_ConnectWindowAdded(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_Application_ConnectQueryEnd(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeApplicationInhibitFlags = coreglib.Type(girepository.MustFind("Gtk", "ApplicationInhibitFlags").RegisteredGType())
	GTypeApplication             = coreglib.Type(girepository.MustFind("Gtk", "Application").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeApplicationInhibitFlags, F: marshalApplicationInhibitFlags},
		coreglib.TypeMarshaler{T: GTypeApplication, F: marshalApplication},
	})
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// GtkApplication.
//
// See gtk.Application.Inhibit().
type ApplicationInhibitFlags C.guint

const (
	// ApplicationInhibitLogout: inhibit ending the user session by logging out
	// or by shutting down the computer.
	ApplicationInhibitLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitSwitch: inhibit user switching.
	ApplicationInhibitSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitSuspend: inhibit suspending the session or computer.
	ApplicationInhibitSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitIdle: inhibit the session being marked as idle (and
	// possibly locked).
	ApplicationInhibitIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ApplicationInhibitFlags.
func (a ApplicationInhibitFlags) String() string {
	if a == 0 {
		return "ApplicationInhibitFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(98)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case ApplicationInhibitLogout:
			builder.WriteString("Logout|")
		case ApplicationInhibitSwitch:
			builder.WriteString("Switch|")
		case ApplicationInhibitSuspend:
			builder.WriteString("Suspend|")
		case ApplicationInhibitIdle:
			builder.WriteString("Idle|")
		default:
			builder.WriteString(fmt.Sprintf("ApplicationInhibitFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a ApplicationInhibitFlags) Has(other ApplicationInhibitFlags) bool {
	return (a & other) == other
}

// ApplicationOverrides contains methods that are overridable.
type ApplicationOverrides struct {
}

func defaultApplicationOverrides(v *Application) ApplicationOverrides {
	return ApplicationOverrides{}
}

// Application: GtkApplication is a high-level API for writing applications.
//
// It supports many aspects of writing a GTK application in a convenient
// fashion, without enforcing a one-size-fits-all model.
//
// Currently, GtkApplication handles GTK initialization, application uniqueness,
// session management, provides some basic scriptability and desktop shell
// integration by exporting actions and menus and manages a list of toplevel
// windows whose life-cycle is automatically tied to the life-cycle of your
// application.
//
// While GtkApplication works fine with plain gtk.Windows, it is recommended to
// use it together with gtk.ApplicationWindow.
//
//
// Automatic resources
//
// GtkApplication will automatically load menus from the GtkBuilder resource
// located at "gtk/menus.ui", relative to the application's resource base path
// (see g_application_set_resource_base_path()). The menu with the ID "menubar"
// is taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk.Application.GetMenuByID() which
// allows for dynamic population of a part of the menu structure.
//
// It is also possible to provide the menubar manually using
// gtk.Application.SetMenubar().
//
// GtkApplication will also automatically setup an icon search path for the
// default icon theme by appending "icons" to the resource base path. This
// allows your application to easily store its icons as resources. See
// gtk.IconTheme.AddResourcePath() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// gtk.ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each gtk.ApplicationWindow and sets up
// the keyboard accelerator <kbd>Control</kbd>+<kbd>?</kbd> to open it. To
// create a menu item that displays the shortcuts window, associate the item
// with the action win.show-help-overlay.
//
//
// A simple application
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c) is
// available in the GTK source code repository
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the gtk.Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk.Application.Inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK: Basics (getting_started.html#basics).
type Application struct {
	_ [0]func() // equal guard
	gio.Application
}

var (
	_ coreglib.Objector = (*Application)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Application, *ApplicationClass, ApplicationOverrides](
		GTypeApplication,
		initApplicationClass,
		wrapApplication,
		defaultApplicationOverrides,
	)
}

func initApplicationClass(gclass unsafe.Pointer, overrides ApplicationOverrides, classInitFunc func(*ApplicationClass)) {
	if classInitFunc != nil {
		class := (*ApplicationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplication(obj *coreglib.Object) *Application {
	return &Application{
		Application: gio.Application{
			Object: obj,
			ActionGroup: gio.ActionGroup{
				Object: obj,
			},
			ActionMap: gio.ActionMap{
				Object: obj,
			},
		},
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	return wrapApplication(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectQueryEnd is emitted when the session manager is about to end the
// session.
//
// This signal is only emitted if gtk.Application:register-session is TRUE.
// Applications can connect to this signal and call gtk.Application.Inhibit()
// with GTK_APPLICATION_INHIBIT_LOGOUT to delay the end of the session until
// state has been saved.
func (v *Application) ConnectQueryEnd(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "query-end", false, unsafe.Pointer(C._gotk4_gtk4_Application_ConnectQueryEnd), f)
}

// ConnectWindowAdded is emitted when a gtk.Window is added to application
// through gtk.Application.AddWindow().
func (v *Application) ConnectWindowAdded(f func(window *Window)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "window-added", false, unsafe.Pointer(C._gotk4_gtk4_Application_ConnectWindowAdded), f)
}

// ConnectWindowRemoved is emitted when a gtk.Window is removed from
// application.
//
// This can happen as a side-effect of the window being destroyed or explicitly
// through gtk.Application.RemoveWindow().
func (v *Application) ConnectWindowRemoved(f func(window *Window)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "window-removed", false, unsafe.Pointer(C._gotk4_gtk4_Application_ConnectWindowRemoved), f)
}

// ApplicationClass: instance of this type is always passed by reference.
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized.
type applicationClass struct {
	native unsafe.Pointer
}

var GIRInfoApplicationClass = girepository.MustFind("Gtk", "ApplicationClass")
