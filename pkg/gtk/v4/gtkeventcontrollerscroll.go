// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_EventControllerScroll_ConnectScrollEnd(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerScroll_ConnectScrollBegin(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerScroll_ConnectDecelerate(gpointer, gdouble, gdouble, guintptr);
// extern gboolean _gotk4_gtk4_EventControllerScroll_ConnectScroll(gpointer, gdouble, gdouble, guintptr);
import "C"

// GType values.
var (
	GTypeEventControllerScrollFlags = coreglib.Type(girepository.MustFind("Gtk", "EventControllerScrollFlags").RegisteredGType())
	GTypeEventControllerScroll      = coreglib.Type(girepository.MustFind("Gtk", "EventControllerScroll").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeEventControllerScrollFlags, F: marshalEventControllerScrollFlags},
		coreglib.TypeMarshaler{T: GTypeEventControllerScroll, F: marshalEventControllerScroll},
	})
}

// EventControllerScrollFlags describes the behavior of a
// GtkEventControllerScroll.
type EventControllerScrollFlags C.guint

const (
	// EventControllerScrollNone: don't emit scroll.
	EventControllerScrollNone EventControllerScrollFlags = 0b0
	// EventControllerScrollVertical: emit scroll with vertical deltas.
	EventControllerScrollVertical EventControllerScrollFlags = 0b1
	// EventControllerScrollHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollHorizontal EventControllerScrollFlags = 0b10
	// EventControllerScrollDiscrete: only emit deltas that are multiples of 1.
	EventControllerScrollDiscrete EventControllerScrollFlags = 0b100
	// EventControllerScrollKinetic: emit ::decelerate after continuous scroll
	// finishes.
	EventControllerScrollKinetic EventControllerScrollFlags = 0b1000
	// EventControllerScrollBothAxes: emit scroll on both axes.
	EventControllerScrollBothAxes EventControllerScrollFlags = 0b11
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for EventControllerScrollFlags.
func (e EventControllerScrollFlags) String() string {
	if e == 0 {
		return "EventControllerScrollFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(176)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case EventControllerScrollNone:
			builder.WriteString("None|")
		case EventControllerScrollVertical:
			builder.WriteString("Vertical|")
		case EventControllerScrollHorizontal:
			builder.WriteString("Horizontal|")
		case EventControllerScrollDiscrete:
			builder.WriteString("Discrete|")
		case EventControllerScrollKinetic:
			builder.WriteString("Kinetic|")
		case EventControllerScrollBothAxes:
			builder.WriteString("BothAxes|")
		default:
			builder.WriteString(fmt.Sprintf("EventControllerScrollFlags(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e EventControllerScrollFlags) Has(other EventControllerScrollFlags) bool {
	return (e & other) == other
}

// EventControllerScroll: GtkEventControllerScroll is an event controller that
// handles scroll events.
//
// It is capable of handling both discrete and continuous scroll events from
// mice or touchpads, abstracting them both with the
// gtk.EventControllerScroll::scroll signal. Deltas in the discrete case are
// multiples of 1.
//
// In the case of continuous scroll events, GtkEventControllerScroll encloses
// all gtk.EventControllerScroll::scroll emissions between two
// gtk.EventControllerScroll::scroll-begin and
// gtk.EventControllerScroll::scroll-end signals.
//
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// gtk.EventControllerScroll.SetFlags() (e.g. because the scrolling conditions
// of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through GTK_EVENT_CONTROLLER_SCROLL_VERTICAL,
// GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL and
// GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES. If any axis is disabled, the
// respective gtk.EventControllerScroll::scroll delta will be 0. Vertical scroll
// events will be translated to horizontal motion for the devices incapable of
// horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through GTK_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// gtk.EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
type EventControllerScroll struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*EventControllerScroll)(nil)
)

func wrapEventControllerScroll(obj *coreglib.Object) *EventControllerScroll {
	return &EventControllerScroll{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	return wrapEventControllerScroll(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDecelerate is emitted after scroll is finished if the
// GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag is set.
//
// vel_x and vel_y express the initial velocity that was imprinted by the scroll
// events. vel_x and vel_y are expressed in pixels/ms.
func (v *EventControllerScroll) ConnectDecelerate(f func(velX, velY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "decelerate", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectDecelerate), f)
}

// ConnectScroll signals that the widget should scroll by the amount specified
// by dx and dy.
func (v *EventControllerScroll) ConnectScroll(f func(dx, dy float64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "scroll", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectScroll), f)
}

// ConnectScrollBegin signals that a new scrolling operation has begun.
//
// It will only be emitted on devices capable of it.
func (v *EventControllerScroll) ConnectScrollBegin(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "scroll-begin", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectScrollBegin), f)
}

// ConnectScrollEnd signals that a scrolling operation has finished.
//
// It will only be emitted on devices capable of it.
func (v *EventControllerScroll) ConnectScrollEnd(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "scroll-end", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectScrollEnd), f)
}
