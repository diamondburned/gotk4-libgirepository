// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_DropTarget_ConnectLeave(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_DropTarget_ConnectDrop(gpointer, GValue, gdouble, gdouble, guintptr);
// extern gboolean _gotk4_gtk4_DropTarget_ConnectAccept(gpointer, void*, guintptr);
import "C"

// GType values.
var (
	GTypeDropTarget = coreglib.Type(girepository.MustFind("Gtk", "DropTarget").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDropTarget, F: marshalDropTarget},
	})
}

// DropTarget: GtkDropTarget is an event controller to receive Drag-and-Drop
// operations.
//
// The most basic way to use a GtkDropTarget to receive drops on a widget is to
// create it via gtk.DropTarget.New, passing in the GType of the data you want
// to receive and connect to the gtk.DropTarget::drop signal to receive the
// data:
//
//    static gboolean
//    on_drop (GtkDropTarget *target,
//             const GValue  *value,
//             double         x,
//             double         y,
//             gpointer       data)
//    {
//      MyWidget *self = data;
//
//      // Call the appropriate setter depending on the type of data
//      // that we received
//      if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//        my_widget_set_file (self, g_value_get_object (value));
//      else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//        my_widget_set_pixbuf (self, g_value_get_object (value));
//      else
//        return FALSE;
//
//      return TRUE;
//    }
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      GtkDropTarget *target =
//        gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
//
//      // This widget accepts two types of drop types: GFile objects
//      // and GdkPixbuf objects
//      gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//        G_TYPE_FILE,
//        GDK_TYPE_PIXBUF,
//      }, 2);
//
//      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
//    }
//
//
// GtkDropTarget supports more options, such as:
//
//    * rejecting potential drops via the gtk.DropTarget::accept signal
//      and the gtk.DropTarget.Reject() function to let other drop
//      targets handle the drop
//    * tracking an ongoing drag operation before the drop via the
//      gtk.DropTarget::enter, gtk.DropTarget::motion and
//      gtk.DropTarget::leave signals
//    * configuring how to receive data by setting the
//      gtk.DropTarget:preload property and listening for its
//      availability via the gtk.DropTarget:value property
//
// However, GtkDropTarget is ultimately modeled in a synchronous way and only
// supports data transferred via GType. If you want full control over an ongoing
// drop, the gtk.DropTargetAsync object gives you this ability.
//
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
//
// If you are not interested in receiving the drop, but just want to update UI
// state during a Drag-and-Drop operation (e.g. switching tabs), you can use
// gtk.DropControllerMotion.
type DropTarget struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*DropTarget)(nil)
)

func wrapDropTarget(obj *coreglib.Object) *DropTarget {
	return &DropTarget{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalDropTarget(p uintptr) (interface{}, error) {
	return wrapDropTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAccept is emitted on the drop site when a drop operation is about to
// begin.
//
// If the drop is not accepted, FALSE will be returned and the drop target will
// ignore the drop. If TRUE is returned, the drop is accepted for now but may be
// rejected later via a call to gtk.DropTarget.Reject() or ultimately by
// returning FALSE from a gtk.DropTarget::drop handler.
//
// The default handler for this signal decides whether to accept the drop based
// on the formats provided by the drop.
//
// If the decision whether the drop will be accepted or rejected depends on the
// data, this function should return TRUE, the gtk.DropTarget:preload property
// should be set and the value should be inspected via the ::notify:value
// signal, calling gtk.DropTarget.Reject() if required.
func (v *DropTarget) ConnectAccept(f func(drop gdk.Dropper) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "accept", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectAccept), f)
}

// ConnectDrop is emitted on the drop site when the user drops the data onto the
// widget.
//
// The signal handler must determine whether the pointer position is in a drop
// zone or not. If it is not in a drop zone, it returns FALSE and no further
// processing is necessary.
//
// Otherwise, the handler returns TRUE. In this case, this handler will accept
// the drop. The handler is responsible for rading the given value and
// performing the drop operation.
func (v *DropTarget) ConnectDrop(f func(value coreglib.Value, x, y float64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drop", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectDrop), f)
}

// ConnectLeave is emitted on the drop site when the pointer leaves the widget.
//
// Its main purpose it to undo things done in gtk.DropTarget::enter.
func (v *DropTarget) ConnectLeave(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "leave", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectLeave), f)
}
