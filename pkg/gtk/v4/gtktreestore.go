// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeTreeStore = coreglib.Type(girepository.MustFind("Gtk", "TreeStore").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTreeStore, F: marshalTreeStore},
	})
}

// TreeStoreOverrides contains methods that are overridable.
type TreeStoreOverrides struct {
}

func defaultTreeStoreOverrides(v *TreeStore) TreeStoreOverrides {
	return TreeStoreOverrides{}
}

// TreeStore: tree-like data structure that can be used with the GtkTreeView
//
// The TreeStore object is a list model for use with a TreeView widget. It
// implements the TreeModel interface, and consequently, can use all of the
// methods available there. It also implements the TreeSortable interface so it
// can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
//
// GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
//
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>.
type TreeStore struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
	TreeDragDest
	TreeDragSource
	TreeSortable
}

var (
	_ coreglib.Objector = (*TreeStore)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeStore, *TreeStoreClass, TreeStoreOverrides](
		GTypeTreeStore,
		initTreeStoreClass,
		wrapTreeStore,
		defaultTreeStoreOverrides,
	)
}

func initTreeStoreClass(gclass unsafe.Pointer, overrides TreeStoreOverrides, classInitFunc func(*TreeStoreClass)) {
	if classInitFunc != nil {
		class := (*TreeStoreClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeStore(obj *coreglib.Object) *TreeStore {
	return &TreeStore{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		TreeDragDest: TreeDragDest{
			Object: obj,
		},
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeSortable: TreeSortable{
			TreeModel: TreeModel{
				Object: obj,
			},
		},
	}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	return wrapTreeStore(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// TreeStoreClass: instance of this type is always passed by reference.
type TreeStoreClass struct {
	*treeStoreClass
}

// treeStoreClass is the struct that's finalized.
type treeStoreClass struct {
	native unsafe.Pointer
}

var GIRInfoTreeStoreClass = girepository.MustFind("Gtk", "TreeStoreClass")
