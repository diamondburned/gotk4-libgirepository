// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypePicture = coreglib.Type(girepository.MustFind("Gtk", "Picture").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePicture, F: marshalPicture},
	})
}

// PictureOverrides contains methods that are overridable.
type PictureOverrides struct {
}

func defaultPictureOverrides(v *Picture) PictureOverrides {
	return PictureOverrides{}
}

// Picture: GtkPicture widget displays a GdkPaintable.
//
// !An example GtkPicture (picture.png)
//
// Many convenience functions are provided to make pictures simple to use. For
// example, if you want to load an image from a file, and then display it,
// there’s a convenience function to do this:
//
//    GtkWidget *widget = gtk_picture_new_for_filename ("myfile.png");
//
//
// If the file isn’t loaded successfully, the picture will contain a “broken
// image” icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with gdk.Texture.NewFromFile, then create the
// GtkPicture with gtk.Picture.NewForPaintable.
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of GResource for details. In this
// case, gtk.Picture.NewForResource and gtk.Picture.SetResource() should be
// used.
//
// GtkPicture displays an image at its natural size. See gtk.Image if you want
// to display a fixed-size image, such as an icon.
//
//
// Sizing the paintable
//
// You can influence how the paintable is displayed inside the GtkPicture. By
// turning off gtk.Picture:keep-aspect-ratio you can allow the paintable to get
// stretched. gtk.Picture:can-shrink can be unset to make sure that paintables
// are never made smaller than their ideal size - but be careful if you do not
// know the size of the paintable in use (like when displaying user-loaded
// images). This can easily cause the picture to grow larger than the screen.
// And gtkwidget:halign and gtkwidget:valign can be used to make sure the
// paintable doesn't fill all available space but is instead displayed at its
// original size.
//
//
// CSS nodes
//
// GtkPicture has a single CSS node with the name picture.
//
//
// Accessibility
//
// GtkPicture uses the GTK_ACCESSIBLE_ROLE_IMG role.
type Picture struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Picture)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Picture, *PictureClass, PictureOverrides](
		GTypePicture,
		initPictureClass,
		wrapPicture,
		defaultPictureOverrides,
	)
}

func initPictureClass(gclass unsafe.Pointer, overrides PictureOverrides, classInitFunc func(*PictureClass)) {
	if classInitFunc != nil {
		class := (*PictureClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPicture(obj *coreglib.Object) *Picture {
	return &Picture{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalPicture(p uintptr) (interface{}, error) {
	return wrapPicture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// PictureClass: instance of this type is always passed by reference.
type PictureClass struct {
	*pictureClass
}

// pictureClass is the struct that's finalized.
type pictureClass struct {
	native unsafe.Pointer
}

var GIRInfoPictureClass = girepository.MustFind("Gtk", "PictureClass")
