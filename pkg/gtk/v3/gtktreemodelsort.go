// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeTreeModelSort = coreglib.Type(girepository.MustFind("Gtk", "TreeModelSort").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTreeModelSort, F: marshalTreeModelSort},
	})
}

// TreeModelSortOverrides contains methods that are overridable.
type TreeModelSortOverrides struct {
}

func defaultTreeModelSortOverrides(v *TreeModelSort) TreeModelSortOverrides {
	return TreeModelSortOverrides{}
}

// TreeModelSort is a model which implements the TreeSortable interface. It does
// not hold any data itself, but rather is created with a child model and
// proxies its data. It has identical column types to this child model, and the
// changes in the child are propagated. The primary purpose of this model is to
// provide a way to sort a different model without modifying it. Note that the
// sort function used by TreeModelSort is not guaranteed to be stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
//
// Using a TreeModelSort
//
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
//
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
//
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
//
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
//
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
//
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }.
type TreeModelSort struct {
	_ [0]func() // equal guard
	*coreglib.Object

	TreeDragSource
	TreeSortable
}

var (
	_ coreglib.Objector = (*TreeModelSort)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeModelSort, *TreeModelSortClass, TreeModelSortOverrides](
		GTypeTreeModelSort,
		initTreeModelSortClass,
		wrapTreeModelSort,
		defaultTreeModelSortOverrides,
	)
}

func initTreeModelSortClass(gclass unsafe.Pointer, overrides TreeModelSortOverrides, classInitFunc func(*TreeModelSortClass)) {
	if classInitFunc != nil {
		class := (*TreeModelSortClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeModelSort(obj *coreglib.Object) *TreeModelSort {
	return &TreeModelSort{
		Object: obj,
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeSortable: TreeSortable{
			TreeModel: TreeModel{
				Object: obj,
			},
		},
	}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	return wrapTreeModelSort(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// TreeModelSortClass: instance of this type is always passed by reference.
type TreeModelSortClass struct {
	*treeModelSortClass
}

// treeModelSortClass is the struct that's finalized.
type treeModelSortClass struct {
	native unsafe.Pointer
}

var GIRInfoTreeModelSortClass = girepository.MustFind("Gtk", "TreeModelSortClass")
