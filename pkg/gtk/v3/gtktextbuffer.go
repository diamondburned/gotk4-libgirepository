// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_TextBuffer_ConnectRemoveTag(gpointer, void*, void*, void*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectPasteDone(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectModifiedChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectMarkSet(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectMarkDeleted(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectInsertText(gpointer, void*, gchar*, gint, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectInsertPixbuf(gpointer, void*, GdkPixbuf*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectEndUserAction(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectDeleteRange(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectBeginUserAction(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectApplyTag(gpointer, void*, void*, void*, guintptr);
import "C"

// GType values.
var (
	GTypeTextBufferTargetInfo = coreglib.Type(girepository.MustFind("Gtk", "TextBufferTargetInfo").RegisteredGType())
	GTypeTextBuffer           = coreglib.Type(girepository.MustFind("Gtk", "TextBuffer").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTextBufferTargetInfo, F: marshalTextBufferTargetInfo},
		coreglib.TypeMarshaler{T: GTypeTextBuffer, F: marshalTextBuffer},
	})
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from -1 to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo C.gint

const (
	// TextBufferTargetInfoBufferContents: buffer contents.
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text.
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text.
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextBufferTargetInfo.
func (t TextBufferTargetInfo) String() string {
	switch t {
	case TextBufferTargetInfoBufferContents:
		return "BufferContents"
	case TextBufferTargetInfoRichText:
		return "RichText"
	case TextBufferTargetInfoText:
		return "Text"
	default:
		return fmt.Sprintf("TextBufferTargetInfo(%d)", t)
	}
}

// TextBufferOverrides contains methods that are overridable.
type TextBufferOverrides struct {
}

func defaultTextBufferOverrides(v *TextBuffer) TextBufferOverrides {
	return TextBufferOverrides{}
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextBuffer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextBuffer, *TextBufferClass, TextBufferOverrides](
		GTypeTextBuffer,
		initTextBufferClass,
		wrapTextBuffer,
		defaultTextBufferOverrides,
	)
}

func initTextBufferClass(gclass unsafe.Pointer, overrides TextBufferOverrides, classInitFunc func(*TextBufferClass)) {
	if classInitFunc != nil {
		class := (*TextBufferClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextBuffer(obj *coreglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	return wrapTextBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectApplyTag signal is emitted to apply a tag to a range of text in a
// TextBuffer. Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk_text_buffer_apply_tag(), gtk_text_buffer_insert_with_tags(),
// gtk_text_buffer_insert_range().
func (v *TextBuffer) ConnectApplyTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "apply-tag", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectApplyTag), f)
}

// ConnectBeginUserAction signal is emitted at the beginning of a single
// user-visible operation on a TextBuffer.
//
// See also: gtk_text_buffer_begin_user_action(),
// gtk_text_buffer_insert_interactive(),
// gtk_text_buffer_insert_range_interactive(),
// gtk_text_buffer_delete_interactive(), gtk_text_buffer_backspace(),
// gtk_text_buffer_delete_selection().
func (v *TextBuffer) ConnectBeginUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "begin-user-action", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectBeginUserAction), f)
}

// ConnectChanged signal is emitted when the content of a TextBuffer has
// changed.
func (v *TextBuffer) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "changed", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectChanged), f)
}

// ConnectDeleteRange signal is emitted to delete a range from a TextBuffer.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them). The default
// signal handler revalidates the start and end iters to both point to the
// location where text was deleted. Handlers which run after the default handler
// (see g_signal_connect_after()) do not have access to the deleted text.
//
// See also: gtk_text_buffer_delete().
func (v *TextBuffer) ConnectDeleteRange(f func(start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "delete-range", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectDeleteRange), f)
}

// ConnectEndUserAction signal is emitted at the end of a single user-visible
// operation on the TextBuffer.
//
// See also: gtk_text_buffer_end_user_action(),
// gtk_text_buffer_insert_interactive(),
// gtk_text_buffer_insert_range_interactive(),
// gtk_text_buffer_delete_interactive(), gtk_text_buffer_backspace(),
// gtk_text_buffer_delete_selection(), gtk_text_buffer_backspace().
func (v *TextBuffer) ConnectEndUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "end-user-action", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectEndUserAction), f)
}

// ConnectInsertChildAnchor signal is emitted to insert a TextChildAnchor in a
// TextBuffer. Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted anchor.
//
// See also: gtk_text_buffer_insert_child_anchor().
func (v *TextBuffer) ConnectInsertChildAnchor(f func(location *TextIter, anchor *TextChildAnchor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-child-anchor", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor), f)
}

// ConnectInsertPixbuf signal is emitted to insert a Pixbuf in a TextBuffer.
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted pixbuf.
//
// See also: gtk_text_buffer_insert_pixbuf().
func (v *TextBuffer) ConnectInsertPixbuf(f func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-pixbuf", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectInsertPixbuf), f)
}

// ConnectInsertText signal is emitted to insert text in a TextBuffer. Insertion
// actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to point to the end of the inserted text.
//
// See also: gtk_text_buffer_insert(), gtk_text_buffer_insert_range().
func (v *TextBuffer) ConnectInsertText(f func(location *TextIter, text string, len int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-text", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectInsertText), f)
}

// ConnectMarkDeleted signal is emitted as notification after a TextMark is
// deleted.
//
// See also: gtk_text_buffer_delete_mark().
func (v *TextBuffer) ConnectMarkDeleted(f func(mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "mark-deleted", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectMarkDeleted), f)
}

// ConnectMarkSet signal is emitted as notification after a TextMark is set.
//
// See also: gtk_text_buffer_create_mark(), gtk_text_buffer_move_mark().
func (v *TextBuffer) ConnectMarkSet(f func(location *TextIter, mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "mark-set", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectMarkSet), f)
}

// ConnectModifiedChanged signal is emitted when the modified bit of a
// TextBuffer flips.
//
// See also: gtk_text_buffer_set_modified().
func (v *TextBuffer) ConnectModifiedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "modified-changed", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectModifiedChanged), f)
}

// ConnectPasteDone signal is emitted after paste operation has been completed.
// This is useful to properly scroll the view to the end of the pasted text. See
// gtk_text_buffer_paste_clipboard() for more details.
func (v *TextBuffer) ConnectPasteDone(f func(clipboard *Clipboard)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "paste-done", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectPasteDone), f)
}

// ConnectRemoveTag signal is emitted to remove all occurrences of tag from a
// range of text in a TextBuffer. Removal actually occurs in the default
// handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk_text_buffer_remove_tag().
func (v *TextBuffer) ConnectRemoveTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "remove-tag", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectRemoveTag), f)
}

// TextBufferClass: instance of this type is always passed by reference.
type TextBufferClass struct {
	*textBufferClass
}

// textBufferClass is the struct that's finalized.
type textBufferClass struct {
	native unsafe.Pointer
}

var GIRInfoTextBufferClass = girepository.MustFind("Gtk", "TextBufferClass")
