// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAttachOptions = coreglib.Type(girepository.MustFind("Gtk", "AttachOptions").RegisteredGType())
	GTypeTable         = coreglib.Type(girepository.MustFind("Gtk", "Table").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAttachOptions, F: marshalAttachOptions},
		coreglib.TypeMarshaler{T: GTypeTable, F: marshalTable},
	})
}

// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
type AttachOptions C.guint

const (
	// Expand: widget should expand to take up any extra space in its container
	// that has been allocated.
	Expand AttachOptions = 0b1
	// Shrink: widget should shrink as and when possible.
	Shrink AttachOptions = 0b10
	// Fill: widget should fill the space allocated to it.
	Fill AttachOptions = 0b100
)

func marshalAttachOptions(p uintptr) (interface{}, error) {
	return AttachOptions(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AttachOptions.
func (a AttachOptions) String() string {
	if a == 0 {
		return "AttachOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(18)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case Expand:
			builder.WriteString("Expand|")
		case Shrink:
			builder.WriteString("Shrink|")
		case Fill:
			builder.WriteString("Fill|")
		default:
			builder.WriteString(fmt.Sprintf("AttachOptions(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AttachOptions) Has(other AttachOptions) bool {
	return (a & other) == other
}

// TableOverrides contains methods that are overridable.
type TableOverrides struct {
}

func defaultTableOverrides(v *Table) TableOverrides {
	return TableOverrides{}
}

// Table functions allow the programmer to arrange widgets in rows and columns,
// making it easy to align many widgets next to each other, horizontally and
// vertically.
//
// Tables are created with a call to gtk_table_new(), the size of which can
// later be changed with gtk_table_resize().
//
// Widgets can be added to a table using gtk_table_attach() or the more
// convenient (but slightly less flexible) gtk_table_attach_defaults().
//
// To alter the space next to a specific row, use gtk_table_set_row_spacing(),
// and for a column, gtk_table_set_col_spacing(). The gaps between all rows or
// columns can be changed by calling gtk_table_set_row_spacings() or
// gtk_table_set_col_spacings() respectively. Note that spacing is added between
// the children, while padding added by gtk_table_attach() is added on either
// side of the widget it belongs to.
//
// gtk_table_set_homogeneous(), can be used to set whether all cells in the
// table will resize themselves to the size of the largest widget in the table.
//
// > Table has been deprecated. Use Grid instead. It provides the same >
// capabilities as GtkTable for arranging widgets in a rectangular grid, but >
// does support height-for-width geometry management.
type Table struct {
	_ [0]func() // equal guard
	Container
}

var (
	_ Containerer = (*Table)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Table, *TableClass, TableOverrides](
		GTypeTable,
		initTableClass,
		wrapTable,
		defaultTableOverrides,
	)
}

func initTableClass(gclass unsafe.Pointer, overrides TableOverrides, classInitFunc func(*TableClass)) {
	if classInitFunc != nil {
		class := (*TableClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTable(obj *coreglib.Object) *Table {
	return &Table{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalTable(p uintptr) (interface{}, error) {
	return wrapTable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// TableChild: instance of this type is always passed by reference.
type TableChild struct {
	*tableChild
}

// tableChild is the struct that's finalized.
type tableChild struct {
	native unsafe.Pointer
}

var GIRInfoTableChild = girepository.MustFind("Gtk", "TableChild")

func (t *TableChild) Widget() Widgetter {
	offset := GIRInfoTableChild.StructFieldOffset("widget")
	valptr := (*Widgetter)(unsafe.Add(t.native, offset))
	var _v Widgetter // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_v = rv
	}
	return _v
}

func (t *TableChild) LeftAttach() uint16 {
	offset := GIRInfoTableChild.StructFieldOffset("left_attach")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableChild) RightAttach() uint16 {
	offset := GIRInfoTableChild.StructFieldOffset("right_attach")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableChild) TopAttach() uint16 {
	offset := GIRInfoTableChild.StructFieldOffset("top_attach")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableChild) BottomAttach() uint16 {
	offset := GIRInfoTableChild.StructFieldOffset("bottom_attach")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableChild) Xpadding() uint16 {
	offset := GIRInfoTableChild.StructFieldOffset("xpadding")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableChild) Ypadding() uint16 {
	offset := GIRInfoTableChild.StructFieldOffset("ypadding")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableChild) SetLeftAttach(leftAttach uint16) {
	offset := GIRInfoTableChild.StructFieldOffset("left_attach")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(leftAttach)
}

func (t *TableChild) SetRightAttach(rightAttach uint16) {
	offset := GIRInfoTableChild.StructFieldOffset("right_attach")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(rightAttach)
}

func (t *TableChild) SetTopAttach(topAttach uint16) {
	offset := GIRInfoTableChild.StructFieldOffset("top_attach")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(topAttach)
}

func (t *TableChild) SetBottomAttach(bottomAttach uint16) {
	offset := GIRInfoTableChild.StructFieldOffset("bottom_attach")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(bottomAttach)
}

func (t *TableChild) SetXpadding(xpadding uint16) {
	offset := GIRInfoTableChild.StructFieldOffset("xpadding")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(xpadding)
}

func (t *TableChild) SetYpadding(ypadding uint16) {
	offset := GIRInfoTableChild.StructFieldOffset("ypadding")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(ypadding)
}

// TableClass: instance of this type is always passed by reference.
type TableClass struct {
	*tableClass
}

// tableClass is the struct that's finalized.
type tableClass struct {
	native unsafe.Pointer
}

var GIRInfoTableClass = girepository.MustFind("Gtk", "TableClass")

// TableRowCol: instance of this type is always passed by reference.
type TableRowCol struct {
	*tableRowCol
}

// tableRowCol is the struct that's finalized.
type tableRowCol struct {
	native unsafe.Pointer
}

var GIRInfoTableRowCol = girepository.MustFind("Gtk", "TableRowCol")

func (t *TableRowCol) Requisition() uint16 {
	offset := GIRInfoTableRowCol.StructFieldOffset("requisition")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableRowCol) Allocation() uint16 {
	offset := GIRInfoTableRowCol.StructFieldOffset("allocation")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableRowCol) Spacing() uint16 {
	offset := GIRInfoTableRowCol.StructFieldOffset("spacing")
	valptr := (*uint16)(unsafe.Add(t.native, offset))
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

func (t *TableRowCol) SetRequisition(requisition uint16) {
	offset := GIRInfoTableRowCol.StructFieldOffset("requisition")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(requisition)
}

func (t *TableRowCol) SetAllocation(allocation uint16) {
	offset := GIRInfoTableRowCol.StructFieldOffset("allocation")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(allocation)
}

func (t *TableRowCol) SetSpacing(spacing uint16) {
	offset := GIRInfoTableRowCol.StructFieldOffset("spacing")
	valptr := (*C.guint16)(unsafe.Add(t.native, offset))
	*valptr = C.guint16(spacing)
}
