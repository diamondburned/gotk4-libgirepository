// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void* _gotk4_gtk3_Notebook_ConnectCreateWindow(gpointer, void*, gint, gint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectSwitchPage(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectPageReordered(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectPageRemoved(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectPageAdded(gpointer, void*, guint, guintptr);
// extern gboolean _gotk4_gtk3_Notebook_ConnectSelectPage(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_Notebook_ConnectChangeCurrentPage(gpointer, gint, guintptr);
import "C"

// GType values.
var (
	GTypeNotebook = coreglib.Type(girepository.MustFind("Gtk", "Notebook").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNotebook, F: marshalNotebook},
	})
}

// NotebookOverrides contains methods that are overridable.
type NotebookOverrides struct {
}

func defaultNotebookOverrides(v *Notebook) NotebookOverrides {
	return NotebookOverrides{}
}

// Notebook widget is a Container whose children are pages that can be switched
// between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
// GtkNotebook has a main CSS node with name notebook, a subnode with name
// header and below that a subnode with name tabs which contains one subnode per
// tab with name tab.
//
// If action widgets are present, their CSS nodes are placed next to the tabs
// node. If the notebook is scrollable, CSS nodes with name arrow are placed as
// first and last child of the tabs node.
//
// The main node gets the .frame style class when the notebook has a border (see
// gtk_notebook_set_show_border()).
//
// The header node gets one of the style class .top, .bottom, .left or .right,
// depending on where the tabs are placed. For reorderable pages, the tab node
// gets the .reorderable-page class.
//
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regarldess of text
// direction.
type Notebook struct {
	_ [0]func() // equal guard
	Container
}

var (
	_ Containerer = (*Notebook)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Notebook, *NotebookClass, NotebookOverrides](
		GTypeNotebook,
		initNotebookClass,
		wrapNotebook,
		defaultNotebookOverrides,
	)
}

func initNotebookClass(gclass unsafe.Pointer, overrides NotebookOverrides, classInitFunc func(*NotebookClass)) {
	if classInitFunc != nil {
		class := (*NotebookClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNotebook(obj *coreglib.Object) *Notebook {
	return &Notebook{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	return wrapNotebook(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Notebook) ConnectChangeCurrentPage(f func(object int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "change-current-page", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectChangeCurrentPage), f)
}

// ConnectCreateWindow signal is emitted when a detachable tab is dropped on the
// root window.
//
// A handler for this signal can create a window containing a notebook where the
// tab will be attached. It is also responsible for moving/resizing the window
// and adding the necessary properties to the notebook (e.g. the
// Notebook:group-name ).
func (v *Notebook) ConnectCreateWindow(f func(page Widgetter, x, y int) (notebook *Notebook)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "create-window", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectCreateWindow), f)
}

// ConnectPageAdded signal is emitted in the notebook right after a page is
// added to the notebook.
func (v *Notebook) ConnectPageAdded(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-added", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectPageAdded), f)
}

// ConnectPageRemoved signal is emitted in the notebook right after a page is
// removed from the notebook.
func (v *Notebook) ConnectPageRemoved(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-removed", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectPageRemoved), f)
}

// ConnectPageReordered signal is emitted in the notebook right after a page has
// been reordered.
func (v *Notebook) ConnectPageReordered(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "page-reordered", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectPageReordered), f)
}

func (v *Notebook) ConnectSelectPage(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select-page", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectSelectPage), f)
}

// ConnectSwitchPage is emitted when the user or a function changes the current
// page.
func (v *Notebook) ConnectSwitchPage(f func(page Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "switch-page", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectSwitchPage), f)
}

// NotebookClass: instance of this type is always passed by reference.
type NotebookClass struct {
	*notebookClass
}

// notebookClass is the struct that's finalized.
type notebookClass struct {
	native unsafe.Pointer
}

var GIRInfoNotebookClass = girepository.MustFind("Gtk", "NotebookClass")
