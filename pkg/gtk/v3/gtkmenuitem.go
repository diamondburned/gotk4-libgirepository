// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_MenuItem_ConnectToggleSizeRequest(gpointer, gpointer, guintptr);
// extern void _gotk4_gtk3_MenuItem_ConnectToggleSizeAllocate(gpointer, gint, guintptr);
// extern void _gotk4_gtk3_MenuItem_ConnectSelect(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuItem_ConnectDeselect(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuItem_ConnectActivateItem(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuItem_ConnectActivate(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeMenuItem = coreglib.Type(girepository.MustFind("Gtk", "MenuItem").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMenuItem, F: marshalMenuItem},
	})
}

// MenuItemOverrides contains methods that are overridable.
type MenuItemOverrides struct {
}

func defaultMenuItemOverrides(v *MenuItem) MenuItemOverrides {
	return MenuItemOverrides{}
}

// MenuItem widget and the derived widgets are the only valid children for
// menus. Their function is to correctly handle highlighting, alignment, events
// and submenus.
//
// As a GtkMenuItem derives from Bin it can hold any valid child widget,
// although only a few are really useful.
//
// By default, a GtkMenuItem sets a AccelLabel as its child. GtkMenuItem has
// direct functions to set the label and its mnemonic. For more advanced label
// settings, you can fetch the child widget from the GtkBin.
//
// An example for setting markup and accelerator on a MenuItem:
//
//    menuitem
//    ├── <child>
//    ╰── [arrow.right]
//
// GtkMenuItem has a single CSS node with name menuitem. If the menuitem has a
// submenu, it gets another CSS node with name arrow, which has the .left or
// .right style class.
type MenuItem struct {
	_ [0]func() // equal guard
	Bin

	*coreglib.Object
	Actionable
	Activatable
}

var (
	_ Binner            = (*MenuItem)(nil)
	_ coreglib.Objector = (*MenuItem)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MenuItem, *MenuItemClass, MenuItemOverrides](
		GTypeMenuItem,
		initMenuItemClass,
		wrapMenuItem,
		defaultMenuItemOverrides,
	)
}

func initMenuItemClass(gclass unsafe.Pointer, overrides MenuItemOverrides, classInitFunc func(*MenuItemClass)) {
	if classInitFunc != nil {
		class := (*MenuItemClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenuItem(obj *coreglib.Object) *MenuItem {
	return &MenuItem{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
		Object: obj,
		Actionable: Actionable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Activatable: Activatable{
			Object: obj,
		},
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	return wrapMenuItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the item is activated.
func (v *MenuItem) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gtk3_MenuItem_ConnectActivate), f)
}

// ConnectActivateItem is emitted when the item is activated, but also if the
// menu item has a submenu. For normal applications, the relevant signal is
// MenuItem::activate.
func (v *MenuItem) ConnectActivateItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate-item", false, unsafe.Pointer(C._gotk4_gtk3_MenuItem_ConnectActivateItem), f)
}

func (v *MenuItem) ConnectDeselect(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "deselect", false, unsafe.Pointer(C._gotk4_gtk3_MenuItem_ConnectDeselect), f)
}

func (v *MenuItem) ConnectSelect(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "select", false, unsafe.Pointer(C._gotk4_gtk3_MenuItem_ConnectSelect), f)
}

func (v *MenuItem) ConnectToggleSizeAllocate(f func(object int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-size-allocate", false, unsafe.Pointer(C._gotk4_gtk3_MenuItem_ConnectToggleSizeAllocate), f)
}

func (v *MenuItem) ConnectToggleSizeRequest(f func(object unsafe.Pointer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-size-request", false, unsafe.Pointer(C._gotk4_gtk3_MenuItem_ConnectToggleSizeRequest), f)
}

// MenuItemClass: instance of this type is always passed by reference.
type MenuItemClass struct {
	*menuItemClass
}

// menuItemClass is the struct that's finalized.
type menuItemClass struct {
	native unsafe.Pointer
}

var GIRInfoMenuItemClass = girepository.MustFind("Gtk", "MenuItemClass")
