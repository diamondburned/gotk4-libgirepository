// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeOrientable = coreglib.Type(girepository.MustFind("Gtk", "Orientable").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeOrientable, F: marshalOrientable},
	})
}

// OrientableOverrider contains methods that are overridable.
type OrientableOverrider interface {
}

// Orientable interface is implemented by all widgets that can be oriented
// horizontally or vertically. Historically, such widgets have been realized as
// subclasses of a common base class (e.g Box/HBox/VBox or Scale/HScale/VScale).
// Orientable is more flexible in that it allows the orientation to be changed
// at runtime, allowing the widgets to “flip”.
//
// Orientable was introduced in GTK+ 2.16.
//
// Orientable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Orientable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Orientable)(nil)
)

// Orientabler describes Orientable's interface methods.
type Orientabler interface {
	coreglib.Objector

	baseOrientable() *Orientable
}

var _ Orientabler = (*Orientable)(nil)

func ifaceInitOrientabler(gifacePtr, data C.gpointer) {
}

func wrapOrientable(obj *coreglib.Object) *Orientable {
	return &Orientable{
		Object: obj,
	}
}

func marshalOrientable(p uintptr) (interface{}, error) {
	return wrapOrientable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Orientable) baseOrientable() *Orientable {
	return v
}

// BaseOrientable returns the underlying base object.
func BaseOrientable(obj Orientabler) *Orientable {
	return obj.baseOrientable()
}

// OrientableIface: instance of this type is always passed by reference.
type OrientableIface struct {
	*orientableIface
}

// orientableIface is the struct that's finalized.
type orientableIface struct {
	native unsafe.Pointer
}

var GIRInfoOrientableIface = girepository.MustFind("Gtk", "OrientableIface")
