// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_UIManager_ConnectPreActivate(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_UIManager_ConnectPostActivate(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_UIManager_ConnectDisconnectProxy(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk3_UIManager_ConnectConnectProxy(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk3_UIManager_ConnectAddWidget(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_UIManager_ConnectActionsChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeUIManagerItemType = coreglib.Type(girepository.MustFind("Gtk", "UIManagerItemType").RegisteredGType())
	GTypeUIManager         = coreglib.Type(girepository.MustFind("Gtk", "UIManager").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeUIManagerItemType, F: marshalUIManagerItemType},
		coreglib.TypeMarshaler{T: GTypeUIManager, F: marshalUIManager},
	})
}

// UIManagerItemType: these enumeration values are used by
// gtk_ui_manager_add_ui() to determine what UI element to create.
//
// Deprecated: since version 3.10.
type UIManagerItemType C.guint

const (
	// UiManagerAuto: pick the type of the UI element according to context.
	UiManagerAuto UIManagerItemType = 0b0
	// UiManagerMenubar: create a menubar.
	UiManagerMenubar UIManagerItemType = 0b1
	// UiManagerMenu: create a menu.
	UiManagerMenu UIManagerItemType = 0b10
	// UiManagerToolbar: create a toolbar.
	UiManagerToolbar UIManagerItemType = 0b100
	// UiManagerPlaceholder: insert a placeholder.
	UiManagerPlaceholder UIManagerItemType = 0b1000
	// UiManagerPopup: create a popup menu.
	UiManagerPopup UIManagerItemType = 0b10000
	// UiManagerMenuitem: create a menuitem.
	UiManagerMenuitem UIManagerItemType = 0b100000
	// UiManagerToolitem: create a toolitem.
	UiManagerToolitem UIManagerItemType = 0b1000000
	// UiManagerSeparator: create a separator.
	UiManagerSeparator UIManagerItemType = 0b10000000
	// UiManagerAccelerator: install an accelerator.
	UiManagerAccelerator UIManagerItemType = 0b100000000
	// UiManagerPopupWithAccels: same as GTK_UI_MANAGER_POPUP, but the actions’
	// accelerators are shown.
	UiManagerPopupWithAccels UIManagerItemType = 0b1000000000
)

func marshalUIManagerItemType(p uintptr) (interface{}, error) {
	return UIManagerItemType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for UIManagerItemType.
func (u UIManagerItemType) String() string {
	if u == 0 {
		return "UIManagerItemType(0)"
	}

	var builder strings.Builder
	builder.Grow(198)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case UiManagerAuto:
			builder.WriteString("Auto|")
		case UiManagerMenubar:
			builder.WriteString("Menubar|")
		case UiManagerMenu:
			builder.WriteString("Menu|")
		case UiManagerToolbar:
			builder.WriteString("Toolbar|")
		case UiManagerPlaceholder:
			builder.WriteString("Placeholder|")
		case UiManagerPopup:
			builder.WriteString("Popup|")
		case UiManagerMenuitem:
			builder.WriteString("Menuitem|")
		case UiManagerToolitem:
			builder.WriteString("Toolitem|")
		case UiManagerSeparator:
			builder.WriteString("Separator|")
		case UiManagerAccelerator:
			builder.WriteString("Accelerator|")
		case UiManagerPopupWithAccels:
			builder.WriteString("PopupWithAccels|")
		default:
			builder.WriteString(fmt.Sprintf("UIManagerItemType(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u UIManagerItemType) Has(other UIManagerItemType) bool {
	return (u & other) == other
}

// UIManagerOverrides contains methods that are overridable.
type UIManagerOverrides struct {
}

func defaultUIManagerOverrides(v *UIManager) UIManagerOverrides {
	return UIManagerOverrides{}
}

// UIManager: > GtkUIManager is deprecated since GTK+ 3.10. To construct user
// interfaces > from XML definitions, you should use Builder, Model, et al. To >
// work with actions, use #GAction, Actionable et al. These newer classes >
// support richer functionality and integration with various desktop shells. >
// It should be possible to migrate most/all functionality from GtkUIManager.
//
// A UIManager constructs a user interface (menus and toolbars) from one or more
// UI definitions, which reference actions from one or more action groups.
//
//
// UI Definitions
//
// The UI definitions are specified in an XML format which can be roughly
// described by the following DTD.
//
// > Do not confuse the GtkUIManager UI Definitions described here with > the
// similarly named [GtkBuilder UI Definitions][BUILDER-UI].
//
//    <!ELEMENT ui          (menubar|toolbar|popup|accelerator)* >
//    <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
//    <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
//    <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
//    <!ELEMENT menuitem     EMPTY >
//    <!ELEMENT toolitem     (menu?) >
//    <!ELEMENT separator    EMPTY >
//    <!ELEMENT accelerator  EMPTY >
//    <!ATTLIST menubar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST toolbar      name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST popup        name                      PLIED
//                           action                    PLIED
//                           accelerators (true|false) PLIED >
//    <!ATTLIST placeholder  name                      PLIED
//                           action                    PLIED >
//    <!ATTLIST separator    name                      PLIED
//                           action                    PLIED
//                           expand       (true|false) PLIED >
//    <!ATTLIST menu         name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST menuitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED
//                           always-show-image (true|false) PLIED >
//    <!ATTLIST toolitem     name                      PLIED
//                           action                    QUIRED
//                           position     (top|bot)    PLIED >
//    <!ATTLIST accelerator  name                      PLIED
//                           action                    QUIRED >
//
// There are some additional restrictions beyond those specified in the DTD,
// e.g. every toolitem must have a toolbar in its anchestry and every menuitem
// must have a menubar or popup in its anchestry. Since a Parser is used to
// parse the UI description, it must not only be valid XML, but valid markup.
//
// If a name is not specified, it defaults to the action. If an action is not
// specified either, the element name is used. The name and action attributes
// must not contain “/” characters after parsing (since that would mess up path
// lookup) and must be usable as XML attributes when enclosed in doublequotes,
// thus they must not “"” characters or references to the &quot; entity.
//
// A UI definition #
//
//    <ui>
//      <menubar>
//        <menu name="FileMenu" action="FileMenuAction">
//          <menuitem name="New" action="New2Action" />
//          <placeholder name="FileMenuAdditions" />
//        </menu>
//        <menu name="JustifyMenu" action="JustifyMenuAction">
//          <menuitem name="Left" action="justify-left"/>
//          <menuitem name="Centre" action="justify-center"/>
//          <menuitem name="Right" action="justify-right"/>
//          <menuitem name="Fill" action="justify-fill"/>
//        </menu>
//      </menubar>
//      <toolbar action="toolbar1">
//        <placeholder name="JustifyToolItems">
//          <separator/>
//          <toolitem name="Left" action="justify-left"/>
//          <toolitem name="Centre" action="justify-center"/>
//          <toolitem name="Right" action="justify-right"/>
//          <toolitem name="Fill" action="justify-fill"/>
//          <separator/>
//        </placeholder>
//      </toolbar>
//    </ui>
//
// The constructed widget hierarchy is very similar to the element tree of the
// XML, with the exception that placeholders are merged into their parents. The
// correspondence of XML elements to widgets should be almost obvious:
//
// - menubar
//
//    a MenuBar
//
// - toolbar
//
//    a Toolbar
//
// - popup
//
//    a toplevel Menu
//
// - menu
//
//    a Menu attached to a menuitem
//
// - menuitem
//
//    a MenuItem subclass, the exact type depends on the action
//
// - toolitem
//
//    a ToolItem subclass, the exact type depends on the
//    action. Note that toolitem elements may contain a menu element,
//    but only if their associated action specifies a
//    MenuToolButton as proxy.
//
// - separator
//
//    a SeparatorMenuItem or SeparatorToolItem
//
// - accelerator
//
//    a keyboard accelerator
//
// The “position” attribute determines where a constructed widget is positioned
// wrt. to its siblings in the partially constructed tree. If it is “top”, the
// widget is prepended, otherwise it is appended.
//
//
// UI Merging
//
// The most remarkable feature of UIManager is that it can overlay a set of
// menuitems and toolitems over another one, and demerge them later.
//
// Merging is done based on the names of the XML elements. Each element is
// identified by a path which consists of the names of its anchestors, separated
// by slashes. For example, the menuitem named “Left” in the example above has
// the path /ui/menubar/JustifyMenu/Left and the toolitem with the same name has
// path /ui/toolbar1/JustifyToolItems/Left.
//
// Accelerators #
//
// Every action has an accelerator path. Accelerators are installed together
// with menuitem proxies, but they can also be explicitly added with
// <accelerator> elements in the UI definition. This makes it possible to have
// accelerators for actions even if they have no visible proxies.
//
//
// Smart Separators
//
// The separators created by UIManager are “smart”, i.e. they do not show up in
// the UI unless they end up between two visible menu or tool items. Separators
// which are located at the very beginning or end of the menu or toolbar
// containing them, or multiple separators next to each other, are hidden. This
// is a useful feature, since the merging of UI elements from multiple sources
// can make it hard or impossible to determine in advance whether a separator
// will end up in such an unfortunate position.
//
// For separators in toolbars, you can set expand="true" to turn them from a
// small, visible separator to an expanding, invisible one. Toolitems following
// an expanding separator are effectively right-aligned.
//
//
// Empty Menus
//
// Submenus pose similar problems to separators inconnection with merging. It is
// impossible to know in advance whether they will end up empty after merging.
// UIManager offers two ways to treat empty submenus:
//
// - make them disappear by hiding the menu item they’re attached to
//
// - add an insensitive “Empty” item
//
// The behaviour is chosen based on the “hide_if_empty” property of the action
// to which the submenu is associated.
//
//
// GtkUIManager as GtkBuildable
//
// The GtkUIManager implementation of the GtkBuildable interface accepts
// GtkActionGroup objects as <child> elements in UI definitions.
//
// A GtkUIManager UI definition as described above can be embedded in an
// GtkUIManager <object> element in a GtkBuilder UI definition.
//
// The widgets that are constructed by a GtkUIManager can be embedded in other
// parts of the constructed user interface with the help of the “constructor”
// attribute. See the example below.
//
// An embedded GtkUIManager UI definition
//
//    <object class="GtkUIManager" id="uiman">
//      <child>
//        <object class="GtkActionGroup" id="actiongroup">
//          <child>
//            <object class="GtkAction" id="file">
//              <property name="label">_File</property>
//            </object>
//          </child>
//        </object>
//      </child>
//      <ui>
//        <menubar name="menubar1">
//          <menu action="file">
//          </menu>
//        </menubar>
//      </ui>
//    </object>
//    <object class="GtkWindow" id="main-window">
//      <child>
//        <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
//      </child>
//    </object>.
type UIManager struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*UIManager)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*UIManager, *UIManagerClass, UIManagerOverrides](
		GTypeUIManager,
		initUIManagerClass,
		wrapUIManager,
		defaultUIManagerOverrides,
	)
}

func initUIManagerClass(gclass unsafe.Pointer, overrides UIManagerOverrides, classInitFunc func(*UIManagerClass)) {
	if classInitFunc != nil {
		class := (*UIManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapUIManager(obj *coreglib.Object) *UIManager {
	return &UIManager{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalUIManager(p uintptr) (interface{}, error) {
	return wrapUIManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActionsChanged signal is emitted whenever the set of actions changes.
func (v *UIManager) ConnectActionsChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "actions-changed", false, unsafe.Pointer(C._gotk4_gtk3_UIManager_ConnectActionsChanged), f)
}

// ConnectAddWidget signal is emitted for each generated menubar and toolbar. It
// is not emitted for generated popup menus, which can be obtained by
// gtk_ui_manager_get_widget().
func (v *UIManager) ConnectAddWidget(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "add-widget", false, unsafe.Pointer(C._gotk4_gtk3_UIManager_ConnectAddWidget), f)
}

// ConnectConnectProxy signal is emitted after connecting a proxy to an action
// in the group.
//
// This is intended for simple customizations for which a custom action class
// would be too clumsy, e.g. showing tooltips for menuitems in the statusbar.
func (v *UIManager) ConnectConnectProxy(f func(action *Action, proxy Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "connect-proxy", false, unsafe.Pointer(C._gotk4_gtk3_UIManager_ConnectConnectProxy), f)
}

// ConnectDisconnectProxy signal is emitted after disconnecting a proxy from an
// action in the group.
func (v *UIManager) ConnectDisconnectProxy(f func(action *Action, proxy Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "disconnect-proxy", false, unsafe.Pointer(C._gotk4_gtk3_UIManager_ConnectDisconnectProxy), f)
}

// ConnectPostActivate signal is emitted just after the action is activated.
//
// This is intended for applications to get notification just after any action
// is activated.
func (v *UIManager) ConnectPostActivate(f func(action *Action)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "post-activate", false, unsafe.Pointer(C._gotk4_gtk3_UIManager_ConnectPostActivate), f)
}

// ConnectPreActivate signal is emitted just before the action is activated.
//
// This is intended for applications to get notification just before any action
// is activated.
func (v *UIManager) ConnectPreActivate(f func(action *Action)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "pre-activate", false, unsafe.Pointer(C._gotk4_gtk3_UIManager_ConnectPreActivate), f)
}

// UIManagerClass: instance of this type is always passed by reference.
type UIManagerClass struct {
	*uiManagerClass
}

// uiManagerClass is the struct that's finalized.
type uiManagerClass struct {
	native unsafe.Pointer
}

var GIRInfoUIManagerClass = girepository.MustFind("Gtk", "UIManagerClass")
