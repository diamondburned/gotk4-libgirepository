// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeIconSet       = coreglib.Type(girepository.MustFind("Gtk", "IconSet").RegisteredGType())
	GTypeIconSource    = coreglib.Type(girepository.MustFind("Gtk", "IconSource").RegisteredGType())
	GTypeSelectionData = coreglib.Type(girepository.MustFind("Gtk", "SelectionData").RegisteredGType())
	GTypeWidgetPath    = coreglib.Type(girepository.MustFind("Gtk", "WidgetPath").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIconSet, F: marshalIconSet},
		coreglib.TypeMarshaler{T: GTypeIconSource, F: marshalIconSource},
		coreglib.TypeMarshaler{T: GTypeSelectionData, F: marshalSelectionData},
		coreglib.TypeMarshaler{T: GTypeWidgetPath, F: marshalWidgetPath},
	})
}

// IconSet: instance of this type is always passed by reference.
type IconSet struct {
	*iconSet
}

// iconSet is the struct that's finalized.
type iconSet struct {
	native unsafe.Pointer
}

var GIRInfoIconSet = girepository.MustFind("Gtk", "IconSet")

func marshalIconSet(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IconSet{&iconSet{(unsafe.Pointer)(b)}}, nil
}

// IconSource: instance of this type is always passed by reference.
type IconSource struct {
	*iconSource
}

// iconSource is the struct that's finalized.
type iconSource struct {
	native unsafe.Pointer
}

var GIRInfoIconSource = girepository.MustFind("Gtk", "IconSource")

func marshalIconSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IconSource{&iconSource{(unsafe.Pointer)(b)}}, nil
}

// SelectionData: instance of this type is always passed by reference.
type SelectionData struct {
	*selectionData
}

// selectionData is the struct that's finalized.
type selectionData struct {
	native unsafe.Pointer
}

var GIRInfoSelectionData = girepository.MustFind("Gtk", "SelectionData")

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SelectionData{&selectionData{(unsafe.Pointer)(b)}}, nil
}

// WidgetPath is a boxed type that represents a widget hierarchy from the
// topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
//
// An instance of this type is always passed by reference.
type WidgetPath struct {
	*widgetPath
}

// widgetPath is the struct that's finalized.
type widgetPath struct {
	native unsafe.Pointer
}

var GIRInfoWidgetPath = girepository.MustFind("Gtk", "WidgetPath")

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &WidgetPath{&widgetPath{(unsafe.Pointer)(b)}}, nil
}
