// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAlign             = coreglib.Type(girepository.MustFind("Gtk", "Align").RegisteredGType())
	GTypeArrowType         = coreglib.Type(girepository.MustFind("Gtk", "ArrowType").RegisteredGType())
	GTypeBorderStyle       = coreglib.Type(girepository.MustFind("Gtk", "BorderStyle").RegisteredGType())
	GTypeDeleteType        = coreglib.Type(girepository.MustFind("Gtk", "DeleteType").RegisteredGType())
	GTypeDirectionType     = coreglib.Type(girepository.MustFind("Gtk", "DirectionType").RegisteredGType())
	GTypeDragResult        = coreglib.Type(girepository.MustFind("Gtk", "DragResult").RegisteredGType())
	GTypeIMPreeditStyle    = coreglib.Type(girepository.MustFind("Gtk", "IMPreeditStyle").RegisteredGType())
	GTypeIMStatusStyle     = coreglib.Type(girepository.MustFind("Gtk", "IMStatusStyle").RegisteredGType())
	GTypeIconSize          = coreglib.Type(girepository.MustFind("Gtk", "IconSize").RegisteredGType())
	GTypeJustification     = coreglib.Type(girepository.MustFind("Gtk", "Justification").RegisteredGType())
	GTypeMenuDirectionType = coreglib.Type(girepository.MustFind("Gtk", "MenuDirectionType").RegisteredGType())
	GTypeMessageType       = coreglib.Type(girepository.MustFind("Gtk", "MessageType").RegisteredGType())
	GTypeNumberUpLayout    = coreglib.Type(girepository.MustFind("Gtk", "NumberUpLayout").RegisteredGType())
	GTypeOrientation       = coreglib.Type(girepository.MustFind("Gtk", "Orientation").RegisteredGType())
	GTypePackDirection     = coreglib.Type(girepository.MustFind("Gtk", "PackDirection").RegisteredGType())
	GTypePackType          = coreglib.Type(girepository.MustFind("Gtk", "PackType").RegisteredGType())
	GTypePageOrientation   = coreglib.Type(girepository.MustFind("Gtk", "PageOrientation").RegisteredGType())
	GTypePageSet           = coreglib.Type(girepository.MustFind("Gtk", "PageSet").RegisteredGType())
	GTypePositionType      = coreglib.Type(girepository.MustFind("Gtk", "PositionType").RegisteredGType())
	GTypePrintDuplex       = coreglib.Type(girepository.MustFind("Gtk", "PrintDuplex").RegisteredGType())
	GTypePrintPages        = coreglib.Type(girepository.MustFind("Gtk", "PrintPages").RegisteredGType())
	GTypePrintQuality      = coreglib.Type(girepository.MustFind("Gtk", "PrintQuality").RegisteredGType())
	GTypeReliefStyle       = coreglib.Type(girepository.MustFind("Gtk", "ReliefStyle").RegisteredGType())
	GTypeScrollType        = coreglib.Type(girepository.MustFind("Gtk", "ScrollType").RegisteredGType())
	GTypeScrollablePolicy  = coreglib.Type(girepository.MustFind("Gtk", "ScrollablePolicy").RegisteredGType())
	GTypeSelectionMode     = coreglib.Type(girepository.MustFind("Gtk", "SelectionMode").RegisteredGType())
	GTypeSensitivityType   = coreglib.Type(girepository.MustFind("Gtk", "SensitivityType").RegisteredGType())
	GTypeShadowType        = coreglib.Type(girepository.MustFind("Gtk", "ShadowType").RegisteredGType())
	GTypeSizeGroupMode     = coreglib.Type(girepository.MustFind("Gtk", "SizeGroupMode").RegisteredGType())
	GTypeSizeRequestMode   = coreglib.Type(girepository.MustFind("Gtk", "SizeRequestMode").RegisteredGType())
	GTypeSortType          = coreglib.Type(girepository.MustFind("Gtk", "SortType").RegisteredGType())
	GTypeStateType         = coreglib.Type(girepository.MustFind("Gtk", "StateType").RegisteredGType())
	GTypeTextDirection     = coreglib.Type(girepository.MustFind("Gtk", "TextDirection").RegisteredGType())
	GTypeToolbarStyle      = coreglib.Type(girepository.MustFind("Gtk", "ToolbarStyle").RegisteredGType())
	GTypeTreeViewGridLines = coreglib.Type(girepository.MustFind("Gtk", "TreeViewGridLines").RegisteredGType())
	GTypeUnit              = coreglib.Type(girepository.MustFind("Gtk", "Unit").RegisteredGType())
	GTypeWrapMode          = coreglib.Type(girepository.MustFind("Gtk", "WrapMode").RegisteredGType())
	GTypeJunctionSides     = coreglib.Type(girepository.MustFind("Gtk", "JunctionSides").RegisteredGType())
	GTypeRegionFlags       = coreglib.Type(girepository.MustFind("Gtk", "RegionFlags").RegisteredGType())
	GTypeStateFlags        = coreglib.Type(girepository.MustFind("Gtk", "StateFlags").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAlign, F: marshalAlign},
		coreglib.TypeMarshaler{T: GTypeArrowType, F: marshalArrowType},
		coreglib.TypeMarshaler{T: GTypeBorderStyle, F: marshalBorderStyle},
		coreglib.TypeMarshaler{T: GTypeDeleteType, F: marshalDeleteType},
		coreglib.TypeMarshaler{T: GTypeDirectionType, F: marshalDirectionType},
		coreglib.TypeMarshaler{T: GTypeDragResult, F: marshalDragResult},
		coreglib.TypeMarshaler{T: GTypeIMPreeditStyle, F: marshalIMPreeditStyle},
		coreglib.TypeMarshaler{T: GTypeIMStatusStyle, F: marshalIMStatusStyle},
		coreglib.TypeMarshaler{T: GTypeIconSize, F: marshalIconSize},
		coreglib.TypeMarshaler{T: GTypeJustification, F: marshalJustification},
		coreglib.TypeMarshaler{T: GTypeMenuDirectionType, F: marshalMenuDirectionType},
		coreglib.TypeMarshaler{T: GTypeMessageType, F: marshalMessageType},
		coreglib.TypeMarshaler{T: GTypeNumberUpLayout, F: marshalNumberUpLayout},
		coreglib.TypeMarshaler{T: GTypeOrientation, F: marshalOrientation},
		coreglib.TypeMarshaler{T: GTypePackDirection, F: marshalPackDirection},
		coreglib.TypeMarshaler{T: GTypePackType, F: marshalPackType},
		coreglib.TypeMarshaler{T: GTypePageOrientation, F: marshalPageOrientation},
		coreglib.TypeMarshaler{T: GTypePageSet, F: marshalPageSet},
		coreglib.TypeMarshaler{T: GTypePositionType, F: marshalPositionType},
		coreglib.TypeMarshaler{T: GTypePrintDuplex, F: marshalPrintDuplex},
		coreglib.TypeMarshaler{T: GTypePrintPages, F: marshalPrintPages},
		coreglib.TypeMarshaler{T: GTypePrintQuality, F: marshalPrintQuality},
		coreglib.TypeMarshaler{T: GTypeReliefStyle, F: marshalReliefStyle},
		coreglib.TypeMarshaler{T: GTypeScrollType, F: marshalScrollType},
		coreglib.TypeMarshaler{T: GTypeScrollablePolicy, F: marshalScrollablePolicy},
		coreglib.TypeMarshaler{T: GTypeSelectionMode, F: marshalSelectionMode},
		coreglib.TypeMarshaler{T: GTypeSensitivityType, F: marshalSensitivityType},
		coreglib.TypeMarshaler{T: GTypeShadowType, F: marshalShadowType},
		coreglib.TypeMarshaler{T: GTypeSizeGroupMode, F: marshalSizeGroupMode},
		coreglib.TypeMarshaler{T: GTypeSizeRequestMode, F: marshalSizeRequestMode},
		coreglib.TypeMarshaler{T: GTypeSortType, F: marshalSortType},
		coreglib.TypeMarshaler{T: GTypeStateType, F: marshalStateType},
		coreglib.TypeMarshaler{T: GTypeTextDirection, F: marshalTextDirection},
		coreglib.TypeMarshaler{T: GTypeToolbarStyle, F: marshalToolbarStyle},
		coreglib.TypeMarshaler{T: GTypeTreeViewGridLines, F: marshalTreeViewGridLines},
		coreglib.TypeMarshaler{T: GTypeUnit, F: marshalUnit},
		coreglib.TypeMarshaler{T: GTypeWrapMode, F: marshalWrapMode},
		coreglib.TypeMarshaler{T: GTypeJunctionSides, F: marshalJunctionSides},
		coreglib.TypeMarshaler{T: GTypeRegionFlags, F: marshalRegionFlags},
		coreglib.TypeMarshaler{T: GTypeStateFlags, F: marshalStateFlags},
	})
}

// Align controls how a widget deals with extra space in a single (x or y)
// dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the Widget:expand flag inside a Box,
// then the widget might get extra space. If you have for example a 16x16 icon
// inside a 32x32 space, the icon could be scaled and stretched, it could be
// centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support for it is optional for containers and widgets, and
// it is only supported for vertical alignment. When its not supported by a
// child or a container it is treated as GTK_ALIGN_FILL.
type Align C.gint

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch.
	AlignFill Align = iota
	// AlignStart: snap to left or top side, leaving space on right or bottom.
	AlignStart
	// AlignEnd: snap to right or bottom side, leaving space on left or top.
	AlignEnd
	// AlignCenter: center natural width of widget inside the allocation.
	AlignCenter
	// AlignBaseline: align the widget according to the baseline. Since 3.10.
	AlignBaseline
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Align.
func (a Align) String() string {
	switch a {
	case AlignFill:
		return "Fill"
	case AlignStart:
		return "Start"
	case AlignEnd:
		return "End"
	case AlignCenter:
		return "Center"
	case AlignBaseline:
		return "Baseline"
	default:
		return fmt.Sprintf("Align(%d)", a)
	}
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType C.gint

const (
	// ArrowUp represents an upward pointing arrow.
	ArrowUp ArrowType = iota
	// ArrowDown represents a downward pointing arrow.
	ArrowDown
	// ArrowLeft represents a left pointing arrow.
	ArrowLeft
	// ArrowRight represents a right pointing arrow.
	ArrowRight
	// ArrowNone: no arrow. Since 2.10.
	ArrowNone
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ArrowType.
func (a ArrowType) String() string {
	switch a {
	case ArrowUp:
		return "Up"
	case ArrowDown:
		return "Down"
	case ArrowLeft:
		return "Left"
	case ArrowRight:
		return "Right"
	case ArrowNone:
		return "None"
	default:
		return fmt.Sprintf("ArrowType(%d)", a)
	}
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle C.gint

const (
	// BorderStyleNone: no visible border.
	BorderStyleNone BorderStyle = iota
	// BorderStyleSolid: single line segment.
	BorderStyleSolid
	// BorderStyleInset looks as if the content is sunken into the canvas.
	BorderStyleInset
	// BorderStyleOutset looks as if the content is coming out of the canvas.
	BorderStyleOutset
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE.
	BorderStyleHidden
	// BorderStyleDotted series of round dots.
	BorderStyleDotted
	// BorderStyleDashed series of square-ended dashes.
	BorderStyleDashed
	// BorderStyleDouble: two parallel lines with some space between them.
	BorderStyleDouble
	// BorderStyleGroove looks as if it were carved in the canvas.
	BorderStyleGroove
	// BorderStyleRidge looks as if it were coming out of the canvas.
	BorderStyleRidge
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BorderStyle.
func (b BorderStyle) String() string {
	switch b {
	case BorderStyleNone:
		return "None"
	case BorderStyleSolid:
		return "Solid"
	case BorderStyleInset:
		return "Inset"
	case BorderStyleOutset:
		return "Outset"
	case BorderStyleHidden:
		return "Hidden"
	case BorderStyleDotted:
		return "Dotted"
	case BorderStyleDashed:
		return "Dashed"
	case BorderStyleDouble:
		return "Double"
	case BorderStyleGroove:
		return "Groove"
	case BorderStyleRidge:
		return "Ridge"
	default:
		return fmt.Sprintf("BorderStyle(%d)", b)
	}
}

// DeleteType: see also: Entry::delete-from-cursor.
type DeleteType C.gint

const (
	// DeleteChars: delete characters.
	DeleteChars DeleteType = iota
	// DeleteWordEnds: delete only the portion of the word to the left/right of
	// cursor if we’re in the middle of a word.
	DeleteWordEnds
	// DeleteWords: delete words.
	DeleteWords
	// DeleteDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteDisplayLines
	// DeleteDisplayLineEnds: delete only the portion of the display-line to the
	// left/right of cursor.
	DeleteDisplayLineEnds
	// DeleteParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteParagraphEnds
	// DeleteParagraphs: delete entire line. Like C-k in pico.
	DeleteParagraphs
	// DeleteWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteWhitespace
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DeleteType.
func (d DeleteType) String() string {
	switch d {
	case DeleteChars:
		return "Chars"
	case DeleteWordEnds:
		return "WordEnds"
	case DeleteWords:
		return "Words"
	case DeleteDisplayLines:
		return "DisplayLines"
	case DeleteDisplayLineEnds:
		return "DisplayLineEnds"
	case DeleteParagraphEnds:
		return "ParagraphEnds"
	case DeleteParagraphs:
		return "Paragraphs"
	case DeleteWhitespace:
		return "Whitespace"
	default:
		return fmt.Sprintf("DeleteType(%d)", d)
	}
}

// DirectionType focus movement types.
type DirectionType C.gint

const (
	// DirTabForward: move forward.
	DirTabForward DirectionType = iota
	// DirTabBackward: move backward.
	DirTabBackward
	// DirUp: move up.
	DirUp
	// DirDown: move down.
	DirDown
	// DirLeft: move left.
	DirLeft
	// DirRight: move right.
	DirRight
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DirectionType.
func (d DirectionType) String() string {
	switch d {
	case DirTabForward:
		return "TabForward"
	case DirTabBackward:
		return "TabBackward"
	case DirUp:
		return "Up"
	case DirDown:
		return "Down"
	case DirLeft:
		return "Left"
	case DirRight:
		return "Right"
	default:
		return fmt.Sprintf("DirectionType(%d)", d)
	}
}

// DragResult gives an indication why a drag operation failed. The value can by
// obtained by connecting to the Widget::drag-failed signal.
type DragResult C.gint

const (
	// DragResultSuccess: drag operation was successful.
	DragResultSuccess DragResult = iota
	// DragResultNoTarget: no suitable drag target.
	DragResultNoTarget
	// DragResultUserCancelled: user cancelled the drag operation.
	DragResultUserCancelled
	// DragResultTimeoutExpired: drag operation timed out.
	DragResultTimeoutExpired
	// DragResultGrabBroken: pointer or keyboard grab used for the drag
	// operation was broken.
	DragResultGrabBroken
	// DragResultError: drag operation failed due to some unspecified error.
	DragResultError
)

func marshalDragResult(p uintptr) (interface{}, error) {
	return DragResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DragResult.
func (d DragResult) String() string {
	switch d {
	case DragResultSuccess:
		return "Success"
	case DragResultNoTarget:
		return "NoTarget"
	case DragResultUserCancelled:
		return "UserCancelled"
	case DragResultTimeoutExpired:
		return "TimeoutExpired"
	case DragResultGrabBroken:
		return "GrabBroken"
	case DragResultError:
		return "Error"
	default:
		return fmt.Sprintf("DragResult(%d)", d)
	}
}

// IMPreeditStyle: style for input method preedit. See also
// Settings:gtk-im-preedit-style
//
// Deprecated: since version 3.10.
type IMPreeditStyle C.gint

const (
	// IMPreeditNothing: deprecated.
	IMPreeditNothing IMPreeditStyle = iota
	// IMPreeditCallback: deprecated.
	IMPreeditCallback
	// IMPreeditNone: deprecated.
	IMPreeditNone
)

func marshalIMPreeditStyle(p uintptr) (interface{}, error) {
	return IMPreeditStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IMPreeditStyle.
func (i IMPreeditStyle) String() string {
	switch i {
	case IMPreeditNothing:
		return "Nothing"
	case IMPreeditCallback:
		return "Callback"
	case IMPreeditNone:
		return "None"
	default:
		return fmt.Sprintf("IMPreeditStyle(%d)", i)
	}
}

// IMStatusStyle: style for input method status. See also
// Settings:gtk-im-status-style
//
// Deprecated: since version 3.10.
type IMStatusStyle C.gint

const (
	// IMStatusNothing: deprecated.
	IMStatusNothing IMStatusStyle = iota
	// IMStatusCallback: deprecated.
	IMStatusCallback
	// IMStatusNone: deprecated.
	IMStatusNone
)

func marshalIMStatusStyle(p uintptr) (interface{}, error) {
	return IMStatusStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IMStatusStyle.
func (i IMStatusStyle) String() string {
	switch i {
	case IMStatusNothing:
		return "Nothing"
	case IMStatusCallback:
		return "Callback"
	case IMStatusNone:
		return "None"
	default:
		return fmt.Sprintf("IMStatusStyle(%d)", i)
	}
}

// IconSize: built-in stock icon sizes.
type IconSize C.gint

const (
	// IconSizeInvalid: invalid size.
	IconSizeInvalid IconSize = iota
	// IconSizeMenu: size appropriate for menus (16px).
	IconSizeMenu
	// IconSizeSmallToolbar: size appropriate for small toolbars (16px).
	IconSizeSmallToolbar
	// IconSizeLargeToolbar: size appropriate for large toolbars (24px).
	IconSizeLargeToolbar
	// IconSizeButton: size appropriate for buttons (16px).
	IconSizeButton
	// IconSizeDND: size appropriate for drag and drop (32px).
	IconSizeDND
	// IconSizeDialog: size appropriate for dialogs (48px).
	IconSizeDialog
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconSize.
func (i IconSize) String() string {
	switch i {
	case IconSizeInvalid:
		return "Invalid"
	case IconSizeMenu:
		return "Menu"
	case IconSizeSmallToolbar:
		return "SmallToolbar"
	case IconSizeLargeToolbar:
		return "LargeToolbar"
	case IconSizeButton:
		return "Button"
	case IconSizeDND:
		return "DND"
	case IconSizeDialog:
		return "Dialog"
	default:
		return fmt.Sprintf("IconSize(%d)", i)
	}
}

// Justification: used for justifying the text inside a Label widget. (See also
// Alignment).
type Justification C.gint

const (
	// JustifyLeft: text is placed at the left edge of the label.
	JustifyLeft Justification = iota
	// JustifyRight: text is placed at the right edge of the label.
	JustifyRight
	// JustifyCenter: text is placed in the center of the label.
	JustifyCenter
	// JustifyFill: text is placed is distributed across the label.
	JustifyFill
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Justification.
func (j Justification) String() string {
	switch j {
	case JustifyLeft:
		return "Left"
	case JustifyRight:
		return "Right"
	case JustifyCenter:
		return "Center"
	case JustifyFill:
		return "Fill"
	default:
		return fmt.Sprintf("Justification(%d)", j)
	}
}

// MenuDirectionType: enumeration representing directional movements within a
// menu.
type MenuDirectionType C.gint

const (
	// MenuDirParent: to the parent menu shell.
	MenuDirParent MenuDirectionType = iota
	// MenuDirChild: to the submenu, if any, associated with the item.
	MenuDirChild
	// MenuDirNext: to the next menu item.
	MenuDirNext
	// MenuDirPrev: to the previous menu item.
	MenuDirPrev
)

func marshalMenuDirectionType(p uintptr) (interface{}, error) {
	return MenuDirectionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MenuDirectionType.
func (m MenuDirectionType) String() string {
	switch m {
	case MenuDirParent:
		return "Parent"
	case MenuDirChild:
		return "Child"
	case MenuDirNext:
		return "Next"
	case MenuDirPrev:
		return "Prev"
	default:
		return fmt.Sprintf("MenuDirectionType(%d)", m)
	}
}

// MessageType: type of message being displayed in the dialog.
type MessageType C.gint

const (
	// MessageInfo: informational message.
	MessageInfo MessageType = iota
	// MessageWarning: non-fatal warning message.
	MessageWarning
	// MessageQuestion: question requiring a choice.
	MessageQuestion
	// MessageError: fatal error message.
	MessageError
	// MessageOther: none of the above.
	MessageOther
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MessageType.
func (m MessageType) String() string {
	switch m {
	case MessageInfo:
		return "Info"
	case MessageWarning:
		return "Warning"
	case MessageQuestion:
		return "Question"
	case MessageError:
		return "Error"
	case MessageOther:
		return "Other"
	default:
		return fmt.Sprintf("MessageType(%d)", m)
	}
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout C.gint

const (
	// NumberUpLayoutLeftToRightTopToBottom: ! (layout-lrtb.png).
	NumberUpLayoutLeftToRightTopToBottom NumberUpLayout = iota
	// NumberUpLayoutLeftToRightBottomToTop: ! (layout-lrbt.png).
	NumberUpLayoutLeftToRightBottomToTop
	// NumberUpLayoutRightToLeftTopToBottom: ! (layout-rltb.png).
	NumberUpLayoutRightToLeftTopToBottom
	// NumberUpLayoutRightToLeftBottomToTop: ! (layout-rlbt.png).
	NumberUpLayoutRightToLeftBottomToTop
	// NumberUpLayoutTopToBottomLeftToRight: ! (layout-tblr.png).
	NumberUpLayoutTopToBottomLeftToRight
	// NumberUpLayoutTopToBottomRightToLeft: ! (layout-tbrl.png).
	NumberUpLayoutTopToBottomRightToLeft
	// NumberUpLayoutBottomToTopLeftToRight: ! (layout-btlr.png).
	NumberUpLayoutBottomToTopLeftToRight
	// NumberUpLayoutBottomToTopRightToLeft: ! (layout-btrl.png).
	NumberUpLayoutBottomToTopRightToLeft
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NumberUpLayout.
func (n NumberUpLayout) String() string {
	switch n {
	case NumberUpLayoutLeftToRightTopToBottom:
		return "Lrtb"
	case NumberUpLayoutLeftToRightBottomToTop:
		return "Lrbt"
	case NumberUpLayoutRightToLeftTopToBottom:
		return "Rltb"
	case NumberUpLayoutRightToLeftBottomToTop:
		return "Rlbt"
	case NumberUpLayoutTopToBottomLeftToRight:
		return "Tblr"
	case NumberUpLayoutTopToBottomRightToLeft:
		return "Tbrl"
	case NumberUpLayoutBottomToTopLeftToRight:
		return "Btlr"
	case NumberUpLayoutBottomToTopRightToLeft:
		return "Btrl"
	default:
		return fmt.Sprintf("NumberUpLayout(%d)", n)
	}
}

// Orientation represents the orientation of widgets and other objects which can
// be switched between horizontal and vertical orientation on the fly, like
// Toolbar or GesturePan.
type Orientation C.gint

const (
	// OrientationHorizontal: element is in horizontal orientation.
	OrientationHorizontal Orientation = iota
	// OrientationVertical: element is in vertical orientation.
	OrientationVertical
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Orientation.
func (o Orientation) String() string {
	switch o {
	case OrientationHorizontal:
		return "Horizontal"
	case OrientationVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("Orientation(%d)", o)
	}
}

// PackDirection determines how widgets should be packed inside menubars and
// menuitems contained in menubars.
type PackDirection C.gint

const (
	// PackDirectionLTR widgets are packed left-to-right.
	PackDirectionLTR PackDirection = iota
	// PackDirectionRTL widgets are packed right-to-left.
	PackDirectionRTL
	// PackDirectionTtb widgets are packed top-to-bottom.
	PackDirectionTtb
	// PackDirectionBtt widgets are packed bottom-to-top.
	PackDirectionBtt
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PackDirection.
func (p PackDirection) String() string {
	switch p {
	case PackDirectionLTR:
		return "LTR"
	case PackDirectionRTL:
		return "RTL"
	case PackDirectionTtb:
		return "Ttb"
	case PackDirectionBtt:
		return "Btt"
	default:
		return fmt.Sprintf("PackDirection(%d)", p)
	}
}

// PackType represents the packing location Box children. (See: VBox, HBox, and
// ButtonBox).
type PackType C.gint

const (
	// PackStart: child is packed into the start of the box.
	PackStart PackType = iota
	// PackEnd: child is packed into the end of the box.
	PackEnd
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PackType.
func (p PackType) String() string {
	switch p {
	case PackStart:
		return "Start"
	case PackEnd:
		return "End"
	default:
		return fmt.Sprintf("PackType(%d)", p)
	}
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation C.gint

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = iota
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PageOrientation.
func (p PageOrientation) String() string {
	switch p {
	case PageOrientationPortrait:
		return "Portrait"
	case PageOrientationLandscape:
		return "Landscape"
	case PageOrientationReversePortrait:
		return "ReversePortrait"
	case PageOrientationReverseLandscape:
		return "ReverseLandscape"
	default:
		return fmt.Sprintf("PageOrientation(%d)", p)
	}
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet C.gint

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = iota
	// PageSetEven: even pages.
	PageSetEven
	// PageSetOdd: odd pages.
	PageSetOdd
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PageSet.
func (p PageSet) String() string {
	switch p {
	case PageSetAll:
		return "All"
	case PageSetEven:
		return "Even"
	case PageSetOdd:
		return "Odd"
	default:
		return fmt.Sprintf("PageSet(%d)", p)
	}
}

// PositionType describes which edge of a widget a certain feature is positioned
// at, e.g. the tabs of a Notebook, the handle of a HandleBox or the label of a
// Scale.
type PositionType C.gint

const (
	// PosLeft: feature is at the left edge.
	PosLeft PositionType = iota
	// PosRight: feature is at the right edge.
	PosRight
	// PosTop: feature is at the top edge.
	PosTop
	// PosBottom: feature is at the bottom edge.
	PosBottom
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PositionType.
func (p PositionType) String() string {
	switch p {
	case PosLeft:
		return "Left"
	case PosRight:
		return "Right"
	case PosTop:
		return "Top"
	case PosBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("PositionType(%d)", p)
	}
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex C.gint

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = iota
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintDuplex.
func (p PrintDuplex) String() string {
	switch p {
	case PrintDuplexSimplex:
		return "Simplex"
	case PrintDuplexHorizontal:
		return "Horizontal"
	case PrintDuplexVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("PrintDuplex(%d)", p)
	}
}

// PrintPages: see also gtk_print_job_set_pages().
type PrintPages C.gint

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = iota
	// PrintPagesCurrent: current page.
	PrintPagesCurrent
	// PrintPagesRanges: range of pages.
	PrintPagesRanges
	// PrintPagesSelection: selected pages.
	PrintPagesSelection
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintPages.
func (p PrintPages) String() string {
	switch p {
	case PrintPagesAll:
		return "All"
	case PrintPagesCurrent:
		return "Current"
	case PrintPagesRanges:
		return "Ranges"
	case PrintPagesSelection:
		return "Selection"
	default:
		return fmt.Sprintf("PrintPages(%d)", p)
	}
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality C.gint

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = iota
	// PrintQualityNormal: normal quality.
	PrintQualityNormal
	// PrintQualityHigh: high quality.
	PrintQualityHigh
	// PrintQualityDraft: draft quality.
	PrintQualityDraft
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintQuality.
func (p PrintQuality) String() string {
	switch p {
	case PrintQualityLow:
		return "Low"
	case PrintQualityNormal:
		return "Normal"
	case PrintQualityHigh:
		return "High"
	case PrintQualityDraft:
		return "Draft"
	default:
		return fmt.Sprintf("PrintQuality(%d)", p)
	}
}

// ReliefStyle: indicated the relief to be drawn around a Button.
type ReliefStyle C.gint

const (
	// ReliefNormal: draw a normal relief.
	ReliefNormal ReliefStyle = iota
	// ReliefHalf: half relief. Deprecated in 3.14, does the same as
	// GTK_RELIEF_NORMAL.
	ReliefHalf
	// ReliefNone: no relief.
	ReliefNone
)

func marshalReliefStyle(p uintptr) (interface{}, error) {
	return ReliefStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ReliefStyle.
func (r ReliefStyle) String() string {
	switch r {
	case ReliefNormal:
		return "Normal"
	case ReliefHalf:
		return "Half"
	case ReliefNone:
		return "None"
	default:
		return fmt.Sprintf("ReliefStyle(%d)", r)
	}
}

// ScrollType: scrolling types.
type ScrollType C.gint

const (
	// ScrollNone: no scrolling.
	ScrollNone ScrollType = iota
	// ScrollJump: jump to new location.
	ScrollJump
	// ScrollStepBackward: step backward.
	ScrollStepBackward
	// ScrollStepForward: step forward.
	ScrollStepForward
	// ScrollPageBackward: page backward.
	ScrollPageBackward
	// ScrollPageForward: page forward.
	ScrollPageForward
	// ScrollStepUp: step up.
	ScrollStepUp
	// ScrollStepDown: step down.
	ScrollStepDown
	// ScrollPageUp: page up.
	ScrollPageUp
	// ScrollPageDown: page down.
	ScrollPageDown
	// ScrollStepLeft: step to the left.
	ScrollStepLeft
	// ScrollStepRight: step to the right.
	ScrollStepRight
	// ScrollPageLeft: page to the left.
	ScrollPageLeft
	// ScrollPageRight: page to the right.
	ScrollPageRight
	// ScrollStart: scroll to start.
	ScrollStart
	// ScrollEnd: scroll to end.
	ScrollEnd
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollType.
func (s ScrollType) String() string {
	switch s {
	case ScrollNone:
		return "None"
	case ScrollJump:
		return "Jump"
	case ScrollStepBackward:
		return "StepBackward"
	case ScrollStepForward:
		return "StepForward"
	case ScrollPageBackward:
		return "PageBackward"
	case ScrollPageForward:
		return "PageForward"
	case ScrollStepUp:
		return "StepUp"
	case ScrollStepDown:
		return "StepDown"
	case ScrollPageUp:
		return "PageUp"
	case ScrollPageDown:
		return "PageDown"
	case ScrollStepLeft:
		return "StepLeft"
	case ScrollStepRight:
		return "StepRight"
	case ScrollPageLeft:
		return "PageLeft"
	case ScrollPageRight:
		return "PageRight"
	case ScrollStart:
		return "Start"
	case ScrollEnd:
		return "End"
	default:
		return fmt.Sprintf("ScrollType(%d)", s)
	}
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy C.gint

const (
	// ScrollMinimum: scrollable adjustments are based on the minimum size.
	ScrollMinimum ScrollablePolicy = iota
	// ScrollNatural: scrollable adjustments are based on the natural size.
	ScrollNatural
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollablePolicy.
func (s ScrollablePolicy) String() string {
	switch s {
	case ScrollMinimum:
		return "Minimum"
	case ScrollNatural:
		return "Natural"
	default:
		return fmt.Sprintf("ScrollablePolicy(%d)", s)
	}
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode C.gint

const (
	// SelectionNone: no selection is possible.
	SelectionNone SelectionMode = iota
	// SelectionSingle: zero or one element may be selected.
	SelectionSingle
	// SelectionBrowse: exactly one element is selected. In some circumstances,
	// such as initially or during a search operation, it’s possible for no
	// element to be selected with GTK_SELECTION_BROWSE. What is really enforced
	// is that the user can’t deselect a currently selected element except by
	// selecting another element.
	SelectionBrowse
	// SelectionMultiple: any number of elements may be selected. The Ctrl key
	// may be used to enlarge the selection, and Shift key to select between the
	// focus and the child pointed to. Some widgets may also allow Click-drag to
	// select a range of elements.
	SelectionMultiple
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SelectionMode.
func (s SelectionMode) String() string {
	switch s {
	case SelectionNone:
		return "None"
	case SelectionSingle:
		return "Single"
	case SelectionBrowse:
		return "Browse"
	case SelectionMultiple:
		return "Multiple"
	default:
		return fmt.Sprintf("SelectionMode(%d)", s)
	}
}

// SensitivityType determines how GTK+ handles the sensitivity of stepper arrows
// at the end of range widgets.
type SensitivityType C.gint

const (
	// SensitivityAuto: arrow is made insensitive if the thumb is at the end.
	SensitivityAuto SensitivityType = iota
	// SensitivityOn: arrow is always sensitive.
	SensitivityOn
	// SensitivityOff: arrow is always insensitive.
	SensitivityOff
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SensitivityType.
func (s SensitivityType) String() string {
	switch s {
	case SensitivityAuto:
		return "Auto"
	case SensitivityOn:
		return "On"
	case SensitivityOff:
		return "Off"
	default:
		return fmt.Sprintf("SensitivityType(%d)", s)
	}
}

// ShadowType: used to change the appearance of an outline typically provided by
// a Frame.
//
// Note that many themes do not differentiate the appearance of the various
// shadow types: Either their is no visible shadow (GTK_SHADOW_NONE), or there
// is (any other value).
type ShadowType C.gint

const (
	// ShadowNone: no outline.
	ShadowNone ShadowType = iota
	// ShadowIn: outline is bevelled inwards.
	ShadowIn
	// ShadowOut: outline is bevelled outwards like a button.
	ShadowOut
	// ShadowEtchedIn: outline has a sunken 3d appearance.
	ShadowEtchedIn
	// ShadowEtchedOut: outline has a raised 3d appearance.
	ShadowEtchedOut
)

func marshalShadowType(p uintptr) (interface{}, error) {
	return ShadowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ShadowType.
func (s ShadowType) String() string {
	switch s {
	case ShadowNone:
		return "None"
	case ShadowIn:
		return "In"
	case ShadowOut:
		return "Out"
	case ShadowEtchedIn:
		return "EtchedIn"
	case ShadowEtchedOut:
		return "EtchedOut"
	default:
		return fmt.Sprintf("ShadowType(%d)", s)
	}
}

// SizeGroupMode: mode of the size group determines the directions in which the
// size group affects the requested sizes of its component widgets.
type SizeGroupMode C.gint

const (
	// SizeGroupNone: group has no effect.
	SizeGroupNone SizeGroupMode = iota
	// SizeGroupHorizontal: group affects horizontal requisition.
	SizeGroupHorizontal
	// SizeGroupVertical: group affects vertical requisition.
	SizeGroupVertical
	// SizeGroupBoth: group affects both horizontal and vertical requisition.
	SizeGroupBoth
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SizeGroupMode.
func (s SizeGroupMode) String() string {
	switch s {
	case SizeGroupNone:
		return "None"
	case SizeGroupHorizontal:
		return "Horizontal"
	case SizeGroupVertical:
		return "Vertical"
	case SizeGroupBoth:
		return "Both"
	default:
		return fmt.Sprintf("SizeGroupMode(%d)", s)
	}
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode C.gint

const (
	// SizeRequestHeightForWidth: prefer height-for-width geometry management.
	SizeRequestHeightForWidth SizeRequestMode = iota
	// SizeRequestWidthForHeight: prefer width-for-height geometry management.
	SizeRequestWidthForHeight
	// SizeRequestConstantSize: don’t trade height-for-width or
	// width-for-height.
	SizeRequestConstantSize
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SizeRequestMode.
func (s SizeRequestMode) String() string {
	switch s {
	case SizeRequestHeightForWidth:
		return "HeightForWidth"
	case SizeRequestWidthForHeight:
		return "WidthForHeight"
	case SizeRequestConstantSize:
		return "ConstantSize"
	default:
		return fmt.Sprintf("SizeRequestMode(%d)", s)
	}
}

// SortType determines the direction of a sort.
type SortType C.gint

const (
	// SortAscending: sorting is in ascending order.
	SortAscending SortType = iota
	// SortDescending: sorting is in descending order.
	SortDescending
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SortType.
func (s SortType) String() string {
	switch s {
	case SortAscending:
		return "Ascending"
	case SortDescending:
		return "Descending"
	default:
		return fmt.Sprintf("SortType(%d)", s)
	}
}

// StateType: this type indicates the current state of a widget; the state
// determines how the widget is drawn. The StateType enumeration is also used to
// identify different colors in a Style for drawing, so states can be used for
// subparts of a widget as well as entire widgets.
//
// Deprecated: All APIs that are using this enumeration have been deprecated in
// favor of alternatives using StateFlags.
type StateType C.gint

const (
	// StateNormal: state during normal operation.
	StateNormal StateType = iota
	// StateActive: state of a currently active widget, such as a depressed
	// button.
	StateActive
	// StatePrelight: state indicating that the mouse pointer is over the widget
	// and the widget will respond to mouse clicks.
	StatePrelight
	// StateSelected: state of a selected item, such the selected row in a list.
	StateSelected
	// StateInsensitive: state indicating that the widget is unresponsive to
	// user actions.
	StateInsensitive
	// StateInconsistent: widget is inconsistent, such as checkbuttons or
	// radiobuttons that aren’t either set to TRUE nor FALSE, or buttons
	// requiring the user attention.
	StateInconsistent
	// StateFocused: widget has the keyboard focus.
	StateFocused
)

func marshalStateType(p uintptr) (interface{}, error) {
	return StateType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StateType.
func (s StateType) String() string {
	switch s {
	case StateNormal:
		return "Normal"
	case StateActive:
		return "Active"
	case StatePrelight:
		return "Prelight"
	case StateSelected:
		return "Selected"
	case StateInsensitive:
		return "Insensitive"
	case StateInconsistent:
		return "Inconsistent"
	case StateFocused:
		return "Focused"
	default:
		return fmt.Sprintf("StateType(%d)", s)
	}
}

// TextDirection: reading directions for text.
type TextDirection C.gint

const (
	// TextDirNone: no direction.
	TextDirNone TextDirection = iota
	// TextDirLTR: left to right text direction.
	TextDirLTR
	// TextDirRTL: right to left text direction.
	TextDirRTL
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextDirection.
func (t TextDirection) String() string {
	switch t {
	case TextDirNone:
		return "None"
	case TextDirLTR:
		return "LTR"
	case TextDirRTL:
		return "RTL"
	default:
		return fmt.Sprintf("TextDirection(%d)", t)
	}
}

// ToolbarStyle: used to customize the appearance of a Toolbar. Note that
// setting the toolbar style overrides the user’s preferences for the default
// toolbar style. Note that if the button has only a label set and
// GTK_TOOLBAR_ICONS is used, the label will be visible, and vice versa.
type ToolbarStyle C.gint

const (
	// ToolbarIcons buttons display only icons in the toolbar.
	ToolbarIcons ToolbarStyle = iota
	// ToolbarText buttons display only text labels in the toolbar.
	ToolbarText
	// ToolbarBoth buttons display text and icons in the toolbar.
	ToolbarBoth
	// ToolbarBothHoriz buttons display icons and text alongside each other,
	// rather than vertically stacked.
	ToolbarBothHoriz
)

func marshalToolbarStyle(p uintptr) (interface{}, error) {
	return ToolbarStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ToolbarStyle.
func (t ToolbarStyle) String() string {
	switch t {
	case ToolbarIcons:
		return "Icons"
	case ToolbarText:
		return "Text"
	case ToolbarBoth:
		return "Both"
	case ToolbarBothHoriz:
		return "BothHoriz"
	default:
		return fmt.Sprintf("ToolbarStyle(%d)", t)
	}
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines C.gint

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = iota
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewGridLines.
func (t TreeViewGridLines) String() string {
	switch t {
	case TreeViewGridLinesNone:
		return "None"
	case TreeViewGridLinesHorizontal:
		return "Horizontal"
	case TreeViewGridLinesVertical:
		return "Vertical"
	case TreeViewGridLinesBoth:
		return "Both"
	default:
		return fmt.Sprintf("TreeViewGridLines(%d)", t)
	}
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit C.gint

const (
	// UnitNone: no units.
	UnitNone Unit = iota
	// UnitPoints dimensions in points.
	UnitPoints
	// UnitInch dimensions in inches.
	UnitInch
	// UnitMm dimensions in millimeters.
	UnitMm
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Unit.
func (u Unit) String() string {
	switch u {
	case UnitNone:
		return "None"
	case UnitPoints:
		return "Points"
	case UnitInch:
		return "Inch"
	case UnitMm:
		return "Mm"
	default:
		return fmt.Sprintf("Unit(%d)", u)
	}
}

// WrapMode describes a type of line wrapping.
type WrapMode C.gint

const (
	// WrapNone: do not wrap lines; just make the text area wider.
	WrapNone WrapMode = iota
	// WrapChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs()).
	WrapChar
	// WrapWord: wrap text, breaking lines in between words.
	WrapWord
	// WrapWordChar: wrap text, breaking lines in between words, or if that is
	// not enough, also between graphemes.
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapNone:
		return "None"
	case WrapChar:
		return "Char"
	case WrapWord:
		return "Word"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// JunctionSides describes how a rendered element connects to adjacent elements.
type JunctionSides C.guint

const (
	// JunctionNone: no junctions.
	JunctionNone JunctionSides = 0b0
	// JunctionCornerTopleft: element connects on the top-left corner.
	JunctionCornerTopleft JunctionSides = 0b1
	// JunctionCornerTopright: element connects on the top-right corner.
	JunctionCornerTopright JunctionSides = 0b10
	// JunctionCornerBottomleft: element connects on the bottom-left corner.
	JunctionCornerBottomleft JunctionSides = 0b100
	// JunctionCornerBottomright: element connects on the bottom-right corner.
	JunctionCornerBottomright JunctionSides = 0b1000
	// JunctionTop: element connects on the top side.
	JunctionTop JunctionSides = 0b11
	// JunctionBottom: element connects on the bottom side.
	JunctionBottom JunctionSides = 0b1100
	// JunctionLeft: element connects on the left side.
	JunctionLeft JunctionSides = 0b101
	// JunctionRight: element connects on the right side.
	JunctionRight JunctionSides = 0b1010
)

func marshalJunctionSides(p uintptr) (interface{}, error) {
	return JunctionSides(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for JunctionSides.
func (j JunctionSides) String() string {
	if j == 0 {
		return "JunctionSides(0)"
	}

	var builder strings.Builder
	builder.Grow(162)

	for j != 0 {
		next := j & (j - 1)
		bit := j - next

		switch bit {
		case JunctionNone:
			builder.WriteString("None|")
		case JunctionCornerTopleft:
			builder.WriteString("CornerTopleft|")
		case JunctionCornerTopright:
			builder.WriteString("CornerTopright|")
		case JunctionCornerBottomleft:
			builder.WriteString("CornerBottomleft|")
		case JunctionCornerBottomright:
			builder.WriteString("CornerBottomright|")
		case JunctionTop:
			builder.WriteString("Top|")
		case JunctionBottom:
			builder.WriteString("Bottom|")
		case JunctionLeft:
			builder.WriteString("Left|")
		case JunctionRight:
			builder.WriteString("Right|")
		default:
			builder.WriteString(fmt.Sprintf("JunctionSides(0b%b)|", bit))
		}

		j = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if j contains other.
func (j JunctionSides) Has(other JunctionSides) bool {
	return (j & other) == other
}

// RegionFlags describes a region within a widget.
type RegionFlags C.guint

const (
	// RegionEven: region has an even number within a set.
	RegionEven RegionFlags = 0b1
	// RegionOdd: region has an odd number within a set.
	RegionOdd RegionFlags = 0b10
	// RegionFirst: region is the first one within a set.
	RegionFirst RegionFlags = 0b100
	// RegionLast: region is the last one within a set.
	RegionLast RegionFlags = 0b1000
	// RegionOnly: region is the only one within a set.
	RegionOnly RegionFlags = 0b10000
	// RegionSorted: region is part of a sorted area.
	RegionSorted RegionFlags = 0b100000
)

func marshalRegionFlags(p uintptr) (interface{}, error) {
	return RegionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RegionFlags.
func (r RegionFlags) String() string {
	if r == 0 {
		return "RegionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(67)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RegionEven:
			builder.WriteString("Even|")
		case RegionOdd:
			builder.WriteString("Odd|")
		case RegionFirst:
			builder.WriteString("First|")
		case RegionLast:
			builder.WriteString("Last|")
		case RegionOnly:
			builder.WriteString("Only|")
		case RegionSorted:
			builder.WriteString("Sorted|")
		default:
			builder.WriteString(fmt.Sprintf("RegionFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RegionFlags) Has(other RegionFlags) bool {
	return (r & other) == other
}

// StateFlags describes a widget state. Widget states are used to match the
// widget against CSS pseudo-classes. Note that GTK extends the regular CSS
// classes and sometimes uses different names.
type StateFlags C.guint

const (
	// StateFlagNormal: state during normal operation.
	StateFlagNormal StateFlags = 0b0
	// StateFlagActive: widget is active.
	StateFlagActive StateFlags = 0b1
	// StateFlagPrelight: widget has a mouse pointer over it.
	StateFlagPrelight StateFlags = 0b10
	// StateFlagSelected: widget is selected.
	StateFlagSelected StateFlags = 0b100
	// StateFlagInsensitive: widget is insensitive.
	StateFlagInsensitive StateFlags = 0b1000
	// StateFlagInconsistent: widget is inconsistent.
	StateFlagInconsistent StateFlags = 0b10000
	// StateFlagFocused: widget has the keyboard focus.
	StateFlagFocused StateFlags = 0b100000
	// StateFlagBackdrop: widget is in a background toplevel window.
	StateFlagBackdrop StateFlags = 0b1000000
	// StateFlagDirLTR: widget is in left-to-right text direction. Since 3.8.
	StateFlagDirLTR StateFlags = 0b10000000
	// StateFlagDirRTL: widget is in right-to-left text direction. Since 3.8.
	StateFlagDirRTL StateFlags = 0b100000000
	// StateFlagLink: widget is a link. Since 3.12.
	StateFlagLink StateFlags = 0b1000000000
	// StateFlagVisited: location the widget points to has already been visited.
	// Since 3.12.
	StateFlagVisited StateFlags = 0b10000000000
	// StateFlagChecked: widget is checked. Since 3.14.
	StateFlagChecked StateFlags = 0b100000000000
	// StateFlagDropActive: widget is highlighted as a drop target for DND.
	// Since 3.20.
	StateFlagDropActive StateFlags = 0b1000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StateFlags.
func (s StateFlags) String() string {
	if s == 0 {
		return "StateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(245)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StateFlagNormal:
			builder.WriteString("Normal|")
		case StateFlagActive:
			builder.WriteString("Active|")
		case StateFlagPrelight:
			builder.WriteString("Prelight|")
		case StateFlagSelected:
			builder.WriteString("Selected|")
		case StateFlagInsensitive:
			builder.WriteString("Insensitive|")
		case StateFlagInconsistent:
			builder.WriteString("Inconsistent|")
		case StateFlagFocused:
			builder.WriteString("Focused|")
		case StateFlagBackdrop:
			builder.WriteString("Backdrop|")
		case StateFlagDirLTR:
			builder.WriteString("DirLTR|")
		case StateFlagDirRTL:
			builder.WriteString("DirRTL|")
		case StateFlagLink:
			builder.WriteString("Link|")
		case StateFlagVisited:
			builder.WriteString("Visited|")
		case StateFlagChecked:
			builder.WriteString("Checked|")
		case StateFlagDropActive:
			builder.WriteString("DropActive|")
		default:
			builder.WriteString(fmt.Sprintf("StateFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StateFlags) Has(other StateFlags) bool {
	return (s & other) == other
}
