// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_Menu_ConnectPoppedUp(gpointer, gpointer, gpointer, gboolean, gboolean, guintptr);
import "C"

// GType values.
var (
	GTypeArrowPlacement = coreglib.Type(girepository.MustFind("Gtk", "ArrowPlacement").RegisteredGType())
	GTypeMenu           = coreglib.Type(girepository.MustFind("Gtk", "Menu").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeArrowPlacement, F: marshalArrowPlacement},
		coreglib.TypeMarshaler{T: GTypeMenu, F: marshalMenu},
	})
}

// ArrowPlacement: used to specify the placement of scroll arrows in scrolling
// menus.
type ArrowPlacement C.gint

const (
	// ArrowsBoth: place one arrow on each end of the menu.
	ArrowsBoth ArrowPlacement = iota
	// ArrowsStart: place both arrows at the top of the menu.
	ArrowsStart
	// ArrowsEnd: place both arrows at the bottom of the menu.
	ArrowsEnd
)

func marshalArrowPlacement(p uintptr) (interface{}, error) {
	return ArrowPlacement(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ArrowPlacement.
func (a ArrowPlacement) String() string {
	switch a {
	case ArrowsBoth:
		return "Both"
	case ArrowsStart:
		return "Start"
	case ArrowsEnd:
		return "End"
	default:
		return fmt.Sprintf("ArrowPlacement(%d)", a)
	}
}

// MenuOverrides contains methods that are overridable.
type MenuOverrides struct {
}

func defaultMenuOverrides(v *Menu) MenuOverrides {
	return MenuOverrides{}
}

// Menu is a MenuShell that implements a drop down menu consisting of a list of
// MenuItem objects which can be navigated and activated by the user to perform
// application functions.
//
// A Menu is most commonly dropped down by activating a MenuItem in a MenuBar or
// popped up by activating a MenuItem in another Menu.
//
// A Menu can also be popped up by activating a ComboBox. Other composite
// widgets such as the Notebook can pop up a Menu as well.
//
// Applications can display a Menu as a popup menu by calling the
// gtk_menu_popup() function. The example below shows how an application can pop
// up a menu when the 3rd mouse button is pressed.
//
// Connecting the popup signal handler.
//
//    menu
//    ├── arrow.top
//    ├── <child>
//    ┊
//    ├── <child>
//    ╰── arrow.bottom
//
// The main CSS node of GtkMenu has name menu, and there are two subnodes with
// name arrow, for scrolling menu arrows. These subnodes get the .top and
// .bottom style classes.
type Menu struct {
	_ [0]func() // equal guard
	MenuShell
}

var (
	_ MenuSheller = (*Menu)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Menu, *MenuClass, MenuOverrides](
		GTypeMenu,
		initMenuClass,
		wrapMenu,
		defaultMenuOverrides,
	)
}

func initMenuClass(gclass unsafe.Pointer, overrides MenuOverrides, classInitFunc func(*MenuClass)) {
	if classInitFunc != nil {
		class := (*MenuClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenu(obj *coreglib.Object) *Menu {
	return &Menu{
		MenuShell: MenuShell{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	return wrapMenu(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPoppedUp is emitted when the position of menu is finalized after being
// popped up using gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (), or
// gtk_menu_popup_at_pointer ().
//
// menu might be flipped over the anchor rectangle in order to keep it
// on-screen, in which case flipped_x and flipped_y will be set to TRUE
// accordingly.
//
// flipped_rect is the ideal position of menu after any possible flipping, but
// before any possible sliding. final_rect is flipped_rect, but possibly
// translated in the case that flipping is still ineffective in keeping menu
// on-screen.
//
// ! (popup-slide.png)
//
// The blue menu is menu's ideal position, the green menu is flipped_rect, and
// the red menu is final_rect.
//
// See gtk_menu_popup_at_rect (), gtk_menu_popup_at_widget (),
// gtk_menu_popup_at_pointer (), Menu:anchor-hints, Menu:rect-anchor-dx,
// Menu:rect-anchor-dy, and Menu:menu-type-hint.
func (v *Menu) ConnectPoppedUp(f func(flippedRect, finalRect unsafe.Pointer, flippedX, flippedY bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "popped-up", false, unsafe.Pointer(C._gotk4_gtk3_Menu_ConnectPoppedUp), f)
}

// MenuClass: instance of this type is always passed by reference.
type MenuClass struct {
	*menuClass
}

// menuClass is the struct that's finalized.
type menuClass struct {
	native unsafe.Pointer
}

var GIRInfoMenuClass = girepository.MustFind("Gtk", "MenuClass")
