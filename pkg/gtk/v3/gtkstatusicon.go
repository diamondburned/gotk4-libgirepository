// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_StatusIcon_ConnectPopupMenu(gpointer, guint, guint, guintptr);
// extern void _gotk4_gtk3_StatusIcon_ConnectActivate(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectSizeChanged(gpointer, gint, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectScrollEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectQueryTooltip(gpointer, gint, gint, gboolean, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent(gpointer, void*, guintptr);
import "C"

// GType values.
var (
	GTypeStatusIcon = coreglib.Type(girepository.MustFind("Gtk", "StatusIcon").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStatusIcon, F: marshalStatusIcon},
	})
}

// StatusIconOverrides contains methods that are overridable.
type StatusIconOverrides struct {
}

func defaultStatusIconOverrides(v *StatusIcon) StatusIconOverrides {
	return StatusIconOverrides{}
}

// StatusIcon: “system tray” or notification area is normally used for transient
// icons that indicate some special state. For example, a system tray icon might
// appear to tell the user that they have new mail, or have an incoming instant
// message, or something along those lines. The basic idea is that creating an
// icon in the notification area is less annoying than popping up a dialog.
//
// A StatusIcon object can be used to display an icon in a “system tray”. The
// icon can have a tooltip, and the user can interact with it by activating it
// or popping up a context menu.
//
// It is very important to notice that status icons depend on the existence of a
// notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your
// application, as the notification area may not exist on the user's
// environment, or may have been removed. You should always check that a status
// icon has been embedded into a notification area by using
// gtk_status_icon_is_embedded(), and gracefully recover if the function returns
// FALSE.
//
// On X11, the implementation follows the FreeDesktop System Tray Specification
// (http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the “tray” side of this specification can be found e.g. in
// the GNOME 2 and KDE panel applications.
//
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesn’t allow
// to embed arbitrary widgets.
//
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with Application on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this HowDoI
// (https://wiki.gnome.org/HowDoI/GNotification) for code examples.
type StatusIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StatusIcon)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StatusIcon, *StatusIconClass, StatusIconOverrides](
		GTypeStatusIcon,
		initStatusIconClass,
		wrapStatusIcon,
		defaultStatusIconOverrides,
	)
}

func initStatusIconClass(gclass unsafe.Pointer, overrides StatusIconOverrides, classInitFunc func(*StatusIconClass)) {
	if classInitFunc != nil {
		class := (*StatusIconClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStatusIcon(obj *coreglib.Object) *StatusIcon {
	return &StatusIcon{
		Object: obj,
	}
}

func marshalStatusIcon(p uintptr) (interface{}, error) {
	return wrapStatusIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate gets emitted when the user activates the status icon. If and
// how status icons can activated is platform-dependent.
//
// Unlike most G_SIGNAL_ACTION signals, this signal is meant to be used by
// applications and should be wrapped by language bindings.
func (v *StatusIcon) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectActivate), f)
}

// ConnectButtonPressEvent signal will be emitted when a button (typically from
// a mouse) is pressed.
//
// Whether this event is emitted is platform-dependent. Use the ::activate and
// ::popup-menu signals in preference.
func (v *StatusIcon) ConnectButtonPressEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "button-press-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectButtonPressEvent), f)
}

// ConnectButtonReleaseEvent signal will be emitted when a button (typically
// from a mouse) is released.
//
// Whether this event is emitted is platform-dependent. Use the ::activate and
// ::popup-menu signals in preference.
func (v *StatusIcon) ConnectButtonReleaseEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "button-release-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent), f)
}

// ConnectPopupMenu gets emitted when the user brings up the context menu of the
// status icon. Whether status icons can have context menus and how these are
// activated is platform-dependent.
//
// The button and activate_time parameters should be passed as the last to
// arguments to gtk_menu_popup().
//
// Unlike most G_SIGNAL_ACTION signals, this signal is meant to be used by
// applications and should be wrapped by language bindings.
func (v *StatusIcon) ConnectPopupMenu(f func(button, activateTime uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "popup-menu", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectPopupMenu), f)
}

// ConnectQueryTooltip is emitted when the hover timeout has expired with the
// cursor hovering above status_icon; or emitted when status_icon got focus in
// keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for status_icon. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
//
// Whether this signal is emitted is platform-dependent. For plain text
// tooltips, use StatusIcon:tooltip-text in preference.
func (v *StatusIcon) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectQueryTooltip), f)
}

// ConnectScrollEvent signal is emitted when a button in the 4 to 7 range is
// pressed. Wheel mice are usually configured to generate button press events
// for buttons 4 and 5 when the wheel is turned.
//
// Whether this event is emitted is platform-dependent.
func (v *StatusIcon) ConnectScrollEvent(f func(event *gdk.EventScroll) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "scroll-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectScrollEvent), f)
}

// ConnectSizeChanged gets emitted when the size available for the image
// changes, e.g. because the notification area got resized.
func (v *StatusIcon) ConnectSizeChanged(f func(size int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "size-changed", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectSizeChanged), f)
}

// StatusIconClass: instance of this type is always passed by reference.
type StatusIconClass struct {
	*statusIconClass
}

// statusIconClass is the struct that's finalized.
type statusIconClass struct {
	native unsafe.Pointer
}

var GIRInfoStatusIconClass = girepository.MustFind("Gtk", "StatusIconClass")
