// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_FileChooser_ConnectUpdatePreview(gpointer, guintptr);
// extern void _gotk4_gtk3_FileChooser_ConnectSelectionChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_FileChooser_ConnectFileActivated(gpointer, guintptr);
// extern void _gotk4_gtk3_FileChooser_ConnectCurrentFolderChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeFileChooserAction = coreglib.Type(girepository.MustFind("Gtk", "FileChooserAction").RegisteredGType())
	GTypeFileChooserError  = coreglib.Type(girepository.MustFind("Gtk", "FileChooserError").RegisteredGType())
	GTypeFileChooser       = coreglib.Type(girepository.MustFind("Gtk", "FileChooser").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileChooserAction, F: marshalFileChooserAction},
		coreglib.TypeMarshaler{T: GTypeFileChooserError, F: marshalFileChooserError},
		coreglib.TypeMarshaler{T: GTypeFileChooser, F: marshalFileChooser},
	})
}

// FileChooserAction describes whether a FileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction C.gint

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = iota
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder
	// FileChooserActionCreateFolder indicates a mode for creating a new folder.
	// The file chooser will let the user name an existing or new folder.
	FileChooserActionCreateFolder
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileChooserAction.
func (f FileChooserAction) String() string {
	switch f {
	case FileChooserActionOpen:
		return "Open"
	case FileChooserActionSave:
		return "Save"
	case FileChooserActionSelectFolder:
		return "SelectFolder"
	case FileChooserActionCreateFolder:
		return "CreateFolder"
	default:
		return fmt.Sprintf("FileChooserAction(%d)", f)
	}
}

// FileChooserError: these identify the various errors that can occur while
// calling FileChooser functions.
type FileChooserError C.gint

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = iota
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileChooserError.
func (f FileChooserError) String() string {
	switch f {
	case FileChooserErrorNonexistent:
		return "Nonexistent"
	case FileChooserErrorBadFilename:
		return "BadFilename"
	case FileChooserErrorAlreadyExists:
		return "AlreadyExists"
	case FileChooserErrorIncompleteHostname:
		return "IncompleteHostname"
	default:
		return fmt.Sprintf("FileChooserError(%d)", f)
	}
}

// FileChooser is an interface that can be implemented by file selection
// widgets. In GTK+, the main objects that implement this interface are
// FileChooserWidget, FileChooserDialog, and FileChooserButton. You do not need
// to write an object that implements the FileChooser interface unless you are
// trying to adapt an existing file selector to expose a standard programming
// interface.
//
// FileChooser allows for shortcuts to various places in the filesystem. In the
// default implementation these are displayed in the left pane. It may be a bit
// confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
//
// File Names and Encodings
//
// When the user is finished selecting files in a FileChooser, your program can
// get the selected names either as filenames or as URIs. For URIs, the normal
// escaping rules are applied if the URI contains non-ASCII characters. However,
// filenames are always returned in the character set specified by the
// G_FILENAME_ENCODING environment variable. Please see the GLib documentation
// for more details about this variable.
//
// This means that while you can pass the result of
// gtk_file_chooser_get_filename() to g_open() or g_fopen(), you may not be able
// to directly set it as the text of a Label widget unless you convert it first
// to UTF-8, which all GTK+ widgets expect. You should use g_filename_to_utf8()
// to convert filenames into strings that can be passed to GTK+ widgets.
//
//
// Adding a Preview Widget
//
// You can add a custom preview widget to a file chooser and then get
// notification about when the preview needs to be updated. To install a preview
// widget, use gtk_file_chooser_set_preview_widget(). Then, connect to the
// FileChooser::update-preview signal to get notified when you need to update
// the contents of the preview.
//
// Your callback should use gtk_file_chooser_get_preview_filename() to see what
// needs previewing. Once you have generated the preview for the corresponding
// file, you must call gtk_file_chooser_set_preview_widget_active() with a
// boolean flag that indicates whether your callback could successfully generate
// a preview.
//
// Example: Using a Preview Widget
//
//
//      GtkWidget *toggle;
//
//      ...
//
//      toggle = gtk_check_button_new_with_label ("Open file read-only");
//      gtk_widget_show (toggle);
//      gtk_file_chooser_set_extra_widget (my_file_chooser, toggle);
//    }
//
// If you want to set more than one extra widget in the file chooser, you can a
// container such as a Box or a Grid and include your widgets in it. Then, set
// the container as the whole extra widget.
//
// FileChooser wraps an interface. This means the user can get the
// underlying type by calling Cast().
type FileChooser struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileChooser)(nil)
)

// FileChooserer describes FileChooser's interface methods.
type FileChooserer interface {
	coreglib.Objector

	baseFileChooser() *FileChooser
}

var _ FileChooserer = (*FileChooser)(nil)

func wrapFileChooser(obj *coreglib.Object) *FileChooser {
	return &FileChooser{
		Object: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	return wrapFileChooser(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *FileChooser) baseFileChooser() *FileChooser {
	return v
}

// BaseFileChooser returns the underlying base object.
func BaseFileChooser(obj FileChooserer) *FileChooser {
	return obj.baseFileChooser()
}

// ConnectCurrentFolderChanged: this signal is emitted when the current folder
// in a FileChooser changes. This can happen due to the user performing some
// action that changes folders, such as selecting a bookmark or visiting a
// folder on the file list. It can also happen as a result of calling a function
// to explicitly change the current folder in a file chooser.
//
// Normally you do not need to connect to this signal, unless you need to keep
// track of which folder a file chooser is showing.
//
// See also: gtk_file_chooser_set_current_folder(),
// gtk_file_chooser_get_current_folder(),
// gtk_file_chooser_set_current_folder_uri(),
// gtk_file_chooser_get_current_folder_uri().
func (v *FileChooser) ConnectCurrentFolderChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "current-folder-changed", false, unsafe.Pointer(C._gotk4_gtk3_FileChooser_ConnectCurrentFolderChanged), f)
}

// ConnectFileActivated: this signal is emitted when the user "activates" a file
// in the file chooser. This can happen by double-clicking on a file in the file
// list, or by pressing Enter.
//
// Normally you do not need to connect to this signal. It is used internally by
// FileChooserDialog to know when to activate the default button in the dialog.
//
// See also: gtk_file_chooser_get_filename(), gtk_file_chooser_get_filenames(),
// gtk_file_chooser_get_uri(), gtk_file_chooser_get_uris().
func (v *FileChooser) ConnectFileActivated(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "file-activated", false, unsafe.Pointer(C._gotk4_gtk3_FileChooser_ConnectFileActivated), f)
}

// ConnectSelectionChanged: this signal is emitted when there is a change in the
// set of selected files in a FileChooser. This can happen when the user
// modifies the selection with the mouse or the keyboard, or when explicitly
// calling functions to change the selection.
//
// Normally you do not need to connect to this signal, as it is easier to wait
// for the file chooser to finish running, and then to get the list of selected
// files using the functions mentioned below.
//
// See also: gtk_file_chooser_select_filename(),
// gtk_file_chooser_unselect_filename(), gtk_file_chooser_get_filename(),
// gtk_file_chooser_get_filenames(), gtk_file_chooser_select_uri(),
// gtk_file_chooser_unselect_uri(), gtk_file_chooser_get_uri(),
// gtk_file_chooser_get_uris().
func (v *FileChooser) ConnectSelectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk3_FileChooser_ConnectSelectionChanged), f)
}

// ConnectUpdatePreview: this signal is emitted when the preview in a file
// chooser should be regenerated. For example, this can happen when the
// currently selected file changes. You should use this signal if you want your
// file chooser to have a preview widget.
//
// Once you have installed a preview widget with
// gtk_file_chooser_set_preview_widget(), you should update it when this signal
// is emitted. You can use the functions gtk_file_chooser_get_preview_filename()
// or gtk_file_chooser_get_preview_uri() to get the name of the file to preview.
// Your widget may not be able to preview all kinds of files; your callback must
// call gtk_file_chooser_set_preview_widget_active() to inform the file chooser
// about whether the preview was generated successfully or not.
//
// Please see the example code in [Using a Preview
// Widget][gtkfilechooser-preview].
//
// See also: gtk_file_chooser_set_preview_widget(),
// gtk_file_chooser_set_preview_widget_active(),
// gtk_file_chooser_set_use_preview_label(),
// gtk_file_chooser_get_preview_filename(), gtk_file_chooser_get_preview_uri().
func (v *FileChooser) ConnectUpdatePreview(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "update-preview", false, unsafe.Pointer(C._gotk4_gtk3_FileChooser_ConnectUpdatePreview), f)
}
