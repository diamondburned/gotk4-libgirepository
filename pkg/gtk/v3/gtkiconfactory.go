// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeIconFactory = coreglib.Type(girepository.MustFind("Gtk", "IconFactory").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIconFactory, F: marshalIconFactory},
	})
}

// IconFactoryOverrides contains methods that are overridable.
type IconFactoryOverrides struct {
}

func defaultIconFactoryOverrides(v *IconFactory) IconFactoryOverrides {
	return IconFactoryOverrides{}
}

// IconFactory: icon factory manages a collection of IconSet; a IconSet manages
// a set of variants of a particular icon (i.e. a IconSet contains variants for
// different sizes and widget states). Icons in an icon factory are named by a
// stock ID, which is a simple string identifying the icon. Each Style has a
// list of IconFactory derived from the current theme; those icon factories are
// consulted first when searching for an icon. If the theme doesnâ€™t set a
// particular icon, GTK+ looks for the icon in a list of default icon factories,
// maintained by gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should add a
// default icon factory with their icons, which will allow themes to override
// the icons for the application.
//
// To display an icon, always use gtk_style_lookup_icon_set() on the widget that
// will display the icon, or the convenience function gtk_widget_render_icon().
// These functions take the theme into account when looking up the icon to use
// for a given stock ID.
//
//
// GtkIconFactory as GtkBuildable
//
// GtkIconFactory supports a custom <sources> element, which can contain
// multiple <source> elements. The following attributes are allowed:
//
// - stock-id
//
//    The stock id of the source, a string. This attribute is
//    mandatory
//
// - filename
//
//    The filename of the source, a string.  This attribute is
//    optional
//
// - icon-name
//
//    The icon name for the source, a string.  This attribute is
//    optional.
//
// - size
//
//    Size of the icon, a IconSize enum value.  This attribute is
//    optional.
//
// - direction
//
//    Direction of the source, a TextDirection enum value.  This
//    attribute is optional.
//
// - state
//
//    State of the source, a StateType enum value.  This
//    attribute is optional.
//
// A IconFactory UI definition fragment. ##
//
//    <object class="GtkIconFactory" id="iconfactory1">
//      <sources>
//        <source stock-id="apple-red" filename="apple-red.png"/>
//      </sources>
//    </object>
//    <object class="GtkWindow" id="window1">
//      <child>
//        <object class="GtkButton" id="apple_button">
//          <property name="label">apple-red</property>
//          <property name="use-stock">True</property>
//        </object>
//      </child>
//    </object>.
type IconFactory struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*IconFactory)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*IconFactory, *IconFactoryClass, IconFactoryOverrides](
		GTypeIconFactory,
		initIconFactoryClass,
		wrapIconFactory,
		defaultIconFactoryOverrides,
	)
}

func initIconFactoryClass(gclass unsafe.Pointer, overrides IconFactoryOverrides, classInitFunc func(*IconFactoryClass)) {
	if classInitFunc != nil {
		class := (*IconFactoryClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIconFactory(obj *coreglib.Object) *IconFactory {
	return &IconFactory{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalIconFactory(p uintptr) (interface{}, error) {
	return wrapIconFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IconFactoryClass: instance of this type is always passed by reference.
type IconFactoryClass struct {
	*iconFactoryClass
}

// iconFactoryClass is the struct that's finalized.
type iconFactoryClass struct {
	native unsafe.Pointer
}

var GIRInfoIconFactoryClass = girepository.MustFind("Gtk", "IconFactoryClass")
