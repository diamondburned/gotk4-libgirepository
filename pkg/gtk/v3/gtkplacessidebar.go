// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_PlacesSidebar_ConnectUnmount(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_PlacesSidebar_ConnectShowOtherLocations(gpointer, guintptr);
// extern void _gotk4_gtk3_PlacesSidebar_ConnectShowErrorMessage(gpointer, gchar*, gchar*, guintptr);
// extern void _gotk4_gtk3_PlacesSidebar_ConnectShowEnterLocation(gpointer, guintptr);
// extern void _gotk4_gtk3_PlacesSidebar_ConnectShowConnectToServer(gpointer, guintptr);
// extern void _gotk4_gtk3_PlacesSidebar_ConnectPopulatePopup(gpointer, void*, void*, void*, guintptr);
// extern void _gotk4_gtk3_PlacesSidebar_ConnectMount(gpointer, void*, guintptr);
// extern gint _gotk4_gtk3_PlacesSidebar_ConnectDragActionAsk(gpointer, gint, guintptr);
import "C"

// GType values.
var (
	GTypePlacesOpenFlags = coreglib.Type(girepository.MustFind("Gtk", "PlacesOpenFlags").RegisteredGType())
	GTypePlacesSidebar   = coreglib.Type(girepository.MustFind("Gtk", "PlacesSidebar").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePlacesOpenFlags, F: marshalPlacesOpenFlags},
		coreglib.TypeMarshaler{T: GTypePlacesSidebar, F: marshalPlacesSidebar},
	})
}

// PlacesOpenFlags: these flags serve two purposes. First, the application can
// call gtk_places_sidebar_set_open_flags() using these flags as a bitmask. This
// tells the sidebar that the application is able to open folders selected from
// the sidebar in various ways, for example, in new tabs or in new windows in
// addition to the normal mode.
//
// Second, when one of these values gets passed back to the application in the
// PlacesSidebar::open-location signal, it means that the application should
// open the selected location in the normal way, in a new tab, or in a new
// window. The sidebar takes care of determining the desired way to open the
// location, based on the modifier keys that the user is pressing at the time
// the selection is made.
//
// If the application never calls gtk_places_sidebar_set_open_flags(), then the
// sidebar will only use K_PLACES_OPEN_NORMAL in the
// PlacesSidebar::open-location signal. This is the default mode of operation.
type PlacesOpenFlags C.guint

const (
	// PlacesOpenNormal: this is the default mode that PlacesSidebar uses if no
	// other flags are specified. It indicates that the calling application
	// should open the selected location in the normal way, for example, in the
	// folder view beside the sidebar.
	PlacesOpenNormal PlacesOpenFlags = 0b1
	// PlacesOpenNewTab: when passed to gtk_places_sidebar_set_open_flags(),
	// this indicates that the application can open folders selected from the
	// sidebar in new tabs. This value will be passed to the
	// PlacesSidebar::open-location signal when the user selects that a location
	// be opened in a new tab instead of in the standard fashion.
	PlacesOpenNewTab PlacesOpenFlags = 0b10
	// PlacesOpenNewWindow: similar to GTK_PLACES_OPEN_NEW_TAB, but indicates
	// that the application can open folders in new windows.
	PlacesOpenNewWindow PlacesOpenFlags = 0b100
)

func marshalPlacesOpenFlags(p uintptr) (interface{}, error) {
	return PlacesOpenFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PlacesOpenFlags.
func (p PlacesOpenFlags) String() string {
	if p == 0 {
		return "PlacesOpenFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(53)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PlacesOpenNormal:
			builder.WriteString("Normal|")
		case PlacesOpenNewTab:
			builder.WriteString("NewTab|")
		case PlacesOpenNewWindow:
			builder.WriteString("NewWindow|")
		default:
			builder.WriteString(fmt.Sprintf("PlacesOpenFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PlacesOpenFlags) Has(other PlacesOpenFlags) bool {
	return (p & other) == other
}

// PlacesSidebar is a widget that displays a list of frequently-used places in
// the file system: the user’s home directory, the user’s bookmarks, and volumes
// and drives. This widget is used as a sidebar in FileChooser and may be used
// by file managers and similar programs.
//
// The places sidebar displays drives and volumes, and will automatically mount
// or unmount them when the user selects them.
//
// Applications can hook to various signals in the places sidebar to customize
// its behavior. For example, they can add extra commands to the context menu of
// the sidebar.
//
// While bookmarks are completely in control of the user, the places sidebar
// also allows individual applications to provide extra shortcut folders that
// are unique to each application. For example, a Paint program may want to add
// a shortcut for a Clipart folder. You can do this with
// gtk_places_sidebar_add_shortcut().
//
// To make use of the places sidebar, an application at least needs to connect
// to the PlacesSidebar::open-location signal. This is emitted when the user
// selects in the sidebar a location to open. The application should also call
// gtk_places_sidebar_set_location() when it changes the currently-viewed
// location.
//
//
// CSS nodes
//
// GtkPlacesSidebar uses a single CSS node with name placessidebar and style
// class .sidebar.
//
// Among the children of the places sidebar, the following style classes can be
// used:
//
// - .sidebar-new-bookmark-row for the 'Add new bookmark' row
//
// - .sidebar-placeholder-row for a row that is a placeholder
//
// - .has-open-popup when a popup is open for a row.
type PlacesSidebar struct {
	_ [0]func() // equal guard
	ScrolledWindow
}

var (
	_ Binner = (*PlacesSidebar)(nil)
)

func wrapPlacesSidebar(obj *coreglib.Object) *PlacesSidebar {
	return &PlacesSidebar{
		ScrolledWindow: ScrolledWindow{
			Bin: Bin{
				Container: Container{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						ImplementorIface: atk.ImplementorIface{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalPlacesSidebar(p uintptr) (interface{}, error) {
	return wrapPlacesSidebar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDragActionAsk places sidebar emits this signal when it needs to ask
// the application to pop up a menu to ask the user for which drag action to
// perform.
func (v *PlacesSidebar) ConnectDragActionAsk(f func(actions int) (gint int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-action-ask", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectDragActionAsk), f)
}

// ConnectMount places sidebar emits this signal when it starts a new operation
// because the user clicked on some location that needs mounting. In this way
// the application using the PlacesSidebar can track the progress of the
// operation and, for example, show a notification.
func (v *PlacesSidebar) ConnectMount(f func(mountOperation *gio.MountOperation)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "mount", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectMount), f)
}

// ConnectPopulatePopup places sidebar emits this signal when the user invokes a
// contextual popup on one of its items. In the signal handler, the application
// may add extra items to the menu as appropriate. For example, a file manager
// may want to add a "Properties" command to the menu.
//
// It is not necessary to store the selected_item for each menu item; during
// their callbacks, the application can use gtk_places_sidebar_get_location() to
// get the file to which the item refers.
//
// The selected_item argument may be NULL in case the selection refers to a
// volume. In this case, selected_volume will be non-NULL. In this case, the
// calling application will have to g_object_ref() the selected_volume and keep
// it around to use it in the callback.
//
// The container and all its contents are destroyed after the user dismisses the
// popup. The popup is re-created (and thus, this signal is emitted) every time
// the user activates the contextual menu.
//
// Before 3.18, the container always was a Menu, and you were expected to add
// your items as MenuItems. Since 3.18, the popup may be implemented as a
// Popover, in which case container will be something else, e.g. a Box, to which
// you may add ModelButtons or other widgets, such as Entries, SpinButtons, etc.
// If your application can deal with this situation, you can set
// PlacesSidebar::populate-all to TRUE to request that this signal is emitted
// for populating popovers as well.
func (v *PlacesSidebar) ConnectPopulatePopup(f func(container Widgetter, selectedItem gio.Filer, selectedVolume gio.Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "populate-popup", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectPopulatePopup), f)
}

// ConnectShowConnectToServer places sidebar emits this signal when it needs the
// calling application to present an way to connect directly to a network
// server. For example, the application may bring up a dialog box asking for a
// URL like "sftp://ftp.example.com". It is up to the application to create the
// corresponding mount by using, for example, g_file_mount_enclosing_volume().
func (v *PlacesSidebar) ConnectShowConnectToServer(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show-connect-to-server", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectShowConnectToServer), f)
}

// ConnectShowEnterLocation places sidebar emits this signal when it needs the
// calling application to present an way to directly enter a location. For
// example, the application may bring up a dialog box asking for a URL like
// "http://http.example.com".
func (v *PlacesSidebar) ConnectShowEnterLocation(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show-enter-location", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectShowEnterLocation), f)
}

// ConnectShowErrorMessage places sidebar emits this signal when it needs the
// calling application to present an error message. Most of these messages refer
// to mounting or unmounting media, for example, when a drive cannot be started
// for some reason.
func (v *PlacesSidebar) ConnectShowErrorMessage(f func(primary, secondary string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show-error-message", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectShowErrorMessage), f)
}

// ConnectShowOtherLocations places sidebar emits this signal when it needs the
// calling application to present a way to show other locations e.g. drives and
// network access points. For example, the application may bring up a page
// showing persistent volumes and discovered network addresses.
func (v *PlacesSidebar) ConnectShowOtherLocations(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show-other-locations", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectShowOtherLocations), f)
}

// ConnectUnmount places sidebar emits this signal when it starts a new
// operation because the user for example ejected some drive or unmounted a
// mount. In this way the application using the PlacesSidebar can track the
// progress of the operation and, for example, show a notification.
func (v *PlacesSidebar) ConnectUnmount(f func(mountOperation *gio.MountOperation)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unmount", false, unsafe.Pointer(C._gotk4_gtk3_PlacesSidebar_ConnectUnmount), f)
}
