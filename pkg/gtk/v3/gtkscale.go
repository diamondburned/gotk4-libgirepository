// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gchar* _gotk4_gtk3_Scale_ConnectFormatValue(gpointer, gdouble, guintptr);
import "C"

// GType values.
var (
	GTypeScale = coreglib.Type(girepository.MustFind("Gtk", "Scale").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeScale, F: marshalScale},
	})
}

// ScaleOverrides contains methods that are overridable.
type ScaleOverrides struct {
}

func defaultScaleOverrides(v *Scale) ScaleOverrides {
	return ScaleOverrides{}
}

// Scale is a slider control used to select a numeric value. To use it, you’ll
// probably want to investigate the methods on its base class, Range, in
// addition to the methods for GtkScale itself. To set the value of a scale, you
// would normally use gtk_range_set_value(). To detect changes to the value, you
// would normally use the Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the Scale (through the
// Range methods) will hide the slider itself. This is useful for applications
// that want to show an undeterminate value on the scale, without changing the
// layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple <mark>
// elements. The “value” and “position” attributes have the same meaning as
// gtk_scale_add_mark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── [value]
//    ├── contents
//    │   ╰── trough
//    │       ├── slider
//    │       ├── [highlight]
//    │       ╰── [fill]
//    ╰── marks.bottom
//        ├── mark
//        ┊    ├── indicator
//        ┊    ╰── [label]
//        ╰── mark
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the contents
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see Scale:draw-value), there is subnode
// with name value.
type Scale struct {
	_ [0]func() // equal guard
	Range
}

var (
	_ Ranger = (*Scale)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Scale, *ScaleClass, ScaleOverrides](
		GTypeScale,
		initScaleClass,
		wrapScale,
		defaultScaleOverrides,
	)
}

func initScaleClass(gclass unsafe.Pointer, overrides ScaleOverrides, classInitFunc func(*ScaleClass)) {
	if classInitFunc != nil {
		class := (*ScaleClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapScale(obj *coreglib.Object) *Scale {
	return &Scale{
		Range: Range{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	return wrapScale(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectFormatValue: signal which allows you to change how the scale value is
// displayed. Connect a signal handler which returns an allocated string
// representing value. That string will then be used to display the scale's
// value.
//
// If no user-provided handlers are installed, the value will be displayed on
// its own, rounded according to the value of the Scale:digits property.
//
// Here's an example signal handler which displays a value 1.0 as with
// "-->1.0<--".
//
//    static gchar*
//    format_value_callback (GtkScale *scale,
//                           gdouble   value)
//    {
//      return g_strdup_printf ("-->\0.*g<--",
//                              gtk_scale_get_digits (scale), value);
//     }.
func (v *Scale) ConnectFormatValue(f func(value float64) (utf8 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "format-value", false, unsafe.Pointer(C._gotk4_gtk3_Scale_ConnectFormatValue), f)
}

// ScaleClass: instance of this type is always passed by reference.
type ScaleClass struct {
	*scaleClass
}

// scaleClass is the struct that's finalized.
type scaleClass struct {
	native unsafe.Pointer
}

var GIRInfoScaleClass = girepository.MustFind("Gtk", "ScaleClass")
