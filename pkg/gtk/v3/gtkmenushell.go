// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_MenuShell_ConnectSelectionDone(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectInsert(gpointer, void*, gint, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectDeactivate(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectCancel(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectActivateCurrent(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_MenuShell_ConnectMoveSelected(gpointer, gint, guintptr);
import "C"

// GType values.
var (
	GTypeMenuShell = coreglib.Type(girepository.MustFind("Gtk", "MenuShell").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMenuShell, F: marshalMenuShell},
	})
}

// MenuShellOverrides contains methods that are overridable.
type MenuShellOverrides struct {
}

func defaultMenuShellOverrides(v *MenuShell) MenuShellOverrides {
	return MenuShellOverrides{}
}

// MenuShell is the abstract base class used to derive the Menu and MenuBar
// subclasses.
//
// A MenuShell is a container of MenuItem objects arranged in a list which can
// be navigated, selected, and activated by the user to perform application
// functions. A MenuItem can have a submenu associated with it, allowing for
// nested hierarchical menus.
//
//
// Terminology
//
// A menu item can be “selected”, this means that it is displayed in the
// prelight state, and if it has a submenu, that submenu will be popped up.
//
// A menu is “active” when it is visible onscreen and the user is selecting from
// it. A menubar is not active until the user clicks on one of its menuitems.
// When a menu is active, passing the mouse over a submenu will pop it up.
//
// There is also is a concept of the current menu and a current menu item. The
// current menu item is the selected menu item that is furthest down in the
// hierarchy. (Every active menu shell does not necessarily contain a selected
// menu item, but if it does, then the parent menu shell must also contain a
// selected menu item.) The current menu is the menu that contains the current
// menu item. It will always have a GTK grab and receive all key presses.
type MenuShell struct {
	_ [0]func() // equal guard
	Container
}

var (
	_ Containerer = (*MenuShell)(nil)
)

// MenuSheller describes types inherited from class MenuShell.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuSheller interface {
	coreglib.Objector
	baseMenuShell() *MenuShell
}

var _ MenuSheller = (*MenuShell)(nil)

func init() {
	coreglib.RegisterClassInfo[*MenuShell, *MenuShellClass, MenuShellOverrides](
		GTypeMenuShell,
		initMenuShellClass,
		wrapMenuShell,
		defaultMenuShellOverrides,
	)
}

func initMenuShellClass(gclass unsafe.Pointer, overrides MenuShellOverrides, classInitFunc func(*MenuShellClass)) {
	if classInitFunc != nil {
		class := (*MenuShellClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenuShell(obj *coreglib.Object) *MenuShell {
	return &MenuShell{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalMenuShell(p uintptr) (interface{}, error) {
	return wrapMenuShell(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *MenuShell) baseMenuShell() *MenuShell {
	return v
}

// BaseMenuShell returns the underlying base object.
func BaseMenuShell(obj MenuSheller) *MenuShell {
	return obj.baseMenuShell()
}

// ConnectActivateCurrent: action signal that activates the current menu item
// within the menu shell.
func (v *MenuShell) ConnectActivateCurrent(f func(forceHide bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate-current", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectActivateCurrent), f)
}

// ConnectCancel: action signal which cancels the selection within the menu
// shell. Causes the MenuShell::selection-done signal to be emitted.
func (v *MenuShell) ConnectCancel(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "cancel", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectCancel), f)
}

// ConnectDeactivate: this signal is emitted when a menu shell is deactivated.
func (v *MenuShell) ConnectDeactivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "deactivate", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectDeactivate), f)
}

// ConnectInsert signal is emitted when a new MenuItem is added to a MenuShell.
// A separate signal is used instead of GtkContainer::add because of the need
// for an additional position parameter.
//
// The inverse of this signal is the GtkContainer::removed signal.
func (v *MenuShell) ConnectInsert(f func(child Widgetter, position int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectInsert), f)
}

// ConnectMoveSelected signal is emitted to move the selection to another item.
func (v *MenuShell) ConnectMoveSelected(f func(distance int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "move-selected", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectMoveSelected), f)
}

// ConnectSelectionDone: this signal is emitted when a selection has been
// completed within a menu shell.
func (v *MenuShell) ConnectSelectionDone(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-done", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectSelectionDone), f)
}

// MenuShellClass: instance of this type is always passed by reference.
type MenuShellClass struct {
	*menuShellClass
}

// menuShellClass is the struct that's finalized.
type menuShellClass struct {
	native unsafe.Pointer
}

var GIRInfoMenuShellClass = girepository.MustFind("Gtk", "MenuShellClass")
