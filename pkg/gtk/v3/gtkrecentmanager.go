// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
//
// An instance of this type is always passed by reference.
type RecentData struct {
	*recentData
}

// recentData is the struct that's finalized.
type recentData struct {
	native unsafe.Pointer
}

var GIRInfoRecentData = girepository.MustFind("Gtk", "RecentData")

// DisplayName: UTF-8 encoded string, containing the name of the recently used
// resource to be displayed, or NULL;.
func (r *RecentData) DisplayName() string {
	offset := GIRInfoRecentData.StructFieldOffset("display_name")
	valptr := (*string)(unsafe.Add(r.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Description: UTF-8 encoded string, containing a short description of the
// resource, or NULL;.
func (r *RecentData) Description() string {
	offset := GIRInfoRecentData.StructFieldOffset("description")
	valptr := (*string)(unsafe.Add(r.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// MIMEType: MIME type of the resource;.
func (r *RecentData) MIMEType() string {
	offset := GIRInfoRecentData.StructFieldOffset("mime_type")
	valptr := (*string)(unsafe.Add(r.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// AppName: name of the application that is registering this recently used
// resource;.
func (r *RecentData) AppName() string {
	offset := GIRInfoRecentData.StructFieldOffset("app_name")
	valptr := (*string)(unsafe.Add(r.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// AppExec: command line used to launch this resource; may contain the “\f” and
// “\u” escape characters which will be expanded to the resource file path and
// URI respectively when the command line is retrieved;.
func (r *RecentData) AppExec() string {
	offset := GIRInfoRecentData.StructFieldOffset("app_exec")
	valptr := (*string)(unsafe.Add(r.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Groups: vector of strings containing groups names;.
func (r *RecentData) Groups() []string {
	offset := GIRInfoRecentData.StructFieldOffset("groups")
	valptr := (*[]string)(unsafe.Add(r.native, offset))
	var _v []string // out
	{
		var i int
		var z *C.gchar
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]string, i)
		for i := range src {
			_v[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}
	return _v
}

// IsPrivate: whether this resource should be displayed only by the applications
// that have registered it or not.
func (r *RecentData) IsPrivate() bool {
	offset := GIRInfoRecentData.StructFieldOffset("is_private")
	valptr := (*bool)(unsafe.Add(r.native, offset))
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// IsPrivate: whether this resource should be displayed only by the applications
// that have registered it or not.
func (r *RecentData) SetIsPrivate(isPrivate bool) {
	offset := GIRInfoRecentData.StructFieldOffset("is_private")
	valptr := (*C.gboolean)(unsafe.Add(r.native, offset))
	if isPrivate {
		*valptr = C.TRUE
	}
}
