// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_Entry_ConnectToggleOverwrite(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPopulatePopup(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectActivate(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeEntry = coreglib.Type(girepository.MustFind("Gtk", "Entry").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeEntry, F: marshalEntry},
	})
}

// EntryOverrides contains methods that are overridable.
type EntryOverrides struct {
}

func defaultEntryOverrides(v *Entry) EntryOverrides {
	return EntryOverrides{}
}

// Entry widget is a single line text entry widget. A fairly large set of key
// bindings are supported by default. If the entered text is longer than the
// allocation of the widget, the widget will scroll so that the cursor position
// is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK+
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char(). Since 2.16, GTK+
// displays a warning when Caps Lock or input methods might interfere with
// entering text in a password entry. The warning can be turned off with the
// Entry:caps-lock-warning property.
//
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from a stock id, an icon name or
// a pixbuf. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.read-only][.flat][.warning][.error]
//    ├── image.left
//    ├── image.right
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [progress[.pulse]]
//    ╰── [window.popup]
//
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// The CSS node for a context menu is added as a subnode below entry as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
type Entry struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellEditable
	Editable
}

var (
	_ Widgetter         = (*Entry)(nil)
	_ coreglib.Objector = (*Entry)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Entry, *EntryClass, EntryOverrides](
		GTypeEntry,
		initEntryClass,
		wrapEntry,
		defaultEntryOverrides,
	)
}

func initEntryClass(gclass unsafe.Pointer, overrides EntryOverrides, classInitFunc func(*EntryClass)) {
	if classInitFunc != nil {
		class := (*EntryClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapEntry(obj *coreglib.Object) *Entry {
	return &Entry{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
		Object: obj,
		CellEditable: CellEditable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Editable: Editable{
			Object: obj,
		},
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	return wrapEntry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate signal is emitted when the user hits the Enter key.
//
// While this signal is used as a [keybinding signal][GtkBindingSignal], it is
// also commonly used by applications to intercept activation of entries.
//
// The default bindings for this signal are all forms of the Enter key.
func (v *Entry) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectActivate), f)
}

// ConnectBackspace signal is a [keybinding signal][GtkBindingSignal] which gets
// emitted when the user asks for it.
//
// The default bindings for this signal are Backspace and Shift-Backspace.
func (v *Entry) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "backspace", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectBackspace), f)
}

// ConnectCopyClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to copy the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-c and Ctrl-Insert.
func (v *Entry) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectCopyClipboard), f)
}

// ConnectCutClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to cut the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-x and Shift-Delete.
func (v *Entry) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectCutClipboard), f)
}

// ConnectInsertAtCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates the insertion of a fixed string at the
// cursor.
//
// This signal has no default bindings.
func (v *Entry) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectInsertAtCursor), f)
}

// ConnectInsertEmoji signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to present the Emoji chooser for the entry.
//
// The default bindings for this signal are Ctrl-. and Ctrl-;.
func (v *Entry) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectInsertEmoji), f)
}

// ConnectPasteClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to paste the contents of the clipboard into the text view.
//
// The default bindings for this signal are Ctrl-v and Shift-Insert.
func (v *Entry) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPasteClipboard), f)
}

// ConnectPopulatePopup signal gets emitted before showing the context menu of
// the entry.
//
// If you need to add items to the context menu, connect to this signal and
// append your items to the widget, which will be a Menu in this case.
//
// If Entry:populate-all is TRUE, this signal will also be emitted to populate
// touch popups. In this case, widget will be a different container, e.g. a
// Toolbar. The signal handler should not make assumptions about the type of
// widget.
func (v *Entry) ConnectPopulatePopup(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "populate-popup", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPopulatePopup), f)
}

// ConnectPreeditChanged: if an input method is used, the typed text will not
// immediately be committed to the buffer. So if you are interested in the text,
// connect to this signal.
func (v *Entry) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPreeditChanged), f)
}

// ConnectToggleOverwrite signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted to toggle the overwrite mode of the entry.
//
// The default bindings for this signal is Insert.
func (v *Entry) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectToggleOverwrite), f)
}

// EntryClass class structure for Entry. All virtual functions have a default
// implementation. Derived classes may set the virtual function pointers for the
// signal handlers to NULL, but must keep get_text_area_size and get_frame_size
// non-NULL; either use the default implementation, or provide a custom one.
//
// An instance of this type is always passed by reference.
type EntryClass struct {
	*entryClass
}

// entryClass is the struct that's finalized.
type entryClass struct {
	native unsafe.Pointer
}

var GIRInfoEntryClass = girepository.MustFind("Gtk", "EntryClass")
