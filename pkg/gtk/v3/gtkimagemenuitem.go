// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeImageMenuItem = coreglib.Type(girepository.MustFind("Gtk", "ImageMenuItem").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeImageMenuItem, F: marshalImageMenuItem},
	})
}

// ImageMenuItemOverrides contains methods that are overridable.
type ImageMenuItemOverrides struct {
}

func defaultImageMenuItemOverrides(v *ImageMenuItem) ImageMenuItemOverrides {
	return ImageMenuItemOverrides{}
}

// ImageMenuItem is a menu item which has an icon next to the text label.
//
// This is functionally equivalent to:
//
//      GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
//      GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
//      GtkWidget *label = gtk_accel_label_new ("Music");
//      GtkWidget *menu_item = gtk_menu_item_new ();
//      GtkAccelGroup *accel_group = gtk_accel_group_new ();
//
//      gtk_container_add (GTK_CONTAINER (box), icon);
//
//      gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
//      gtk_label_set_xalign (GTK_LABEL (label), 0.0);
//
//      gtk_widget_add_accelerator (menu_item, "activate", accel_group,
//                                  GDK_KEY_m, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
//      gtk_accel_label_set_accel_widget (GTK_ACCEL_LABEL (label), menu_item);
//
//      gtk_box_pack_end (GTK_BOX (box), label, TRUE, TRUE, 0);
//
//      gtk_container_add (GTK_CONTAINER (menu_item), box);
//
//      gtk_widget_show_all (menu_item);.
type ImageMenuItem struct {
	_ [0]func() // equal guard
	MenuItem
}

var (
	_ Binner            = (*ImageMenuItem)(nil)
	_ coreglib.Objector = (*ImageMenuItem)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ImageMenuItem, *ImageMenuItemClass, ImageMenuItemOverrides](
		GTypeImageMenuItem,
		initImageMenuItemClass,
		wrapImageMenuItem,
		defaultImageMenuItemOverrides,
	)
}

func initImageMenuItemClass(gclass unsafe.Pointer, overrides ImageMenuItemOverrides, classInitFunc func(*ImageMenuItemClass)) {
	if classInitFunc != nil {
		class := (*ImageMenuItemClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapImageMenuItem(obj *coreglib.Object) *ImageMenuItem {
	return &ImageMenuItem{
		MenuItem: MenuItem{
			Bin: Bin{
				Container: Container{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						ImplementorIface: atk.ImplementorIface{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
					},
				},
			},
			Object: obj,
			Actionable: Actionable{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
			Activatable: Activatable{
				Object: obj,
			},
		},
	}
}

func marshalImageMenuItem(p uintptr) (interface{}, error) {
	return wrapImageMenuItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ImageMenuItemClass: instance of this type is always passed by reference.
type ImageMenuItemClass struct {
	*imageMenuItemClass
}

// imageMenuItemClass is the struct that's finalized.
type imageMenuItemClass struct {
	native unsafe.Pointer
}

var GIRInfoImageMenuItemClass = girepository.MustFind("Gtk", "ImageMenuItemClass")
