// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_Widget_ConnectUnrealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectUnmap(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStyleUpdated(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStyleSet(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSizeAllocate(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSelectionReceived(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSelectionGet(gpointer, void*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectScreenChanged(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectParentSet(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectMap(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectHierarchyChanged(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectGrabNotify(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectGrabFocus(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragLeave(gpointer, void*, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragEnd(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataReceived(gpointer, void*, gint, gint, void*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataGet(gpointer, void*, void*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataDelete(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragBegin(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDestroy(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectCompositedChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectAccelClosuresChanged(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectWindowStateEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectUnmapEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionRequestEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionClearEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectScrollEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectQueryTooltip(gpointer, gint, gint, gboolean, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectProximityOutEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectProximityInEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectPopupMenu(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMotionNotifyEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMnemonicActivate(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMapEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeyReleaseEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeyPressEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectGrabBrokenEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocusOutEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocusInEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectEnterNotifyEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDraw(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragMotion(gpointer, void*, gint, gint, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragDrop(gpointer, void*, gint, gint, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDamageEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectConfigureEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectCanActivateAccel(gpointer, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectButtonReleaseEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectButtonPressEvent(gpointer, void*, guintptr);
import "C"

// GType values.
var (
	GTypeWidgetHelpType = coreglib.Type(girepository.MustFind("Gtk", "WidgetHelpType").RegisteredGType())
	GTypeWidget         = coreglib.Type(girepository.MustFind("Gtk", "Widget").RegisteredGType())
	GTypeRequisition    = coreglib.Type(girepository.MustFind("Gtk", "Requisition").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWidgetHelpType, F: marshalWidgetHelpType},
		coreglib.TypeMarshaler{T: GTypeWidget, F: marshalWidget},
		coreglib.TypeMarshaler{T: GTypeRequisition, F: marshalRequisition},
	})
}

// Allocation of a widget represents region which has been allocated to the
// widget by its parent. It is a subregion of its parents allocation. See
// [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Allocation = gdk.Rectangle

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType C.gint

const (
	// WidgetHelpTooltip: tooltip.
	WidgetHelpTooltip WidgetHelpType = iota
	// WidgetHelpWhatsThis what’s this.
	WidgetHelpWhatsThis
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WidgetHelpType.
func (w WidgetHelpType) String() string {
	switch w {
	case WidgetHelpTooltip:
		return "Tooltip"
	case WidgetHelpWhatsThis:
		return "WhatsThis"
	default:
		return fmt.Sprintf("WidgetHelpType(%d)", w)
	}
}

// Callback: type of the callback functions used for e.g. iterating over the
// children of a container, see gtk_container_foreach().
type Callback func(widget Widgetter)

// WidgetOverrides contains methods that are overridable.
type WidgetOverrides struct {
}

func defaultWidgetOverrides(v *Widget) WidgetOverrides {
	return WidgetOverrides{}
}

// Widget is the base class all widgets in GTK+ derive from. It manages the
// widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK+ by way of five
// virtual methods:
//
// - WidgetClass.get_request_mode()
//
// - WidgetClass.get_preferred_width()
//
// - WidgetClass.get_preferred_height()
//
// - WidgetClass.get_preferred_height_for_width()
//
// - WidgetClass.get_preferred_width_for_height()
//
// - WidgetClass.get_preferred_height_and_baseline_for_width()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_get_preferred_width(). Because
// the preferred widths for each container depend on the preferred widths of
// their children, this information propagates up the hierarchy, and finally a
// minimum and natural width is determined for the entire toplevel. Next, the
// toplevel will use the minimum width to query for the minimum height
// contextual to that width using gtk_widget_get_preferred_height_for_width(),
// which will also be a highly recursive operation. The minimum height for the
// minimum width is normally used to set the minimum size constraint on the
// toplevel (unless gtk_window_set_geometry_hints() is explicitly used instead).
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while container widgets allocate their children. Each
// container widget, once allocated a size, will go on to first share the space
// in one orientation among its children and then request each child's height
// for its target allocated width or its width for allocated height, depending.
// In this way a Widget will typically be requested its size a number of times
// before actually being allocated a size. The size a widget is finally
// allocated can of course differ from the size it has requested. For this
// reason, Widget caches a small number of results to avoid re-querying for the
// same sizes in one allocation cycle.
//
// See [GtkContainer’s geometry management
// section][container-geometry-management] to learn more about how
// height-for-width allocations are performed by container widgets.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.get_preferred_height() called because that call is
// specific to a width-for-height request. In this case the label must return
// the height required for its own minimum possible width. By following this
// rule any widget that handles height-for-width or width-for-height requests
// will always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for
// WidgetClass.get_preferred_height() it will do:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }.
type Widget struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	atk.ImplementorIface
	Buildable
}

var (
	_ coreglib.Objector = (*Widget)(nil)
)

// Widgetter describes types inherited from class Widget.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Widgetter interface {
	coreglib.Objector
	baseWidget() *Widget
}

var _ Widgetter = (*Widget)(nil)

func init() {
	coreglib.RegisterClassInfo[*Widget, *WidgetClass, WidgetOverrides](
		GTypeWidget,
		initWidgetClass,
		wrapWidget,
		defaultWidgetOverrides,
	)
}

func initWidgetClass(gclass unsafe.Pointer, overrides WidgetOverrides, classInitFunc func(*WidgetClass)) {
	if classInitFunc != nil {
		class := (*WidgetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWidget(obj *coreglib.Object) *Widget {
	return &Widget{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	return wrapWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Widget) baseWidget() *Widget {
	return v
}

// BaseWidget returns the underlying base object.
func BaseWidget(obj Widgetter) *Widget {
	return obj.baseWidget()
}

func (v *Widget) ConnectAccelClosuresChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "accel-closures-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectAccelClosuresChanged), f)
}

// ConnectButtonPressEvent signal will be emitted when a button (typically from
// a mouse) is pressed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_BUTTON_PRESS_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectButtonPressEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "button-press-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectButtonPressEvent), f)
}

// ConnectButtonReleaseEvent signal will be emitted when a button (typically
// from a mouse) is released.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_BUTTON_RELEASE_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectButtonReleaseEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "button-release-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectButtonReleaseEvent), f)
}

// ConnectCanActivateAccel determines whether an accelerator that activates the
// signal identified by signal_id can currently be activated. This signal is
// present to allow applications and derived widgets to override the default
// Widget handling for determining whether an accelerator can be activated.
func (v *Widget) ConnectCanActivateAccel(f func(signalId uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "can-activate-accel", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectCanActivateAccel), f)
}

// ConnectCompositedChanged signal is emitted when the composited status of
// widgets screen changes. See gdk_screen_is_composited().
func (v *Widget) ConnectCompositedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "composited-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectCompositedChanged), f)
}

// ConnectConfigureEvent signal will be emitted when the size, position or
// stacking of the widget's window has changed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (v *Widget) ConnectConfigureEvent(f func(event *gdk.EventConfigure) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "configure-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectConfigureEvent), f)
}

// ConnectDamageEvent is emitted when a redirected window belonging to widget
// gets drawn into. The region/area members of the event shows what area of the
// redirected drawable was drawn into.
func (v *Widget) ConnectDamageEvent(f func(event *gdk.EventExpose) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "damage-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDamageEvent), f)
}

// ConnectDestroy signals that all holders of a reference to the widget should
// release the reference that they hold. May result in finalization of the
// widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (v *Widget) ConnectDestroy(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "destroy", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDestroy), f)
}

// ConnectDragBegin signal is emitted on the drag source when a drag is started.
// A typical reason to connect to this signal is to set up a custom drag icon
// with e.g. gtk_drag_source_set_icon_pixbuf().
//
// Note that some widgets set up a drag icon in the default handler of this
// signal, so you may have to use g_signal_connect_after() to override what the
// default handler did.
func (v *Widget) ConnectDragBegin(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-begin", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragBegin), f)
}

// ConnectDragDataDelete signal is emitted on the drag source when a drag with
// the action GDK_ACTION_MOVE is successfully completed. The signal handler is
// responsible for deleting the data that has been dropped. What "delete" means
// depends on the context of the drag operation.
func (v *Widget) ConnectDragDataDelete(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-data-delete", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataDelete), f)
}

// ConnectDragDataGet signal is emitted on the drag source when the drop site
// requests the data which is dragged. It is the responsibility of the signal
// handler to fill data with the data in the format which is indicated by info.
// See gtk_selection_data_set() and gtk_selection_data_set_text().
func (v *Widget) ConnectDragDataGet(f func(context *gdk.DragContext, data *SelectionData, info, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-data-get", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataGet), f)
}

// ConnectDragDataReceived signal is emitted on the drop site when the dragged
// data has been received. If the data was received in order to determine
// whether the drop will be accepted, the handler is expected to call
// gdk_drag_status() and not finish the drag. If the data was received in
// response to a Widget::drag-drop signal (and this is the last target to be
// received), the handler for this signal is expected to process the received
// data and then call gtk_drag_finish(), setting the success parameter depending
// on whether the data was processed successfully.
//
// Applications must create some means to determine why the signal was emitted
// and therefore whether to call gdk_drag_status() or gtk_drag_finish().
//
// The handler may inspect the selected action with
// gdk_drag_context_get_selected_action() before calling gtk_drag_finish(), e.g.
// to implement GDK_ACTION_ASK as shown in the following example:
//
//    void
//    drag_data_received (GtkWidget          *widget,
//                        GdkDragContext     *context,
//                        gint                x,
//                        gint                y,
//                        GtkSelectionData   *data,
//                        guint               info,
//                        guint               time)
//    {
//      if ((data->length >= 0) && (data->format == 8))
//        {
//          GdkDragAction action;
//
//          // handle data here
//
//          action = gdk_drag_context_get_selected_action (context);
//          if (action == GDK_ACTION_ASK)
//            {
//              GtkWidget *dialog;
//              gint response;
//
//              dialog = gtk_message_dialog_new (NULL,
//                                               GTK_DIALOG_MODAL |
//                                               GTK_DIALOG_DESTROY_WITH_PARENT,
//                                               GTK_MESSAGE_INFO,
//                                               GTK_BUTTONS_YES_NO,
//                                               "Move the data ?\n");
//              response = gtk_dialog_run (GTK_DIALOG (dialog));
//              gtk_widget_destroy (dialog);
//
//              if (response == GTK_RESPONSE_YES)
//                action = GDK_ACTION_MOVE;
//              else
//                action = GDK_ACTION_COPY;
//             }
//
//          gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
//        }
//      else
//        gtk_drag_finish (context, FALSE, FALSE, time);
//     }.
func (v *Widget) ConnectDragDataReceived(f func(context *gdk.DragContext, x, y int, data *SelectionData, info, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-data-received", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataReceived), f)
}

// ConnectDragDrop signal is emitted on the drop site when the user drops the
// data onto the widget. The signal handler must determine whether the cursor
// position is in a drop zone or not. If it is not in a drop zone, it returns
// FALSE and no further processing is necessary. Otherwise, the handler returns
// TRUE. In this case, the handler must ensure that gtk_drag_finish() is called
// to let the source know that the drop is done. The call to gtk_drag_finish()
// can be done either directly or in a Widget::drag-data-received handler which
// gets triggered by calling gtk_drag_get_data() to receive the data for one or
// more of the supported targets.
func (v *Widget) ConnectDragDrop(f func(context *gdk.DragContext, x, y int, time uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-drop", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDrop), f)
}

// ConnectDragEnd signal is emitted on the drag source when a drag is finished.
// A typical reason to connect to this signal is to undo things done in
// Widget::drag-begin.
func (v *Widget) ConnectDragEnd(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-end", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragEnd), f)
}

// ConnectDragLeave signal is emitted on the drop site when the cursor leaves
// the widget. A typical reason to connect to this signal is to undo things done
// in Widget::drag-motion, e.g. undo highlighting with gtk_drag_unhighlight().
//
//    Likewise, the Widget::drag-leave signal is also emitted before the ::drag-drop signal, for instance to allow cleaning up of a preview item created in the Widget::drag-motion signal handler.
func (v *Widget) ConnectDragLeave(f func(context *gdk.DragContext, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-leave", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragLeave), f)
}

// ConnectDragMotion signal is emitted on the drop site when the user moves the
// cursor over the widget during a drag. The signal handler must determine
// whether the cursor position is in a drop zone or not. If it is not in a drop
// zone, it returns FALSE and no further processing is necessary. Otherwise, the
// handler returns TRUE. In this case, the handler is responsible for providing
// the necessary information for displaying feedback to the user, by calling
// gdk_drag_status().
//
// If the decision whether the drop will be accepted or rejected can't be made
// based solely on the cursor position and the type of the data, the handler may
// inspect the dragged data by calling gtk_drag_get_data() and defer the
// gdk_drag_status() call to the Widget::drag-data-received handler. Note that
// you must pass K_DEST_DEFAULT_DROP, K_DEST_DEFAULT_MOTION or
// K_DEST_DEFAULT_ALL to gtk_drag_dest_set() when using the drag-motion signal
// that way.
//
// Also note that there is no drag-enter signal. The drag receiver has to keep
// track of whether he has received any drag-motion signals since the last
// Widget::drag-leave and if not, treat the drag-motion signal as an "enter"
// signal. Upon an "enter", the handler will typically highlight the drop site
// with gtk_drag_highlight().
//
//    static void
//    drag_motion (GtkWidget      *widget,
//                 GdkDragContext *context,
//                 gint            x,
//                 gint            y,
//                 guint           time)
//    {
//      GdkAtom target;
//
//      PrivateData *private_data = GET_PRIVATE_DATA (widget);
//
//      if (!private_data->drag_highlight)
//       {
//         private_data->drag_highlight = 1;
//         gtk_drag_highlight (widget);
//       }
//
//      target = gtk_drag_dest_find_target (widget, context, NULL);
//      if (target == GDK_NONE)
//        gdk_drag_status (context, 0, time);
//      else
//       {
//         private_data->pending_status
//            = gdk_drag_context_get_suggested_action (context);
//         gtk_drag_get_data (widget, context, target, time);
//       }
//
//      return TRUE;
//    }
//
//    static void
//    drag_data_received (GtkWidget        *widget,
//                        GdkDragContext   *context,
//                        gint              x,
//                        gint              y,
//                        GtkSelectionData *selection_data,
//                        guint             info,
//                        guint             time)
//    {
//      PrivateData *private_data = GET_PRIVATE_DATA (widget);
//
//      if (private_data->suggested_action)
//       {
//         private_data->suggested_action = 0;
//
//         // We are getting this data due to a request in drag_motion,
//         // rather than due to a request in drag_drop, so we are just
//         // supposed to call gdk_drag_status(), not actually paste in
//         // the data.
//
//         str = gtk_selection_data_get_text (selection_data);
//         if (!data_is_acceptable (str))
//           gdk_drag_status (context, 0, time);
//         else
//           gdk_drag_status (context,
//                            private_data->suggested_action,
//                            time);
//       }
//      else
//       {
//         // accept the drop
//       }
//    }.
func (v *Widget) ConnectDragMotion(f func(context *gdk.DragContext, x, y int, time uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drag-motion", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragMotion), f)
}

// ConnectDraw: this signal is emitted when a widget is supposed to render
// itself. The widget's top left corner must be painted at the origin of the
// passed in context and be sized to the values returned by
// gtk_widget_get_allocated_width() and gtk_widget_get_allocated_height().
//
// Signal handlers connected to this signal can modify the cairo context passed
// as cr in any way they like and don't need to restore it. The signal emission
// takes care of calling cairo_save() before and cairo_restore() after invoking
// the handler.
//
// The signal handler will get a cr with a clip region already set to the
// widget's dirty region, i.e. to the area that needs repainting. Complicated
// widgets that want to avoid redrawing themselves completely can get the full
// extents of the clip region with gdk_cairo_get_clip_rectangle(), or they can
// get a finer-grained representation of the dirty region with
// cairo_copy_clip_rectangle_list().
func (v *Widget) ConnectDraw(f func(cr *cairo.Context) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "draw", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDraw), f)
}

// ConnectEnterNotifyEvent will be emitted when the pointer enters the widget's
// window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_ENTER_NOTIFY_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectEnterNotifyEvent(f func(event *gdk.EventCrossing) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "enter-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEnterNotifyEvent), f)
}

// ConnectFocusInEvent signal will be emitted when the keyboard focus enters the
// widget's window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_FOCUS_CHANGE_MASK mask.
func (v *Widget) ConnectFocusInEvent(f func(event *gdk.EventFocus) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "focus-in-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocusInEvent), f)
}

// ConnectFocusOutEvent signal will be emitted when the keyboard focus leaves
// the widget's window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_FOCUS_CHANGE_MASK mask.
func (v *Widget) ConnectFocusOutEvent(f func(event *gdk.EventFocus) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "focus-out-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocusOutEvent), f)
}

// ConnectGrabBrokenEvent is emitted when a pointer or keyboard grab on a window
// belonging to widget gets broken.
//
// On X11, this happens when the grab window becomes unviewable (i.e. it or one
// of its ancestors is unmapped), or if the same application grabs the pointer
// or keyboard again.
func (v *Widget) ConnectGrabBrokenEvent(f func(event *gdk.EventGrabBroken) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "grab-broken-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabBrokenEvent), f)
}

func (v *Widget) ConnectGrabFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "grab-focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabFocus), f)
}

// ConnectGrabNotify signal is emitted when a widget becomes shadowed by a GTK+
// grab (not a pointer or keyboard grab) on another widget, or when it becomes
// unshadowed due to a grab being removed.
//
// A widget is shadowed by a gtk_grab_add() when the topmost grab widget in the
// grab stack of its window group is not its ancestor.
func (v *Widget) ConnectGrabNotify(f func(wasGrabbed bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "grab-notify", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabNotify), f)
}

// ConnectHide signal is emitted when widget is hidden, for example with
// gtk_widget_hide().
func (v *Widget) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "hide", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectHide), f)
}

// ConnectHierarchyChanged signal is emitted when the anchored state of a widget
// changes. A widget is “anchored” when its toplevel ancestor is a Window. This
// signal is emitted when a widget changes from un-anchored to anchored or
// vice-versa.
func (v *Widget) ConnectHierarchyChanged(f func(previousToplevel Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "hierarchy-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectHierarchyChanged), f)
}

// ConnectKeyPressEvent signal is emitted when a key is pressed. The signal
// emission will reoccur at the key-repeat rate when the key is kept pressed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_KEY_PRESS_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectKeyPressEvent(f func(event *gdk.EventKey) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "key-press-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeyPressEvent), f)
}

// ConnectKeyReleaseEvent signal is emitted when a key is released.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_KEY_RELEASE_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectKeyReleaseEvent(f func(event *gdk.EventKey) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "key-release-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeyReleaseEvent), f)
}

// ConnectLeaveNotifyEvent will be emitted when the pointer leaves the widget's
// window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_LEAVE_NOTIFY_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectLeaveNotifyEvent(f func(event *gdk.EventCrossing) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "leave-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectLeaveNotifyEvent), f)
}

// ConnectMap signal is emitted when widget is going to be mapped, that is when
// the widget is visible (which is controlled with gtk_widget_set_visible()) and
// all its parents up to the toplevel widget are also visible. Once the map has
// occurred, Widget::map-event will be emitted.
//
// The ::map signal can be used to determine whether a widget will be drawn, for
// instance it can resume an animation that was stopped during the emission of
// Widget::unmap.
func (v *Widget) ConnectMap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "map", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMap), f)
}

// ConnectMapEvent signal will be emitted when the widget's window is mapped. A
// window is mapped when it becomes visible on the screen.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (v *Widget) ConnectMapEvent(f func(event *gdk.EventAny) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "map-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMapEvent), f)
}

// ConnectMnemonicActivate: default handler for this signal activates widget if
// group_cycling is FALSE, or just makes widget grab focus if group_cycling is
// TRUE.
func (v *Widget) ConnectMnemonicActivate(f func(groupCycling bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "mnemonic-activate", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMnemonicActivate), f)
}

// ConnectMotionNotifyEvent signal is emitted when the pointer moves over the
// widget's Window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_POINTER_MOTION_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectMotionNotifyEvent(f func(event *gdk.EventMotion) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "motion-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMotionNotifyEvent), f)
}

// ConnectParentSet signal is emitted when a new parent has been set on a
// widget.
func (v *Widget) ConnectParentSet(f func(oldParent Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "parent-set", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectParentSet), f)
}

// ConnectPopupMenu: this signal gets emitted whenever a widget should pop up a
// context menu. This usually happens through the standard key binding
// mechanism; by pressing a certain key while a widget is focused, the user can
// cause the widget to pop up a menu. For example, the Entry widget creates a
// menu with clipboard commands. See the [Popup Menu Migration
// Checklist][checklist-popup-menu] for an example of how to use this signal.
func (v *Widget) ConnectPopupMenu(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "popup-menu", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectPopupMenu), f)
}

// ConnectPropertyNotifyEvent signal will be emitted when a property on the
// widget's window has been changed or deleted.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_PROPERTY_CHANGE_MASK mask.
func (v *Widget) ConnectPropertyNotifyEvent(f func(event *gdk.EventProperty) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "property-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectPropertyNotifyEvent), f)
}

// ConnectProximityInEvent: to receive this signal the Window associated to the
// widget needs to enable the K_PROXIMITY_IN_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectProximityInEvent(f func(event *gdk.EventProximity) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "proximity-in-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectProximityInEvent), f)
}

// ConnectProximityOutEvent: to receive this signal the Window associated to the
// widget needs to enable the K_PROXIMITY_OUT_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectProximityOutEvent(f func(event *gdk.EventProximity) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "proximity-out-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectProximityOutEvent), f)
}

// ConnectQueryTooltip is emitted when Widget:has-tooltip is TRUE and the hover
// timeout has expired with the cursor hovering "above" widget; or emitted when
// widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for widget. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
func (v *Widget) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectQueryTooltip), f)
}

// ConnectRealize signal is emitted when widget is associated with a Window,
// which means that gtk_widget_realize() has been called or the widget has been
// mapped (that is, it is going to be drawn).
func (v *Widget) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "realize", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectRealize), f)
}

// ConnectScreenChanged signal gets emitted when the screen of a widget has
// changed.
func (v *Widget) ConnectScreenChanged(f func(previousScreen *gdk.Screen)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "screen-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectScreenChanged), f)
}

// ConnectScrollEvent signal is emitted when a button in the 4 to 7 range is
// pressed. Wheel mice are usually configured to generate button press events
// for buttons 4 and 5 when the wheel is turned.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_SCROLL_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (v *Widget) ConnectScrollEvent(f func(event *gdk.EventScroll) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "scroll-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectScrollEvent), f)
}

// ConnectSelectionClearEvent signal will be emitted when the the widget's
// window has lost ownership of a selection.
func (v *Widget) ConnectSelectionClearEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-clear-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionClearEvent), f)
}

func (v *Widget) ConnectSelectionGet(f func(data *SelectionData, info, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-get", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionGet), f)
}

func (v *Widget) ConnectSelectionNotifyEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionNotifyEvent), f)
}

func (v *Widget) ConnectSelectionReceived(f func(data *SelectionData, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-received", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionReceived), f)
}

// ConnectSelectionRequestEvent signal will be emitted when another client
// requests ownership of the selection owned by the widget's window.
func (v *Widget) ConnectSelectionRequestEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "selection-request-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionRequestEvent), f)
}

// ConnectShow signal is emitted when widget is shown, for example with
// gtk_widget_show().
func (v *Widget) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectShow), f)
}

func (v *Widget) ConnectSizeAllocate(f func(allocation *Allocation)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "size-allocate", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSizeAllocate), f)
}

// ConnectStyleSet signal is emitted when a new style has been set on a widget.
// Note that style-modifying functions like gtk_widget_modify_base() also cause
// this signal to be emitted.
//
// Note that this signal is emitted for changes to the deprecated Style. To
// track changes to the StyleContext associated with a widget, use the
// Widget::style-updated signal.
func (v *Widget) ConnectStyleSet(f func(previousStyle *Style)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "style-set", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStyleSet), f)
}

// ConnectStyleUpdated signal is a convenience signal that is emitted when the
// StyleContext::changed signal is emitted on the widget's associated
// StyleContext as returned by gtk_widget_get_style_context().
//
// Note that style-modifying functions like gtk_widget_override_color() also
// cause this signal to be emitted.
func (v *Widget) ConnectStyleUpdated(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "style-updated", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStyleUpdated), f)
}

// ConnectUnmap signal is emitted when widget is going to be unmapped, which
// means that either it or any of its parents up to the toplevel widget have
// been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer, it can be
// used to, for example, stop an animation on the widget.
func (v *Widget) ConnectUnmap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unmap", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnmap), f)
}

// ConnectUnmapEvent signal will be emitted when the widget's window is
// unmapped. A window is unmapped when it becomes invisible on the screen.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (v *Widget) ConnectUnmapEvent(f func(event *gdk.EventAny) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unmap-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnmapEvent), f)
}

// ConnectUnrealize signal is emitted when the Window associated with widget is
// destroyed, which means that gtk_widget_unrealize() has been called or the
// widget has been unmapped (that is, it is going to be hidden).
func (v *Widget) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unrealize", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnrealize), f)
}

// ConnectVisibilityNotifyEvent will be emitted when the widget's window is
// obscured or unobscured.
//
// To receive this signal the Window associated to the widget needs to enable
// the K_VISIBILITY_NOTIFY_MASK mask.
func (v *Widget) ConnectVisibilityNotifyEvent(f func(event *gdk.EventVisibility) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "visibility-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent), f)
}

// ConnectWindowStateEvent will be emitted when the state of the toplevel window
// associated to the widget changes.
//
// To receive this signal the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (v *Widget) ConnectWindowStateEvent(f func(event *gdk.EventWindowState) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "window-state-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectWindowStateEvent), f)
}

// Requisition represents the desired size of a widget. See [GtkWidget’s
// geometry management section][geometry-management] for more information.
//
// An instance of this type is always passed by reference.
type Requisition struct {
	*requisition
}

// requisition is the struct that's finalized.
type requisition struct {
	native unsafe.Pointer
}

var GIRInfoRequisition = girepository.MustFind("Gtk", "Requisition")

func marshalRequisition(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Requisition{&requisition{(unsafe.Pointer)(b)}}, nil
}

// Width widget’s desired width.
func (r *Requisition) Width() int {
	offset := GIRInfoRequisition.StructFieldOffset("width")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height widget’s desired height.
func (r *Requisition) Height() int {
	offset := GIRInfoRequisition.StructFieldOffset("height")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width widget’s desired width.
func (r *Requisition) SetWidth(width int) {
	offset := GIRInfoRequisition.StructFieldOffset("width")
	valptr := (*C.gint)(unsafe.Add(r.native, offset))
	*valptr = C.gint(width)
}

// Height widget’s desired height.
func (r *Requisition) SetHeight(height int) {
	offset := GIRInfoRequisition.StructFieldOffset("height")
	valptr := (*C.gint)(unsafe.Add(r.native, offset))
	*valptr = C.gint(height)
}

// WidgetClass: instance of this type is always passed by reference.
type WidgetClass struct {
	*widgetClass
}

// widgetClass is the struct that's finalized.
type widgetClass struct {
	native unsafe.Pointer
}

var GIRInfoWidgetClass = girepository.MustFind("Gtk", "WidgetClass")

// ActivateSignal: signal to emit when a widget of this class is activated,
// gtk_widget_activate() handles the emission. Implementation of this signal is
// optional.
func (w *WidgetClass) ActivateSignal() uint {
	offset := GIRInfoWidgetClass.StructFieldOffset("activate_signal")
	valptr := (*uint)(unsafe.Add(w.native, offset))
	var _v uint // out
	_v = uint(*valptr)
	return _v
}
