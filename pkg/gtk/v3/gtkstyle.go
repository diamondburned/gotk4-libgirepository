// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_Style_ConnectUnrealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Style_ConnectRealize(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeExpanderStyle = coreglib.Type(girepository.MustFind("Gtk", "ExpanderStyle").RegisteredGType())
	GTypeStyle         = coreglib.Type(girepository.MustFind("Gtk", "Style").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeExpanderStyle, F: marshalExpanderStyle},
		coreglib.TypeMarshaler{T: GTypeStyle, F: marshalStyle},
	})
}

// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
type ExpanderStyle C.gint

const (
	// ExpanderCollapsed: style used for a collapsed subtree.
	ExpanderCollapsed ExpanderStyle = iota
	// ExpanderSemiCollapsed: intermediate style used during animation.
	ExpanderSemiCollapsed
	// ExpanderSemiExpanded: intermediate style used during animation.
	ExpanderSemiExpanded
	// ExpanderExpanded: style used for an expanded subtree.
	ExpanderExpanded
)

func marshalExpanderStyle(p uintptr) (interface{}, error) {
	return ExpanderStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ExpanderStyle.
func (e ExpanderStyle) String() string {
	switch e {
	case ExpanderCollapsed:
		return "Collapsed"
	case ExpanderSemiCollapsed:
		return "SemiCollapsed"
	case ExpanderSemiExpanded:
		return "SemiExpanded"
	case ExpanderExpanded:
		return "Expanded"
	default:
		return fmt.Sprintf("ExpanderStyle(%d)", e)
	}
}

// StyleOverrides contains methods that are overridable.
type StyleOverrides struct {
}

func defaultStyleOverrides(v *Style) StyleOverrides {
	return StyleOverrides{}
}

// Style object encapsulates the information that provides the look and feel for
// a widget.
//
// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by > StyleContext.
//
// Each Widget has an associated Style object that is used when rendering that
// widget. Also, a Style holds information for the five possible widget states
// though not every widget supports all five states; see StateType.
//
// Usually the Style for a widget is the same as the default style that is set
// by GTK+ and modified the theme engine.
//
// Usually applications should not need to use or modify the Style of their
// widgets.
type Style struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Style)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Style, *StyleClass, StyleOverrides](
		GTypeStyle,
		initStyleClass,
		wrapStyle,
		defaultStyleOverrides,
	)
}

func initStyleClass(gclass unsafe.Pointer, overrides StyleOverrides, classInitFunc func(*StyleClass)) {
	if classInitFunc != nil {
		class := (*StyleClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStyle(obj *coreglib.Object) *Style {
	return &Style{
		Object: obj,
	}
}

func marshalStyle(p uintptr) (interface{}, error) {
	return wrapStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRealize is emitted when the style has been initialized for a
// particular visual. Connecting to this signal is probably seldom useful since
// most of the time applications and widgets only deal with styles that have
// been already realized.
func (v *Style) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "realize", false, unsafe.Pointer(C._gotk4_gtk3_Style_ConnectRealize), f)
}

// ConnectUnrealize is emitted when the aspects of the style specific to a
// particular visual is being cleaned up. A connection to this signal can be
// useful if a widget wants to cache objects as object data on Style. This
// signal provides a convenient place to free such cached objects.
func (v *Style) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unrealize", false, unsafe.Pointer(C._gotk4_gtk3_Style_ConnectUnrealize), f)
}

// StyleClass: instance of this type is always passed by reference.
type StyleClass struct {
	*styleClass
}

// styleClass is the struct that's finalized.
type styleClass struct {
	native unsafe.Pointer
}

var GIRInfoStyleClass = girepository.MustFind("Gtk", "StyleClass")
