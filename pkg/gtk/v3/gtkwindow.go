// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_Window_ConnectSetFocus(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Window_ConnectKeysChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_Window_ConnectActivateFocus(gpointer, guintptr);
// extern void _gotk4_gtk3_Window_ConnectActivateDefault(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_Window_ConnectEnableDebugging(gpointer, gboolean, guintptr);
import "C"

// GType values.
var (
	GTypeWindowPosition = coreglib.Type(girepository.MustFind("Gtk", "WindowPosition").RegisteredGType())
	GTypeWindowType     = coreglib.Type(girepository.MustFind("Gtk", "WindowType").RegisteredGType())
	GTypeWindow         = coreglib.Type(girepository.MustFind("Gtk", "Window").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWindowPosition, F: marshalWindowPosition},
		coreglib.TypeMarshaler{T: GTypeWindowType, F: marshalWindowType},
		coreglib.TypeMarshaler{T: GTypeWindow, F: marshalWindow},
	})
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition C.gint

const (
	// WinPosNone: no influence is made on placement.
	WinPosNone WindowPosition = iota
	// WinPosCenter windows should be placed in the center of the screen.
	WinPosCenter
	// WinPosMouse windows should be placed at the current mouse position.
	WinPosMouse
	// WinPosCenterAlways: keep window centered as it changes size, etc.
	WinPosCenterAlways
	// WinPosCenterOnParent: center the window on its transient parent (see
	// gtk_window_set_transient_for()).
	WinPosCenterOnParent
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowPosition.
func (w WindowPosition) String() string {
	switch w {
	case WinPosNone:
		return "None"
	case WinPosCenter:
		return "Center"
	case WinPosMouse:
		return "Mouse"
	case WinPosCenterAlways:
		return "CenterAlways"
	case WinPosCenterOnParent:
		return "CenterOnParent"
	default:
		return fmt.Sprintf("WindowPosition(%d)", w)
	}
}

// WindowType can be one of these types. Most things you’d consider a “window”
// should have type K_WINDOW_TOPLEVEL; windows with this type are managed by the
// window manager and have a frame by default (call gtk_window_set_decorated()
// to toggle the frame). Windows with type K_WINDOW_POPUP are ignored by the
// window manager; window manager keybindings won’t work on them, the window
// manager won’t decorate the window with a frame, many GTK+ features that rely
// on the window manager will not work (e.g. resize grips and
// maximization/minimization). K_WINDOW_POPUP is used to implement widgets such
// as Menu or tooltips that you normally don’t think of as windows per se.
// Nearly all windows should be K_WINDOW_TOPLEVEL. In particular, do not use
// K_WINDOW_POPUP just to turn off the window borders; use
// gtk_window_set_decorated() for that.
type WindowType C.gint

const (
	// WindowToplevel: regular window, such as a dialog.
	WindowToplevel WindowType = iota
	// WindowPopup: special window such as a tooltip.
	WindowPopup
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowType.
func (w WindowType) String() string {
	switch w {
	case WindowToplevel:
		return "Toplevel"
	case WindowPopup:
		return "Popup"
	default:
		return fmt.Sprintf("WindowType(%d)", w)
	}
}

// WindowOverrides contains methods that are overridable.
type WindowOverrides struct {
}

func defaultWindowOverrides(v *Window) WindowOverrides {
	return WindowOverrides{}
}

// Window is a toplevel window which can contain other widgets. Windows normally
// have decorations that are under the control of the windowing system and allow
// the user to manipulate the window (resize it, move it, close it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
//
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
//
//    ...
//
//    <object class="GtkAccelGroup" id="accelgroup1"/>
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
type Window struct {
	_ [0]func() // equal guard
	Bin
}

var (
	_ Binner = (*Window)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Window, *WindowClass, WindowOverrides](
		GTypeWindow,
		initWindowClass,
		wrapWindow,
		defaultWindowOverrides,
	)
}

func initWindowClass(gclass unsafe.Pointer, overrides WindowOverrides, classInitFunc func(*WindowClass)) {
	if classInitFunc != nil {
		class := (*WindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWindow(obj *coreglib.Object) *Window {
	return &Window{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	return wrapWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateDefault signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user activates the default widget of window.
func (v *Window) ConnectActivateDefault(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate-default", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectActivateDefault), f)
}

// ConnectActivateFocus signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user activates the currently focused widget of window.
func (v *Window) ConnectActivateFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "activate-focus", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectActivateFocus), f)
}

// ConnectEnableDebugging signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user enables or disables interactive debugging.
// When toggle is TRUE, interactive debugging is toggled on or off, when it is
// FALSE, the debugger will be pointed at the widget under the pointer.
//
// The default bindings for this signal are Ctrl-Shift-I and Ctrl-Shift-D.
func (v *Window) ConnectEnableDebugging(f func(toggle bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "enable-debugging", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectEnableDebugging), f)
}

// ConnectKeysChanged signal gets emitted when the set of accelerators or
// mnemonics that are associated with window changes.
func (v *Window) ConnectKeysChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "keys-changed", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectKeysChanged), f)
}

// ConnectSetFocus: this signal is emitted whenever the currently focused widget
// in this window changes.
func (v *Window) ConnectSetFocus(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "set-focus", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectSetFocus), f)
}

// WindowClass: instance of this type is always passed by reference.
type WindowClass struct {
	*windowClass
}

// windowClass is the struct that's finalized.
type windowClass struct {
	native unsafe.Pointer
}

var GIRInfoWindowClass = girepository.MustFind("Gtk", "WindowClass")
