// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_ToolItem_ConnectToolbarReconfigured(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_ToolItem_ConnectCreateMenuProxy(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeToolItem = coreglib.Type(girepository.MustFind("Gtk", "ToolItem").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeToolItem, F: marshalToolItem},
	})
}

// ToolItemOverrides contains methods that are overridable.
type ToolItemOverrides struct {
}

func defaultToolItemOverrides(v *ToolItem) ToolItemOverrides {
	return ToolItemOverrides{}
}

// ToolItem are widgets that can appear on a toolbar. To create a toolbar item
// that contain something else than a button, use gtk_tool_item_new(). Use
// gtk_container_add() to add a child widget to the tool item.
//
// For toolbar items that contain buttons, see the ToolButton, ToggleToolButton
// and RadioToolButton classes.
//
// See the Toolbar class for a description of the toolbar widget, and ToolShell
// for a description of the tool shell interface.
type ToolItem struct {
	_ [0]func() // equal guard
	Bin

	*coreglib.Object
	Activatable
}

var (
	_ Binner            = (*ToolItem)(nil)
	_ coreglib.Objector = (*ToolItem)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ToolItem, *ToolItemClass, ToolItemOverrides](
		GTypeToolItem,
		initToolItemClass,
		wrapToolItem,
		defaultToolItemOverrides,
	)
}

func initToolItemClass(gclass unsafe.Pointer, overrides ToolItemOverrides, classInitFunc func(*ToolItemClass)) {
	if classInitFunc != nil {
		class := (*ToolItemClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapToolItem(obj *coreglib.Object) *ToolItem {
	return &ToolItem{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
		Object: obj,
		Activatable: Activatable{
			Object: obj,
		},
	}
}

func marshalToolItem(p uintptr) (interface{}, error) {
	return wrapToolItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateMenuProxy: this signal is emitted when the toolbar needs
// information from tool_item about whether the item should appear in the
// toolbar overflow menu. In response the tool item should either
//
// - call gtk_tool_item_set_proxy_menu_item() with a NULL pointer and return
// TRUE to indicate that the item should not appear in the overflow menu
//
// - call gtk_tool_item_set_proxy_menu_item() with a new menu item and return
// TRUE, or
//
// - return FALSE to indicate that the signal was not handled by the item. This
// means that the item will not appear in the overflow menu unless a later
// handler installs a menu item.
//
// The toolbar may cache the result of this signal. When the tool item changes
// how it will respond to this signal it must call gtk_tool_item_rebuild_menu()
// to invalidate the cache and ensure that the toolbar rebuilds its overflow
// menu.
func (v *ToolItem) ConnectCreateMenuProxy(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "create-menu-proxy", false, unsafe.Pointer(C._gotk4_gtk3_ToolItem_ConnectCreateMenuProxy), f)
}

// ConnectToolbarReconfigured: this signal is emitted when some property of the
// toolbar that the item is a child of changes. For custom subclasses of
// ToolItem, the default handler of this signal use the functions
//
// - gtk_tool_shell_get_orientation()
//
// - gtk_tool_shell_get_style()
//
// - gtk_tool_shell_get_icon_size()
//
// - gtk_tool_shell_get_relief_style() to find out what the toolbar should look
// like and change themselves accordingly.
func (v *ToolItem) ConnectToolbarReconfigured(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "toolbar-reconfigured", false, unsafe.Pointer(C._gotk4_gtk3_ToolItem_ConnectToolbarReconfigured), f)
}

// ToolItemClass: instance of this type is always passed by reference.
type ToolItemClass struct {
	*toolItemClass
}

// toolItemClass is the struct that's finalized.
type toolItemClass struct {
	native unsafe.Pointer
}

var GIRInfoToolItemClass = girepository.MustFind("Gtk", "ToolItemClass")
