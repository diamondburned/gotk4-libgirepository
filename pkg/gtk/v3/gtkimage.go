// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeImageType = coreglib.Type(girepository.MustFind("Gtk", "ImageType").RegisteredGType())
	GTypeImage     = coreglib.Type(girepository.MustFind("Gtk", "Image").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeImageType, F: marshalImageType},
		coreglib.TypeMarshaler{T: GTypeImage, F: marshalImage},
	})
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return NULL values.
type ImageType C.gint

const (
	// ImageEmpty: there is no image displayed by the widget.
	ImageEmpty ImageType = iota
	// ImagePixbuf: widget contains a Pixbuf.
	ImagePixbuf
	// ImageStock: widget contains a [stock item name][gtkstock].
	ImageStock
	// ImageIconSet: widget contains a IconSet.
	ImageIconSet
	// ImageAnimation: widget contains a PixbufAnimation.
	ImageAnimation
	// ImageIconName: widget contains a named icon. This image type was added in
	// GTK+ 2.6.
	ImageIconName
	// ImageGIcon: widget contains a #GIcon. This image type was added in GTK+
	// 2.14.
	ImageGIcon
	// ImageSurface: widget contains a #cairo_surface_t. This image type was
	// added in GTK+ 3.10.
	ImageSurface
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ImageType.
func (i ImageType) String() string {
	switch i {
	case ImageEmpty:
		return "Empty"
	case ImagePixbuf:
		return "Pixbuf"
	case ImageStock:
		return "Stock"
	case ImageIconSet:
		return "IconSet"
	case ImageAnimation:
		return "Animation"
	case ImageIconName:
		return "IconName"
	case ImageGIcon:
		return "GIcon"
	case ImageSurface:
		return "Surface"
	default:
		return fmt.Sprintf("ImageType(%d)", i)
	}
}

// ImageOverrides contains methods that are overridable.
type ImageOverrides struct {
}

func defaultImageOverrides(v *Image) ImageOverrides {
	return ImageOverrides{}
}

// Image widget displays an image. Various kinds of object can be displayed as
// an image; most typically, you would load a Pixbuf ("pixel buffer") from a
// file, and then display that. There’s a convenience function to do this,
// gtk_image_new_from_file(), used as follows:
//
//      static gboolean
//      button_press_callback (GtkWidget      *event_box,
//                             GdkEventButton *event,
//                             gpointer        data)
//      {
//        g_print ("Event box clicked at coordinates f,f\n",
//                 event->x, event->y);
//
//        // Returning TRUE means we handled the event, so the signal
//        // emission should be stopped (don’t call any further callbacks
//        // that may be connected). Return FALSE to continue invoking callbacks.
//        return TRUE;
//      }
//
//      static GtkWidget*
//      create_image (void)
//      {
//        GtkWidget *image;
//        GtkWidget *event_box;
//
//        image = gtk_image_new_from_file ("myfile.png");
//
//        event_box = gtk_event_box_new ();
//
//        gtk_container_add (GTK_CONTAINER (event_box), image);
//
//        g_signal_connect (G_OBJECT (event_box),
//                          "button_press_event",
//                          G_CALLBACK (button_press_callback),
//                          image);
//
//        return image;
//      }
//
// When handling events on the event box, keep in mind that coordinates in the
// image may be different from event box coordinates due to the alignment and
// padding settings on the image (see Misc). The simplest way to solve this is
// to set the alignment to 0.0 (left/top), and set the padding to zero. Then the
// origin of the image will be the same as the origin of the event box.
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. GTK+ comes with a program to avoid this, called
// “gdk-pixbuf-csource”. This library allows you to convert an image into a C
// variable declaration, which can then be loaded into a Pixbuf using
// gdk_pixbuf_new_from_inline().
//
//
// CSS nodes
//
// GtkImage has a single CSS node with the name image. The style classes may
// appear on image CSS nodes: .icon-dropshadow, .lowres-icon.
type Image struct {
	_ [0]func() // equal guard
	Misc
}

var (
	_ Miscer = (*Image)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Image, *ImageClass, ImageOverrides](
		GTypeImage,
		initImageClass,
		wrapImage,
		defaultImageOverrides,
	)
}

func initImageClass(gclass unsafe.Pointer, overrides ImageOverrides, classInitFunc func(*ImageClass)) {
	if classInitFunc != nil {
		class := (*ImageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapImage(obj *coreglib.Object) *Image {
	return &Image{
		Misc: Misc{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	return wrapImage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ImageClass: instance of this type is always passed by reference.
type ImageClass struct {
	*imageClass
}

// imageClass is the struct that's finalized.
type imageClass struct {
	native unsafe.Pointer
}

var GIRInfoImageClass = girepository.MustFind("Gtk", "ImageClass")
