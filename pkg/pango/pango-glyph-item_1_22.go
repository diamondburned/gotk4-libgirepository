// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeGlyphItemIter = coreglib.Type(girepository.MustFind("Pango", "GlyphItemIter").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGlyphItemIter, F: marshalGlyphItemIter},
	})
}

// GlyphItemIter: PangoGlyphItemIter is an iterator over the clusters in a
// PangoGlyphItem.
//
// The *forward direction* of the iterator is the logical direction of text.
// That is, with increasing start_index and start_char values. If glyph_item is
// right-to-left (that is, if glyph_item->item->analysis.level is odd), then
// start_glyph decreases as the iterator moves forward. Moreover, in
// right-to-left cases, start_glyph is greater than end_glyph.
//
// An iterator should be initialized using either
// pango_glyph_item_iter_init_start() or pango_glyph_item_iter_init_end(), for
// forward and backward iteration respectively, and walked over using any
// desired mixture of pango_glyph_item_iter_next_cluster() and
// pango_glyph_item_iter_prev_cluster().
//
// A common idiom for doing a forward iteration over the clusters is:
//
//    PangoGlyphItemIter cluster_iter;
//    gboolean have_cluster;
//
//    for (have_cluster = pango_glyph_item_iter_init_start (&cluster_iter,
//                                                          glyph_item, text);
//         have_cluster;
//         have_cluster = pango_glyph_item_iter_next_cluster (&cluster_iter))
//    {
//      ...
//    }
//
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset to get to the text of glyph_item. The start_index
// and end_index values can directly index into text. The start_glyph,
// end_glyph, start_char, and end_char values however are zero-based for the
// glyph_item. For each cluster, the item pointed at by the start variables is
// included in the cluster while the one pointed at by end variables is not.
//
// None of the members of a PangoGlyphItemIter should be modified manually.
//
// An instance of this type is always passed by reference.
type GlyphItemIter struct {
	*glyphItemIter
}

// glyphItemIter is the struct that's finalized.
type glyphItemIter struct {
	native unsafe.Pointer
}

var GIRInfoGlyphItemIter = girepository.MustFind("Pango", "GlyphItemIter")

func marshalGlyphItemIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GlyphItemIter{&glyphItemIter{(unsafe.Pointer)(b)}}, nil
}

func (g *GlyphItemIter) GlyphItem() *GlyphItem {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("glyph_item")
	valptr := (**GlyphItem)(unsafe.Add(g.native, offset))
	var _v *GlyphItem // out
	_v = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

func (g *GlyphItemIter) Text() string {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("text")
	valptr := (*string)(unsafe.Add(g.native, offset))
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (g *GlyphItemIter) StartGlyph() int {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("start_glyph")
	valptr := (*int)(unsafe.Add(g.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) StartIndex() int {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("start_index")
	valptr := (*int)(unsafe.Add(g.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) StartChar() int {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("start_char")
	valptr := (*int)(unsafe.Add(g.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) EndGlyph() int {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("end_glyph")
	valptr := (*int)(unsafe.Add(g.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) EndIndex() int {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("end_index")
	valptr := (*int)(unsafe.Add(g.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) EndChar() int {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("end_char")
	valptr := (*int)(unsafe.Add(g.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GlyphItemIter) SetStartGlyph(startGlyph int) {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("start_glyph")
	valptr := (*C.int)(unsafe.Add(g.native, offset))
	*valptr = C.int(startGlyph)
}

func (g *GlyphItemIter) SetStartIndex(startIndex int) {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("start_index")
	valptr := (*C.int)(unsafe.Add(g.native, offset))
	*valptr = C.int(startIndex)
}

func (g *GlyphItemIter) SetStartChar(startChar int) {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("start_char")
	valptr := (*C.int)(unsafe.Add(g.native, offset))
	*valptr = C.int(startChar)
}

func (g *GlyphItemIter) SetEndGlyph(endGlyph int) {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("end_glyph")
	valptr := (*C.int)(unsafe.Add(g.native, offset))
	*valptr = C.int(endGlyph)
}

func (g *GlyphItemIter) SetEndIndex(endIndex int) {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("end_index")
	valptr := (*C.int)(unsafe.Add(g.native, offset))
	*valptr = C.int(endIndex)
}

func (g *GlyphItemIter) SetEndChar(endChar int) {
	offset := GIRInfoGlyphItemIter.StructFieldOffset("end_char")
	valptr := (*C.int)(unsafe.Add(g.native, offset))
	*valptr = C.int(endChar)
}
