// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeMatrix = coreglib.Type(girepository.MustFind("Pango", "Matrix").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMatrix, F: marshalMatrix},
	})
}

// Matrix: PangoMatrix specifies a transformation between user-space and device
// coordinates.
//
// The transformation is given by
//
//    x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;
//    y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0;
//
//
// An instance of this type is always passed by reference.
type Matrix struct {
	*matrix
}

// matrix is the struct that's finalized.
type matrix struct {
	native unsafe.Pointer
}

var GIRInfoMatrix = girepository.MustFind("Pango", "Matrix")

func marshalMatrix(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Matrix{&matrix{(unsafe.Pointer)(b)}}, nil
}

// NewMatrix creates a new Matrix instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewMatrix(xx, xy, yx, yy, x0, y0 float64) Matrix {
	var f0 C.double // out
	f0 = C.double(xx)
	var f1 C.double // out
	f1 = C.double(xy)
	var f2 C.double // out
	f2 = C.double(yx)
	var f3 C.double // out
	f3 = C.double(yy)
	var f4 C.double // out
	f4 = C.double(x0)
	var f5 C.double // out
	f5 = C.double(y0)

	size := GIRInfoMatrix.StructSize()
	native := make([]byte, size)
	gextras.Sink(&native[0])

	offset0 := GIRInfoMatrix.StructFieldOffset("xx")
	valptr0 := (*C.double)(unsafe.Add(unsafe.Pointer(&native[0]), offset0))
	*valptr0 = f0

	offset1 := GIRInfoMatrix.StructFieldOffset("xy")
	valptr1 := (*C.double)(unsafe.Add(unsafe.Pointer(&native[0]), offset1))
	*valptr1 = f1

	offset2 := GIRInfoMatrix.StructFieldOffset("yx")
	valptr2 := (*C.double)(unsafe.Add(unsafe.Pointer(&native[0]), offset2))
	*valptr2 = f2

	offset3 := GIRInfoMatrix.StructFieldOffset("yy")
	valptr3 := (*C.double)(unsafe.Add(unsafe.Pointer(&native[0]), offset3))
	*valptr3 = f3

	offset4 := GIRInfoMatrix.StructFieldOffset("x0")
	valptr4 := (*C.double)(unsafe.Add(unsafe.Pointer(&native[0]), offset4))
	*valptr4 = f4

	offset5 := GIRInfoMatrix.StructFieldOffset("y0")
	valptr5 := (*C.double)(unsafe.Add(unsafe.Pointer(&native[0]), offset5))
	*valptr5 = f5

	return *(*Matrix)(gextras.NewStructNative(unsafe.Pointer(&native[0])))
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) XX() float64 {
	offset := GIRInfoMatrix.StructFieldOffset("xx")
	valptr := (*float64)(unsafe.Add(m.native, offset))
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) XY() float64 {
	offset := GIRInfoMatrix.StructFieldOffset("xy")
	valptr := (*float64)(unsafe.Add(m.native, offset))
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) YX() float64 {
	offset := GIRInfoMatrix.StructFieldOffset("yx")
	valptr := (*float64)(unsafe.Add(m.native, offset))
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) YY() float64 {
	offset := GIRInfoMatrix.StructFieldOffset("yy")
	valptr := (*float64)(unsafe.Add(m.native, offset))
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// X0: x translation.
func (m *Matrix) X0() float64 {
	offset := GIRInfoMatrix.StructFieldOffset("x0")
	valptr := (*float64)(unsafe.Add(m.native, offset))
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// Y0: y translation.
func (m *Matrix) Y0() float64 {
	offset := GIRInfoMatrix.StructFieldOffset("y0")
	valptr := (*float64)(unsafe.Add(m.native, offset))
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) SetXX(xx float64) {
	offset := GIRInfoMatrix.StructFieldOffset("xx")
	valptr := (*C.double)(unsafe.Add(m.native, offset))
	*valptr = C.double(xx)
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) SetXY(xy float64) {
	offset := GIRInfoMatrix.StructFieldOffset("xy")
	valptr := (*C.double)(unsafe.Add(m.native, offset))
	*valptr = C.double(xy)
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) SetYX(yx float64) {
	offset := GIRInfoMatrix.StructFieldOffset("yx")
	valptr := (*C.double)(unsafe.Add(m.native, offset))
	*valptr = C.double(yx)
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) SetYY(yy float64) {
	offset := GIRInfoMatrix.StructFieldOffset("yy")
	valptr := (*C.double)(unsafe.Add(m.native, offset))
	*valptr = C.double(yy)
}

// X0: x translation.
func (m *Matrix) SetX0(x0 float64) {
	offset := GIRInfoMatrix.StructFieldOffset("x0")
	valptr := (*C.double)(unsafe.Add(m.native, offset))
	*valptr = C.double(x0)
}

// Y0: y translation.
func (m *Matrix) SetY0(y0 float64) {
	offset := GIRInfoMatrix.StructFieldOffset("y0")
	valptr := (*C.double)(unsafe.Add(m.native, offset))
	*valptr = C.double(y0)
}
