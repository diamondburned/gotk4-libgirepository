// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAlignment     = coreglib.Type(girepository.MustFind("Pango", "Alignment").RegisteredGType())
	GTypeEllipsizeMode = coreglib.Type(girepository.MustFind("Pango", "EllipsizeMode").RegisteredGType())
	GTypeWrapMode      = coreglib.Type(girepository.MustFind("Pango", "WrapMode").RegisteredGType())
	GTypeLayout        = coreglib.Type(girepository.MustFind("Pango", "Layout").RegisteredGType())
	GTypeLayoutIter    = coreglib.Type(girepository.MustFind("Pango", "LayoutIter").RegisteredGType())
	GTypeLayoutLine    = coreglib.Type(girepository.MustFind("Pango", "LayoutLine").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAlignment, F: marshalAlignment},
		coreglib.TypeMarshaler{T: GTypeEllipsizeMode, F: marshalEllipsizeMode},
		coreglib.TypeMarshaler{T: GTypeWrapMode, F: marshalWrapMode},
		coreglib.TypeMarshaler{T: GTypeLayout, F: marshalLayout},
		coreglib.TypeMarshaler{T: GTypeLayoutIter, F: marshalLayoutIter},
		coreglib.TypeMarshaler{T: GTypeLayoutLine, F: marshalLayoutLine},
	})
}

// LayoutRun: PangoLayoutRun represents a single run within a PangoLayoutLine.
//
// It is simply an alternate name for pango.GlyphItem. See the pango.GlyphItem
// docs for details on the fields.
type LayoutRun = GlyphItem

// Alignment: PangoAlignment describes how to align the lines of a PangoLayout
// within the available space.
//
// If the PangoLayout is set to justify using pango.Layout.SetJustify(), this
// only has effect for partial lines.
type Alignment C.gint

const (
	// AlignLeft: put all available space on the right.
	AlignLeft Alignment = iota
	// AlignCenter: center the line within the available space.
	AlignCenter
	// AlignRight: put all available space on the left.
	AlignRight
)

func marshalAlignment(p uintptr) (interface{}, error) {
	return Alignment(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Alignment.
func (a Alignment) String() string {
	switch a {
	case AlignLeft:
		return "Left"
	case AlignCenter:
		return "Center"
	case AlignRight:
		return "Right"
	default:
		return fmt.Sprintf("Alignment(%d)", a)
	}
}

// EllipsizeMode: PangoEllipsizeMode describes what sort of ellipsization should
// be applied to text.
//
// In the ellipsization process characters are removed from the text in order to
// make it fit to a given width and replaced with an ellipsis.
type EllipsizeMode C.gint

const (
	// EllipsizeNone: no ellipsization.
	EllipsizeNone EllipsizeMode = iota
	// EllipsizeStart: omit characters at the start of the text.
	EllipsizeStart
	// EllipsizeMiddle: omit characters in the middle of the text.
	EllipsizeMiddle
	// EllipsizeEnd: omit characters at the end of the text.
	EllipsizeEnd
)

func marshalEllipsizeMode(p uintptr) (interface{}, error) {
	return EllipsizeMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EllipsizeMode.
func (e EllipsizeMode) String() string {
	switch e {
	case EllipsizeNone:
		return "None"
	case EllipsizeStart:
		return "Start"
	case EllipsizeMiddle:
		return "Middle"
	case EllipsizeEnd:
		return "End"
	default:
		return fmt.Sprintf("EllipsizeMode(%d)", e)
	}
}

// WrapMode: PangoWrapMode describes how to wrap the lines of a PangoLayout to
// the desired width.
type WrapMode C.gint

const (
	// WrapWord: wrap lines at word boundaries.
	WrapWord WrapMode = iota
	// WrapChar: wrap lines at character boundaries.
	WrapChar
	// WrapWordChar: wrap lines at word boundaries, but fall back to character
	// boundaries if there is not enough space for a full word.
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapWord:
		return "Word"
	case WrapChar:
		return "Char"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// Layout: PangoLayout structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided using
// the detailed interfaces for itemization and shaping, using that functionality
// directly involves writing a fairly large amount of code. PangoLayout provides
// a high-level driver for formatting entire paragraphs of text at once. This
// includes paragraph-level functionality such as line breaking, justification,
// alignment and ellipsization.
//
// A PangoLayout is initialized with a PangoContext`, UTF-8 string and set of
// attributes for that string. Once that is done, the set of formatted lines can
// be extracted from the object, the layout can be rendered, and conversion
// between logical character positions within the layout's text, and the
// physical position of the resulting glyphs can be made.
//
// There are a number of parameters to adjust the formatting of a PangoLayout.
// The following image shows adjustable parameters (on the left) and font
// metrics (on the right):
//
// !Pango Layout Parameters (layout.png)
//
// It is possible, as well, to ignore the 2-D setup, and simply treat the
// results of a PangoLayout as a list of lines.
type Layout struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Layout)(nil)
)

func wrapLayout(obj *coreglib.Object) *Layout {
	return &Layout{
		Object: obj,
	}
}

func marshalLayout(p uintptr) (interface{}, error) {
	return wrapLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// LayoutIter: PangoLayoutIter can be used to iterate over the visual extents of
// a PangoLayout.
//
// To obtain a PangoLayoutIter, use pango.Layout.GetIter().
//
// The PangoLayoutIter structure is opaque, and has no user-visible fields.
//
// An instance of this type is always passed by reference.
type LayoutIter struct {
	*layoutIter
}

// layoutIter is the struct that's finalized.
type layoutIter struct {
	native unsafe.Pointer
}

var GIRInfoLayoutIter = girepository.MustFind("Pango", "LayoutIter")

func marshalLayoutIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &LayoutIter{&layoutIter{(unsafe.Pointer)(b)}}, nil
}

// LayoutLine: PangoLayoutLine represents one of the lines resulting from laying
// out a paragraph via PangoLayout.
//
// PangoLayoutLine structures are obtained by calling pango.Layout.GetLine() and
// are only valid until the text, attributes, or settings of the parent
// PangoLayout are modified.
//
// An instance of this type is always passed by reference.
type LayoutLine struct {
	*layoutLine
}

// layoutLine is the struct that's finalized.
type layoutLine struct {
	native unsafe.Pointer
}

var GIRInfoLayoutLine = girepository.MustFind("Pango", "LayoutLine")

func marshalLayoutLine(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &LayoutLine{&layoutLine{(unsafe.Pointer)(b)}}, nil
}

// Layout: layout this line belongs to, might be NULL.
func (l *LayoutLine) Layout() *Layout {
	offset := GIRInfoLayoutLine.StructFieldOffset("layout")
	valptr := (**Layout)(unsafe.Add(l.native, offset))
	var _v *Layout // out
	_v = wrapLayout(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// StartIndex: start of line as byte index into layout->text.
func (l *LayoutLine) StartIndex() int {
	offset := GIRInfoLayoutLine.StructFieldOffset("start_index")
	valptr := (*int)(unsafe.Add(l.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Length: length of line in bytes.
func (l *LayoutLine) Length() int {
	offset := GIRInfoLayoutLine.StructFieldOffset("length")
	valptr := (*int)(unsafe.Add(l.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// StartIndex: start of line as byte index into layout->text.
func (l *LayoutLine) SetStartIndex(startIndex int) {
	offset := GIRInfoLayoutLine.StructFieldOffset("start_index")
	valptr := (*C.gint)(unsafe.Add(l.native, offset))
	*valptr = C.gint(startIndex)
}

// Length: length of line in bytes.
func (l *LayoutLine) SetLength(length int) {
	offset := GIRInfoLayoutLine.StructFieldOffset("length")
	valptr := (*C.gint)(unsafe.Add(l.native, offset))
	*valptr = C.gint(length)
}
