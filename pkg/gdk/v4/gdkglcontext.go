// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeGLContext = coreglib.Type(girepository.MustFind("Gdk", "GLContext").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLContext, F: marshalGLContext},
	})
}

// GLContext: GdkGLContext is an object representing a platform-specific OpenGL
// draw context.
//
// GdkGLContexts are created for a surface using gdk.Surface.CreateGLContext(),
// and the context will match the the characteristics of the surface.
//
// A GdkGLContext is not tied to any particular normal framebuffer. For
// instance, it cannot draw to the surface back buffer. The GDK repaint system
// is in full control of the painting to that. Instead, you can create render
// buffers or textures and use cairo_draw_from_gl in the draw function of your
// widget to draw them. Then GDK will handle the integration of your rendering
// with that of other widgets.
//
// Support for GdkGLContext is platform-specific and context creation can fail,
// returning NULL context.
//
// A GdkGLContext has to be made "current" in order to start using it, otherwise
// any OpenGL call will be ignored.
//
//
// Creating a new OpenGL context
//
// In order to create a new GdkGLContext instance you need a GdkSurface, which
// you typically get during the realize call of a widget.
//
// A GdkGLContext is not realized until either gdk.GLContext.MakeCurrent() or
// gdk.GLContext.Realize() is called. It is possible to specify details of the
// GL context like the OpenGL version to be used, or whether the GL context
// should have extra state validation enabled after calling
// gdk.Surface.CreateGLContext() by calling gdk.GLContext.Realize(). If the
// realization fails you have the option to change the settings of the
// GdkGLContext and try again.
//
//
// Using a GdkGLContext
//
// You will need to make the GdkGLContext the current context before issuing
// OpenGL calls; the system sends OpenGL commands to whichever context is
// current. It is possible to have multiple contexts, so you always need to
// ensure that the one which you want to draw with is the current one before
// issuing commands:
//
//    gdk_gl_context_make_current (context);
//
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which GdkGLContext is the current one by using
// gdk.GLContext().GetCurrent; you can also unset any GdkGLContext that is
// currently set by calling gdk.GLContext().ClearCurrent.
type GLContext struct {
	_ [0]func() // equal guard
	DrawContext
}

var (
	_ DrawContexter = (*GLContext)(nil)
)

// GLContexter describes types inherited from class GLContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLContexter interface {
	coreglib.Objector
	baseGLContext() *GLContext
}

var _ GLContexter = (*GLContext)(nil)

func wrapGLContext(obj *coreglib.Object) *GLContext {
	return &GLContext{
		DrawContext: DrawContext{
			Object: obj,
		},
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	return wrapGLContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *GLContext) baseGLContext() *GLContext {
	return v
}

// BaseGLContext returns the underlying base object.
func BaseGLContext(obj GLContexter) *GLContext {
	return obj.baseGLContext()
}
