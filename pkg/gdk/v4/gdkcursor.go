// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeCursor = coreglib.Type(girepository.MustFind("Gdk", "Cursor").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCursor, F: marshalCursor},
	})
}

// Cursor: GdkCursor is used to create and destroy cursors.
//
// Cursors are immutable objects, so once you created them, there is no way to
// modify them later. You should create a new cursor when you want to change
// something about it.
//
// Cursors by themselves are not very interesting: they must be bound to a
// window for users to see them. This is done with gdk.Surface.SetCursor() or
// gdk.Surface.SetDeviceCursor(). Applications will typically use higher-level
// GTK functions such as gtk.Widget.SetCursor()` instead.
//
// Cursors are not bound to a given gdk.Display, so they can be shared. However,
// the appearance of cursors may vary when used on different platforms.
//
//
// Named and texture cursors
//
// There are multiple ways to create cursors. The platform's own cursors can be
// created with gdk.Cursor.NewFromName. That function lists the commonly
// available names that are shared with the CSS specification. Other names may
// be available, depending on the platform in use. On some platforms, what
// images are used for named cursors may be influenced by the cursor theme.
//
// Another option to create a cursor is to use gdk.Cursor.NewFromTexture and
// provide an image to use for the cursor.
//
// To ease work with unsupported cursors, a fallback cursor can be provided. If
// a gdk.Surface cannot use a cursor because of the reasons mentioned above, it
// will try the fallback cursor. Fallback cursors can themselves have fallback
// cursors again, so it is possible to provide a chain of progressively easier
// to support cursors. If none of the provided cursors can be supported, the
// default cursor will be the ultimate fallback.
type Cursor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Cursor)(nil)
)

func wrapCursor(obj *coreglib.Object) *Cursor {
	return &Cursor{
		Object: obj,
	}
}

func marshalCursor(p uintptr) (interface{}, error) {
	return wrapCursor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
