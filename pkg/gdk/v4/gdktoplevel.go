// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFullscreenMode = coreglib.Type(girepository.MustFind("Gdk", "FullscreenMode").RegisteredGType())
	GTypeSurfaceEdge    = coreglib.Type(girepository.MustFind("Gdk", "SurfaceEdge").RegisteredGType())
	GTypeToplevelState  = coreglib.Type(girepository.MustFind("Gdk", "ToplevelState").RegisteredGType())
	GTypeToplevel       = coreglib.Type(girepository.MustFind("Gdk", "Toplevel").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFullscreenMode, F: marshalFullscreenMode},
		coreglib.TypeMarshaler{T: GTypeSurfaceEdge, F: marshalSurfaceEdge},
		coreglib.TypeMarshaler{T: GTypeToplevelState, F: marshalToplevelState},
		coreglib.TypeMarshaler{T: GTypeToplevel, F: marshalToplevel},
	})
}

// FullscreenMode indicates which monitor a surface should span over when in
// fullscreen mode.
type FullscreenMode C.gint

const (
	// FullscreenOnCurrentMonitor: fullscreen on current monitor only.
	FullscreenOnCurrentMonitor FullscreenMode = iota
	// FullscreenOnAllMonitors: span across all monitors when fullscreen.
	FullscreenOnAllMonitors
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FullscreenMode.
func (f FullscreenMode) String() string {
	switch f {
	case FullscreenOnCurrentMonitor:
		return "CurrentMonitor"
	case FullscreenOnAllMonitors:
		return "AllMonitors"
	default:
		return fmt.Sprintf("FullscreenMode(%d)", f)
	}
}

// SurfaceEdge determines a surface edge or corner.
type SurfaceEdge C.gint

const (
	// SurfaceEdgeNorthWest: top left corner.
	SurfaceEdgeNorthWest SurfaceEdge = iota
	// SurfaceEdgeNorth: top edge.
	SurfaceEdgeNorth
	// SurfaceEdgeNorthEast: top right corner.
	SurfaceEdgeNorthEast
	// SurfaceEdgeWest: left edge.
	SurfaceEdgeWest
	// SurfaceEdgeEast: right edge.
	SurfaceEdgeEast
	// SurfaceEdgeSouthWest: lower left corner.
	SurfaceEdgeSouthWest
	// SurfaceEdgeSouth: lower edge.
	SurfaceEdgeSouth
	// SurfaceEdgeSouthEast: lower right corner.
	SurfaceEdgeSouthEast
)

func marshalSurfaceEdge(p uintptr) (interface{}, error) {
	return SurfaceEdge(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SurfaceEdge.
func (s SurfaceEdge) String() string {
	switch s {
	case SurfaceEdgeNorthWest:
		return "NorthWest"
	case SurfaceEdgeNorth:
		return "North"
	case SurfaceEdgeNorthEast:
		return "NorthEast"
	case SurfaceEdgeWest:
		return "West"
	case SurfaceEdgeEast:
		return "East"
	case SurfaceEdgeSouthWest:
		return "SouthWest"
	case SurfaceEdgeSouth:
		return "South"
	case SurfaceEdgeSouthEast:
		return "SouthEast"
	default:
		return fmt.Sprintf("SurfaceEdge(%d)", s)
	}
}

// ToplevelState specifies the state of a toplevel surface.
//
// On platforms that support information about individual edges, the
// GDK_TOPLEVEL_STATE_TILED state will be set whenever any of the individual
// tiled states is set. On platforms that lack that support, the tiled state
// will give an indication of tiledness without any of the per-edge states being
// set.
type ToplevelState C.guint

const (
	// ToplevelStateMinimized: surface is minimized.
	ToplevelStateMinimized ToplevelState = 0b1
	// ToplevelStateMaximized: surface is maximized.
	ToplevelStateMaximized ToplevelState = 0b10
	// ToplevelStateSticky: surface is sticky.
	ToplevelStateSticky ToplevelState = 0b100
	// ToplevelStateFullscreen: surface is maximized without decorations.
	ToplevelStateFullscreen ToplevelState = 0b1000
	// ToplevelStateAbove: surface is kept above other surfaces.
	ToplevelStateAbove ToplevelState = 0b10000
	// ToplevelStateBelow: surface is kept below other surfaces.
	ToplevelStateBelow ToplevelState = 0b100000
	// ToplevelStateFocused: surface is presented as focused (with active
	// decorations).
	ToplevelStateFocused ToplevelState = 0b1000000
	// ToplevelStateTiled: surface is in a tiled state.
	ToplevelStateTiled ToplevelState = 0b10000000
	// ToplevelStateTopTiled: whether the top edge is tiled.
	ToplevelStateTopTiled ToplevelState = 0b100000000
	// ToplevelStateTopResizable: whether the top edge is resizable.
	ToplevelStateTopResizable ToplevelState = 0b1000000000
	// ToplevelStateRightTiled: whether the right edge is tiled.
	ToplevelStateRightTiled ToplevelState = 0b10000000000
	// ToplevelStateRightResizable: whether the right edge is resizable.
	ToplevelStateRightResizable ToplevelState = 0b100000000000
	// ToplevelStateBottomTiled: whether the bottom edge is tiled.
	ToplevelStateBottomTiled ToplevelState = 0b1000000000000
	// ToplevelStateBottomResizable: whether the bottom edge is resizable.
	ToplevelStateBottomResizable ToplevelState = 0b10000000000000
	// ToplevelStateLeftTiled: whether the left edge is tiled.
	ToplevelStateLeftTiled ToplevelState = 0b100000000000000
	// ToplevelStateLeftResizable: whether the left edge is resizable.
	ToplevelStateLeftResizable ToplevelState = 0b1000000000000000
)

func marshalToplevelState(p uintptr) (interface{}, error) {
	return ToplevelState(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ToplevelState.
func (t ToplevelState) String() string {
	if t == 0 {
		return "ToplevelState(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case ToplevelStateMinimized:
			builder.WriteString("Minimized|")
		case ToplevelStateMaximized:
			builder.WriteString("Maximized|")
		case ToplevelStateSticky:
			builder.WriteString("Sticky|")
		case ToplevelStateFullscreen:
			builder.WriteString("Fullscreen|")
		case ToplevelStateAbove:
			builder.WriteString("Above|")
		case ToplevelStateBelow:
			builder.WriteString("Below|")
		case ToplevelStateFocused:
			builder.WriteString("Focused|")
		case ToplevelStateTiled:
			builder.WriteString("Tiled|")
		case ToplevelStateTopTiled:
			builder.WriteString("TopTiled|")
		case ToplevelStateTopResizable:
			builder.WriteString("TopResizable|")
		case ToplevelStateRightTiled:
			builder.WriteString("RightTiled|")
		case ToplevelStateRightResizable:
			builder.WriteString("RightResizable|")
		case ToplevelStateBottomTiled:
			builder.WriteString("BottomTiled|")
		case ToplevelStateBottomResizable:
			builder.WriteString("BottomResizable|")
		case ToplevelStateLeftTiled:
			builder.WriteString("LeftTiled|")
		case ToplevelStateLeftResizable:
			builder.WriteString("LeftResizable|")
		default:
			builder.WriteString(fmt.Sprintf("ToplevelState(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t ToplevelState) Has(other ToplevelState) bool {
	return (t & other) == other
}

// Toplevel: GdkToplevel is a freestanding toplevel surface.
//
// The GdkToplevel interface provides useful APIs for interacting with the
// windowing system, such as controlling maximization and size of the surface,
// setting icons and transient parents for dialogs.
//
// Toplevel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Toplevel struct {
	_ [0]func() // equal guard
	Surface
}

var (
	_ Surfacer = (*Toplevel)(nil)
)

// Topleveller describes Toplevel's interface methods.
type Topleveller interface {
	coreglib.Objector

	baseToplevel() *Toplevel
}

var _ Topleveller = (*Toplevel)(nil)

func wrapToplevel(obj *coreglib.Object) *Toplevel {
	return &Toplevel{
		Surface: Surface{
			Object: obj,
		},
	}
}

func marshalToplevel(p uintptr) (interface{}, error) {
	return wrapToplevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Toplevel) baseToplevel() *Toplevel {
	return v
}

// BaseToplevel returns the underlying base object.
func BaseToplevel(obj Topleveller) *Toplevel {
	return obj.baseToplevel()
}
