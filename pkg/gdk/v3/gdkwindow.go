// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void* _gotk4_gdk3_Window_ConnectPickEmbeddedChild(gpointer, gdouble, gdouble, guintptr);
// extern void* _gotk4_gdk3_Window_ConnectCreateSurface(gpointer, gint, gint, guintptr);
// extern void _gotk4_gdk3_Window_ConnectMovedToRect(gpointer, gpointer, gpointer, gboolean, gboolean, guintptr);
import "C"

// GType values.
var (
	GTypeGravity              = coreglib.Type(girepository.MustFind("Gdk", "Gravity").RegisteredGType())
	GTypeWindowEdge           = coreglib.Type(girepository.MustFind("Gdk", "WindowEdge").RegisteredGType())
	GTypeWindowType           = coreglib.Type(girepository.MustFind("Gdk", "WindowType").RegisteredGType())
	GTypeWindowWindowClass    = coreglib.Type(girepository.MustFind("Gdk", "WindowWindowClass").RegisteredGType())
	GTypeWMDecoration         = coreglib.Type(girepository.MustFind("Gdk", "WMDecoration").RegisteredGType())
	GTypeWMFunction           = coreglib.Type(girepository.MustFind("Gdk", "WMFunction").RegisteredGType())
	GTypeWindowAttributesType = coreglib.Type(girepository.MustFind("Gdk", "WindowAttributesType").RegisteredGType())
	GTypeWindowHints          = coreglib.Type(girepository.MustFind("Gdk", "WindowHints").RegisteredGType())
	GTypeWindow               = coreglib.Type(girepository.MustFind("Gdk", "Window").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGravity, F: marshalGravity},
		coreglib.TypeMarshaler{T: GTypeWindowEdge, F: marshalWindowEdge},
		coreglib.TypeMarshaler{T: GTypeWindowType, F: marshalWindowType},
		coreglib.TypeMarshaler{T: GTypeWindowWindowClass, F: marshalWindowWindowClass},
		coreglib.TypeMarshaler{T: GTypeWMDecoration, F: marshalWMDecoration},
		coreglib.TypeMarshaler{T: GTypeWMFunction, F: marshalWMFunction},
		coreglib.TypeMarshaler{T: GTypeWindowAttributesType, F: marshalWindowAttributesType},
		coreglib.TypeMarshaler{T: GTypeWindowHints, F: marshalWindowHints},
		coreglib.TypeMarshaler{T: GTypeWindow, F: marshalWindow},
	})
}

// Gravity defines the reference point of a window and the meaning of
// coordinates passed to gtk_window_move(). See gtk_window_move() and the
// "implementation notes" section of the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) specification for more
// details.
type Gravity C.gint

const (
	// GravityNorthWest: reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: reference point is at the center of the window.
	GravityCenter Gravity = 5
	// GravityEast: reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: reference point is at the top left corner of the window
	// itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Gravity.
func (g Gravity) String() string {
	switch g {
	case GravityNorthWest:
		return "NorthWest"
	case GravityNorth:
		return "North"
	case GravityNorthEast:
		return "NorthEast"
	case GravityWest:
		return "West"
	case GravityCenter:
		return "Center"
	case GravityEast:
		return "East"
	case GravitySouthWest:
		return "SouthWest"
	case GravitySouth:
		return "South"
	case GravitySouthEast:
		return "SouthEast"
	case GravityStatic:
		return "Static"
	default:
		return fmt.Sprintf("Gravity(%d)", g)
	}
}

// WindowEdge determines a window edge or corner.
type WindowEdge C.gint

const (
	// WindowEdgeNorthWest: top left corner.
	WindowEdgeNorthWest WindowEdge = iota
	// WindowEdgeNorth: top edge.
	WindowEdgeNorth
	// WindowEdgeNorthEast: top right corner.
	WindowEdgeNorthEast
	// WindowEdgeWest: left edge.
	WindowEdgeWest
	// WindowEdgeEast: right edge.
	WindowEdgeEast
	// WindowEdgeSouthWest: lower left corner.
	WindowEdgeSouthWest
	// WindowEdgeSouth: lower edge.
	WindowEdgeSouth
	// WindowEdgeSouthEast: lower right corner.
	WindowEdgeSouthEast
)

func marshalWindowEdge(p uintptr) (interface{}, error) {
	return WindowEdge(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowEdge.
func (w WindowEdge) String() string {
	switch w {
	case WindowEdgeNorthWest:
		return "NorthWest"
	case WindowEdgeNorth:
		return "North"
	case WindowEdgeNorthEast:
		return "NorthEast"
	case WindowEdgeWest:
		return "West"
	case WindowEdgeEast:
		return "East"
	case WindowEdgeSouthWest:
		return "SouthWest"
	case WindowEdgeSouth:
		return "South"
	case WindowEdgeSouthEast:
		return "SouthEast"
	default:
		return fmt.Sprintf("WindowEdge(%d)", w)
	}
}

// WindowType describes the kind of window.
type WindowType C.gint

const (
	// WindowRoot: root window; this window has no parent, covers the entire
	// screen, and is created by the window system.
	WindowRoot WindowType = iota
	// WindowToplevel: toplevel window (used to implement Window).
	WindowToplevel
	// WindowChild: child window (used to implement e.g. Entry).
	WindowChild
	// WindowTemp: override redirect temporary window (used to implement Menu).
	WindowTemp
	// WindowForeign: foreign window (see gdk_window_foreign_new()).
	WindowForeign
	// WindowOffscreen: offscreen window (see [Offscreen
	// Windows][OFFSCREEN-WINDOWS]). Since 2.18.
	WindowOffscreen
	// WindowSubsurface: subsurface-based window; This window is visually tied
	// to a toplevel, and is moved/stacked with it. Currently this window type
	// is only implemented in Wayland. Since 3.14.
	WindowSubsurface
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowType.
func (w WindowType) String() string {
	switch w {
	case WindowRoot:
		return "Root"
	case WindowToplevel:
		return "Toplevel"
	case WindowChild:
		return "Child"
	case WindowTemp:
		return "Temp"
	case WindowForeign:
		return "Foreign"
	case WindowOffscreen:
		return "Offscreen"
	case WindowSubsurface:
		return "Subsurface"
	default:
		return fmt.Sprintf("WindowType(%d)", w)
	}
}

// WindowWindowClass: GDK_INPUT_OUTPUT windows are the standard kind of window
// you might expect. Such windows receive events and are also displayed on
// screen. GDK_INPUT_ONLY windows are invisible; they are usually placed above
// other windows in order to trap or filter the events. You can’t draw on
// GDK_INPUT_ONLY windows.
type WindowWindowClass C.gint

const (
	// InputOutput: window for graphics and events.
	InputOutput WindowWindowClass = iota
	// InputOnly: window for events only.
	InputOnly
)

func marshalWindowWindowClass(p uintptr) (interface{}, error) {
	return WindowWindowClass(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowWindowClass.
func (w WindowWindowClass) String() string {
	switch w {
	case InputOutput:
		return "InputOutput"
	case InputOnly:
		return "InputOnly"
	default:
		return fmt.Sprintf("WindowWindowClass(%d)", w)
	}
}

// WMDecoration: these are hints originally defined by the Motif toolkit. The
// window manager can use them when determining how to decorate the window. The
// hint must be set before mapping the window.
type WMDecoration C.guint

const (
	// DecorAll: all decorations should be applied.
	DecorAll WMDecoration = 0b1
	// DecorBorder: frame should be drawn around the window.
	DecorBorder WMDecoration = 0b10
	// DecorResizeh: frame should have resize handles.
	DecorResizeh WMDecoration = 0b100
	// DecorTitle: titlebar should be placed above the window.
	DecorTitle WMDecoration = 0b1000
	// DecorMenu: button for opening a menu should be included.
	DecorMenu WMDecoration = 0b10000
	// DecorMinimize: minimize button should be included.
	DecorMinimize WMDecoration = 0b100000
	// DecorMaximize: maximize button should be included.
	DecorMaximize WMDecoration = 0b1000000
)

func marshalWMDecoration(p uintptr) (interface{}, error) {
	return WMDecoration(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WMDecoration.
func (w WMDecoration) String() string {
	if w == 0 {
		return "WMDecoration(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case DecorAll:
			builder.WriteString("All|")
		case DecorBorder:
			builder.WriteString("Border|")
		case DecorResizeh:
			builder.WriteString("Resizeh|")
		case DecorTitle:
			builder.WriteString("Title|")
		case DecorMenu:
			builder.WriteString("Menu|")
		case DecorMinimize:
			builder.WriteString("Minimize|")
		case DecorMaximize:
			builder.WriteString("Maximize|")
		default:
			builder.WriteString(fmt.Sprintf("WMDecoration(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WMDecoration) Has(other WMDecoration) bool {
	return (w & other) == other
}

// WMFunction: these are hints originally defined by the Motif toolkit. The
// window manager can use them when determining the functions to offer for the
// window. The hint must be set before mapping the window.
type WMFunction C.guint

const (
	// FuncAll: all functions should be offered.
	FuncAll WMFunction = 0b1
	// FuncResize: window should be resizable.
	FuncResize WMFunction = 0b10
	// FuncMove: window should be movable.
	FuncMove WMFunction = 0b100
	// FuncMinimize: window should be minimizable.
	FuncMinimize WMFunction = 0b1000
	// FuncMaximize: window should be maximizable.
	FuncMaximize WMFunction = 0b10000
	// FuncClose: window should be closable.
	FuncClose WMFunction = 0b100000
)

func marshalWMFunction(p uintptr) (interface{}, error) {
	return WMFunction(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WMFunction.
func (w WMFunction) String() string {
	if w == 0 {
		return "WMFunction(0)"
	}

	var builder strings.Builder
	builder.Grow(63)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case FuncAll:
			builder.WriteString("All|")
		case FuncResize:
			builder.WriteString("Resize|")
		case FuncMove:
			builder.WriteString("Move|")
		case FuncMinimize:
			builder.WriteString("Minimize|")
		case FuncMaximize:
			builder.WriteString("Maximize|")
		case FuncClose:
			builder.WriteString("Close|")
		default:
			builder.WriteString(fmt.Sprintf("WMFunction(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WMFunction) Has(other WMFunction) bool {
	return (w & other) == other
}

// WindowAttributesType: used to indicate which fields in the WindowAttr struct
// should be honored. For example, if you filled in the “cursor” and “x” fields
// of WindowAttr, pass “GDK_WA_X | GDK_WA_CURSOR” to gdk_window_new(). Fields in
// WindowAttr not covered by a bit in this enum are required; for example, the
// width/height, wclass, and window_type fields are required, they have no
// corresponding flag in WindowAttributesType.
type WindowAttributesType C.guint

const (
	// WaTitle: honor the title field.
	WaTitle WindowAttributesType = 0b10
	// WaX: honor the X coordinate field.
	WaX WindowAttributesType = 0b100
	// WaY: honor the Y coordinate field.
	WaY WindowAttributesType = 0b1000
	// WaCursor: honor the cursor field.
	WaCursor WindowAttributesType = 0b10000
	// WaVisual: honor the visual field.
	WaVisual WindowAttributesType = 0b100000
	// WaWmclass: honor the wmclass_class and wmclass_name fields.
	WaWmclass WindowAttributesType = 0b1000000
	// WaNoredir: honor the override_redirect field.
	WaNoredir WindowAttributesType = 0b10000000
	// WaTypeHint: honor the type_hint field.
	WaTypeHint WindowAttributesType = 0b100000000
)

func marshalWindowAttributesType(p uintptr) (interface{}, error) {
	return WindowAttributesType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WindowAttributesType.
func (w WindowAttributesType) String() string {
	if w == 0 {
		return "WindowAttributesType(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case WaTitle:
			builder.WriteString("Title|")
		case WaX:
			builder.WriteString("X|")
		case WaY:
			builder.WriteString("Y|")
		case WaCursor:
			builder.WriteString("Cursor|")
		case WaVisual:
			builder.WriteString("Visual|")
		case WaWmclass:
			builder.WriteString("Wmclass|")
		case WaNoredir:
			builder.WriteString("Noredir|")
		case WaTypeHint:
			builder.WriteString("TypeHint|")
		default:
			builder.WriteString(fmt.Sprintf("WindowAttributesType(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WindowAttributesType) Has(other WindowAttributesType) bool {
	return (w & other) == other
}

// WindowHints: used to indicate which fields of a Geometry struct should be
// paid attention to. Also, the presence/absence of GDK_HINT_POS,
// GDK_HINT_USER_POS, and GDK_HINT_USER_SIZE is significant, though they don't
// directly refer to Geometry fields. GDK_HINT_USER_POS will be set
// automatically by Window if you call gtk_window_move(). GDK_HINT_USER_POS and
// GDK_HINT_USER_SIZE should be set if the user specified a size/position using
// a --geometry command-line argument; gtk_window_parse_geometry() automatically
// sets these flags.
type WindowHints C.guint

const (
	// HintPos indicates that the program has positioned the window.
	HintPos WindowHints = 0b1
	// HintMinSize: min size fields are set.
	HintMinSize WindowHints = 0b10
	// HintMaxSize: max size fields are set.
	HintMaxSize WindowHints = 0b100
	// HintBaseSize: base size fields are set.
	HintBaseSize WindowHints = 0b1000
	// HintAspect: aspect ratio fields are set.
	HintAspect WindowHints = 0b10000
	// HintResizeInc: resize increment fields are set.
	HintResizeInc WindowHints = 0b100000
	// HintWinGravity: window gravity field is set.
	HintWinGravity WindowHints = 0b1000000
	// HintUserPos indicates that the window’s position was explicitly set by
	// the user.
	HintUserPos WindowHints = 0b10000000
	// HintUserSize indicates that the window’s size was explicitly set by the
	// user.
	HintUserSize WindowHints = 0b100000000
)

func marshalWindowHints(p uintptr) (interface{}, error) {
	return WindowHints(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WindowHints.
func (w WindowHints) String() string {
	if w == 0 {
		return "WindowHints(0)"
	}

	var builder strings.Builder
	builder.Grow(109)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case HintPos:
			builder.WriteString("Pos|")
		case HintMinSize:
			builder.WriteString("MinSize|")
		case HintMaxSize:
			builder.WriteString("MaxSize|")
		case HintBaseSize:
			builder.WriteString("BaseSize|")
		case HintAspect:
			builder.WriteString("Aspect|")
		case HintResizeInc:
			builder.WriteString("ResizeInc|")
		case HintWinGravity:
			builder.WriteString("WinGravity|")
		case HintUserPos:
			builder.WriteString("UserPos|")
		case HintUserSize:
			builder.WriteString("UserSize|")
		default:
			builder.WriteString(fmt.Sprintf("WindowHints(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WindowHints) Has(other WindowHints) bool {
	return (w & other) == other
}

// WindowChildFunc: function of this type is passed to
// gdk_window_invalidate_maybe_recurse(). It gets called for each child of the
// window to determine whether to recursively invalidate it or now.
type WindowChildFunc func(window Windower) (ok bool)

// WindowOverrides contains methods that are overridable.
type WindowOverrides struct {
}

func defaultWindowOverrides(v *Window) WindowOverrides {
	return WindowOverrides{}
}

type Window struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Window)(nil)
)

// Windower describes types inherited from class Window.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Windower interface {
	coreglib.Objector
	baseWindow() *Window
}

var _ Windower = (*Window)(nil)

func init() {
	coreglib.RegisterClassInfo[*Window, *WindowClass, WindowOverrides](
		GTypeWindow,
		initWindowClass,
		wrapWindow,
		defaultWindowOverrides,
	)
}

func initWindowClass(gclass unsafe.Pointer, overrides WindowOverrides, classInitFunc func(*WindowClass)) {
	if classInitFunc != nil {
		class := (*WindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWindow(obj *coreglib.Object) *Window {
	return &Window{
		Object: obj,
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	return wrapWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Window) baseWindow() *Window {
	return v
}

// BaseWindow returns the underlying base object.
func BaseWindow(obj Windower) *Window {
	return obj.baseWindow()
}

// ConnectCreateSurface signal is emitted when an offscreen window needs its
// surface (re)created, which happens either when the window is first drawn to,
// or when the window is being resized. The first signal handler that returns a
// non-NULL surface will stop any further signal emission, and its surface will
// be used.
//
// Note that it is not possible to access the window's previous surface from
// within any callback of this signal. Calling
// gdk_offscreen_window_get_surface() will lead to a crash.
func (v *Window) ConnectCreateSurface(f func(width, height int) (surface *cairo.Surface)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "create-surface", false, unsafe.Pointer(C._gotk4_gdk3_Window_ConnectCreateSurface), f)
}

// ConnectMovedToRect is emitted when the position of window is finalized after
// being moved to a destination rectangle.
//
// window might be flipped over the destination rectangle in order to keep it
// on-screen, in which case flipped_x and flipped_y will be set to TRUE
// accordingly.
//
// flipped_rect is the ideal position of window after any possible flipping, but
// before any possible sliding. final_rect is flipped_rect, but possibly
// translated in the case that flipping is still ineffective in keeping window
// on-screen.
func (v *Window) ConnectMovedToRect(f func(flippedRect, finalRect unsafe.Pointer, flippedX, flippedY bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "moved-to-rect", false, unsafe.Pointer(C._gotk4_gdk3_Window_ConnectMovedToRect), f)
}

// ConnectPickEmbeddedChild signal is emitted to find an embedded child at the
// given position.
func (v *Window) ConnectPickEmbeddedChild(f func(x, y float64) (window Windower)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "pick-embedded-child", false, unsafe.Pointer(C._gotk4_gdk3_Window_ConnectPickEmbeddedChild), f)
}

// Geometry struct gives the window manager information about a window’s
// geometry constraints. Normally you would set these on the GTK+ level using
// gtk_window_set_geometry_hints(). Window then sets the hints on the Window it
// creates.
//
// gdk_window_set_geometry_hints() expects the hints to be fully valid already
// and simply passes them to the window manager; in contrast,
// gtk_window_set_geometry_hints() performs some interpretation. For example,
// Window will apply the hints to the geometry widget instead of the toplevel
// window, if you set a geometry widget. Also, the
// min_width/min_height/max_width/max_height fields may be set to -1, and Window
// will substitute the size request of the window or geometry widget. If the
// minimum size hint is not provided, Window will use its requisition as the
// minimum size. If the minimum size is provided and a geometry widget is set,
// Window will take the minimum size as the minimum size of the geometry widget
// rather than the entire window. The base size is treated similarly.
//
// The canonical use-case for gtk_window_set_geometry_hints() is to get a
// terminal widget to resize properly. Here, the terminal text area should be
// the geometry widget; Window will then automatically set the base size to the
// size of other widgets in the terminal window, such as the menubar and
// scrollbar. Then, the width_inc and height_inc fields should be set to the
// size of one character in the terminal. Finally, the base size should be set
// to the size of one character. The net effect is that the minimum size of the
// terminal will have a 1x1 character terminal area, and only terminal sizes on
// the “character grid” will be allowed.
//
// Here’s an example of how the terminal example would be implemented, assuming
// a terminal area widget called “terminal” and a toplevel window “toplevel”:
//
//    	GdkGeometry hints;
//
//    	hints.base_width = terminal->char_width;
//            hints.base_height = terminal->char_height;
//            hints.min_width = terminal->char_width;
//            hints.min_height = terminal->char_height;
//            hints.width_inc = terminal->char_width;
//            hints.height_inc = terminal->char_height;
//
//     gtk_window_set_geometry_hints (GTK_WINDOW (toplevel),
//                                    GTK_WIDGET (terminal),
//                                    &hints,
//                                    GDK_HINT_RESIZE_INC |
//                                    GDK_HINT_MIN_SIZE |
//                                    GDK_HINT_BASE_SIZE);
//
// The other useful fields are the min_aspect and max_aspect fields; these
// contain a width/height ratio as a floating point number. If a geometry widget
// is set, the aspect applies to the geometry widget rather than the entire
// window. The most common use of these hints is probably to set min_aspect and
// max_aspect to the same value, thus forcing the window to keep a constant
// aspect ratio.
//
// An instance of this type is always passed by reference.
type Geometry struct {
	*geometry
}

// geometry is the struct that's finalized.
type geometry struct {
	native unsafe.Pointer
}

var GIRInfoGeometry = girepository.MustFind("Gdk", "Geometry")

// WindowAttr attributes to use for a newly-created window.
//
// An instance of this type is always passed by reference.
type WindowAttr struct {
	*windowAttr
}

// windowAttr is the struct that's finalized.
type windowAttr struct {
	native unsafe.Pointer
}

var GIRInfoWindowAttr = girepository.MustFind("Gdk", "WindowAttr")

// WindowClass: instance of this type is always passed by reference.
type WindowClass struct {
	*windowClass
}

// windowClass is the struct that's finalized.
type windowClass struct {
	native unsafe.Pointer
}

var GIRInfoWindowClass = girepository.MustFind("Gdk", "WindowClass")
