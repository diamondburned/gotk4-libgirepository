// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gdk3_DragContext_ConnectDropPerformed(gpointer, gint, guintptr);
// extern void _gotk4_gdk3_DragContext_ConnectDNDFinished(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeStatus      = coreglib.Type(girepository.MustFind("Gdk", "Status").RegisteredGType())
	GTypeDeviceTool  = coreglib.Type(girepository.MustFind("Gdk", "DeviceTool").RegisteredGType())
	GTypeDragContext = coreglib.Type(girepository.MustFind("Gdk", "DragContext").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStatus, F: marshalStatus},
		coreglib.TypeMarshaler{T: GTypeDeviceTool, F: marshalDeviceTool},
		coreglib.TypeMarshaler{T: GTypeDragContext, F: marshalDragContext},
	})
}

func init() {
	girepository.Require("Gdk", "3.0", girepository.LoadFlagLazy)
}

type Status C.gint

const (
	OK         Status = 0
	Error      Status = -1
	ErrorParam Status = -2
	ErrorFile  Status = -3
	ErrorMem   Status = -4
)

func marshalStatus(p uintptr) (interface{}, error) {
	return Status(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Status.
func (s Status) String() string {
	switch s {
	case OK:
		return "OK"
	case Error:
		return "Error"
	case ErrorParam:
		return "ErrorParam"
	case ErrorFile:
		return "ErrorFile"
	case ErrorMem:
		return "ErrorMem"
	default:
		return fmt.Sprintf("Status(%d)", s)
	}
}

type DeviceTool struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DeviceTool)(nil)
)

func wrapDeviceTool(obj *coreglib.Object) *DeviceTool {
	return &DeviceTool{
		Object: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	return wrapDeviceTool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

type DragContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DragContext)(nil)
)

func wrapDragContext(obj *coreglib.Object) *DragContext {
	return &DragContext{
		Object: obj,
	}
}

func marshalDragContext(p uintptr) (interface{}, error) {
	return wrapDragContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDNDFinished: drag and drop operation was finished, the drag
// destination finished reading all data. The drag source can now free all
// miscellaneous data.
//
// This signal will only be emitted if the DragContext manages the drag and drop
// operation. See gdk_drag_context_manage_dnd() for more information.
func (v *DragContext) ConnectDNDFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "dnd-finished", false, unsafe.Pointer(C._gotk4_gdk3_DragContext_ConnectDNDFinished), f)
}

// ConnectDropPerformed: drag and drop operation was performed on an accepting
// client.
//
// This signal will only be emitted if the DragContext manages the drag and drop
// operation. See gdk_drag_context_manage_dnd() for more information.
func (v *DragContext) ConnectDropPerformed(f func(time int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "drop-performed", false, unsafe.Pointer(C._gotk4_gdk3_DragContext_ConnectDropPerformed), f)
}
