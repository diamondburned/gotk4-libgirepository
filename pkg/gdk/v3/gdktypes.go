// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeAxisUse        = coreglib.Type(girepository.MustFind("Gdk", "AxisUse").RegisteredGType())
	GTypeByteOrder      = coreglib.Type(girepository.MustFind("Gdk", "ByteOrder").RegisteredGType())
	GTypeGrabOwnership  = coreglib.Type(girepository.MustFind("Gdk", "GrabOwnership").RegisteredGType())
	GTypeGrabStatus     = coreglib.Type(girepository.MustFind("Gdk", "GrabStatus").RegisteredGType())
	GTypeWindowTypeHint = coreglib.Type(girepository.MustFind("Gdk", "WindowTypeHint").RegisteredGType())
	GTypeEventMask      = coreglib.Type(girepository.MustFind("Gdk", "EventMask").RegisteredGType())
	GTypeModifierType   = coreglib.Type(girepository.MustFind("Gdk", "ModifierType").RegisteredGType())
	GTypeRectangle      = coreglib.Type(girepository.MustFind("Gdk", "Rectangle").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAxisUse, F: marshalAxisUse},
		coreglib.TypeMarshaler{T: GTypeByteOrder, F: marshalByteOrder},
		coreglib.TypeMarshaler{T: GTypeGrabOwnership, F: marshalGrabOwnership},
		coreglib.TypeMarshaler{T: GTypeGrabStatus, F: marshalGrabStatus},
		coreglib.TypeMarshaler{T: GTypeWindowTypeHint, F: marshalWindowTypeHint},
		coreglib.TypeMarshaler{T: GTypeEventMask, F: marshalEventMask},
		coreglib.TypeMarshaler{T: GTypeModifierType, F: marshalModifierType},
		coreglib.TypeMarshaler{T: GTypeRectangle, F: marshalRectangle},
	})
}

// CURRENT_TIME represents the current time, and can be used anywhere a time is
// expected.
const CURRENT_TIME = 0

// PARENT_RELATIVE: special value, indicating that the background for a window
// should be inherited from the parent window.
const PARENT_RELATIVE = 1

// AxisUse: enumeration describing the way in which a device axis (valuator)
// maps onto the predefined valuator types that GTK+ understands.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse C.gint

const (
	// AxisIgnore axis is ignored.
	AxisIgnore AxisUse = iota
	// AxisX axis is used as the x axis.
	AxisX
	// AxisY axis is used as the y axis.
	AxisY
	// AxisPressure axis is used for pressure information.
	AxisPressure
	// AxisXtilt axis is used for x tilt information.
	AxisXtilt
	// AxisYtilt axis is used for y tilt information.
	AxisYtilt
	// AxisWheel axis is used for wheel information.
	AxisWheel
	// AxisDistance axis is used for pen/tablet distance information. (Since:
	// 3.22).
	AxisDistance
	// AxisRotation axis is used for pen rotation information. (Since: 3.22).
	AxisRotation
	// AxisSlider axis is used for pen slider information. (Since: 3.22).
	AxisSlider
	// AxisLast: constant equal to the numerically highest axis value.
	AxisLast
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AxisUse.
func (a AxisUse) String() string {
	switch a {
	case AxisIgnore:
		return "Ignore"
	case AxisX:
		return "X"
	case AxisY:
		return "Y"
	case AxisPressure:
		return "Pressure"
	case AxisXtilt:
		return "Xtilt"
	case AxisYtilt:
		return "Ytilt"
	case AxisWheel:
		return "Wheel"
	case AxisDistance:
		return "Distance"
	case AxisRotation:
		return "Rotation"
	case AxisSlider:
		return "Slider"
	case AxisLast:
		return "Last"
	default:
		return fmt.Sprintf("AxisUse(%d)", a)
	}
}

// ByteOrder: set of values describing the possible byte-orders for storing
// pixel values in memory.
type ByteOrder C.gint

const (
	// LsbFirst values are stored with the least-significant byte first. For
	// instance, the 32-bit value 0xffeecc would be stored in memory as 0xcc,
	// 0xee, 0xff, 0x00.
	LsbFirst ByteOrder = iota
	// MsbFirst values are stored with the most-significant byte first. For
	// instance, the 32-bit value 0xffeecc would be stored in memory as 0x00,
	// 0xff, 0xee, 0xcc.
	MsbFirst
)

func marshalByteOrder(p uintptr) (interface{}, error) {
	return ByteOrder(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ByteOrder.
func (b ByteOrder) String() string {
	switch b {
	case LsbFirst:
		return "LsbFirst"
	case MsbFirst:
		return "MsbFirst"
	default:
		return fmt.Sprintf("ByteOrder(%d)", b)
	}
}

// GrabOwnership defines how device grabs interact with other devices.
type GrabOwnership C.gint

const (
	// OwnershipNone: all other devices’ events are allowed.
	OwnershipNone GrabOwnership = iota
	// OwnershipWindow: other devices’ events are blocked for the grab window.
	OwnershipWindow
	// OwnershipApplication: other devices’ events are blocked for the whole
	// application.
	OwnershipApplication
)

func marshalGrabOwnership(p uintptr) (interface{}, error) {
	return GrabOwnership(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GrabOwnership.
func (g GrabOwnership) String() string {
	switch g {
	case OwnershipNone:
		return "None"
	case OwnershipWindow:
		return "Window"
	case OwnershipApplication:
		return "Application"
	default:
		return fmt.Sprintf("GrabOwnership(%d)", g)
	}
}

// GrabStatus: returned by gdk_device_grab(), gdk_pointer_grab() and
// gdk_keyboard_grab() to indicate success or the reason for the failure of the
// grab attempt.
type GrabStatus C.gint

const (
	// GrabSuccess: resource was successfully grabbed.
	GrabSuccess GrabStatus = iota
	// GrabAlreadyGrabbed: resource is actively grabbed by another client.
	GrabAlreadyGrabbed
	// GrabInvalidTime: resource was grabbed more recently than the specified
	// time.
	GrabInvalidTime
	// GrabNotViewable: grab window or the confine_to window are not viewable.
	GrabNotViewable
	// GrabFrozen: resource is frozen by an active grab of another client.
	GrabFrozen
	// GrabFailed: grab failed for some other reason. Since 3.16.
	GrabFailed
)

func marshalGrabStatus(p uintptr) (interface{}, error) {
	return GrabStatus(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GrabStatus.
func (g GrabStatus) String() string {
	switch g {
	case GrabSuccess:
		return "Success"
	case GrabAlreadyGrabbed:
		return "AlreadyGrabbed"
	case GrabInvalidTime:
		return "InvalidTime"
	case GrabNotViewable:
		return "NotViewable"
	case GrabFrozen:
		return "Frozen"
	case GrabFailed:
		return "Failed"
	default:
		return fmt.Sprintf("GrabStatus(%d)", g)
	}
}

// WindowTypeHint: these are hints for the window manager that indicate what
// type of function the window has. The window manager can use this when
// determining decoration and behaviour of the window. The hint must be set
// before mapping the window.
//
// See the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) specification for more details
// about window types.
type WindowTypeHint C.gint

const (
	// WindowTypeHintNormal: normal toplevel window.
	WindowTypeHintNormal WindowTypeHint = iota
	// WindowTypeHintDialog: dialog window.
	WindowTypeHintDialog
	// WindowTypeHintMenu: window used to implement a menu; GTK+ uses this hint
	// only for torn-off menus, see TearoffMenuItem.
	WindowTypeHintMenu
	// WindowTypeHintToolbar: window used to implement toolbars.
	WindowTypeHintToolbar
	// WindowTypeHintSplashscreen: window used to display a splash screen during
	// application startup.
	WindowTypeHintSplashscreen
	// WindowTypeHintUtility: utility windows which are not detached toolbars or
	// dialogs.
	WindowTypeHintUtility
	// WindowTypeHintDock: used for creating dock or panel windows.
	WindowTypeHintDock
	// WindowTypeHintDesktop: used for creating the desktop background window.
	WindowTypeHintDesktop
	// WindowTypeHintDropdownMenu: menu that belongs to a menubar.
	WindowTypeHintDropdownMenu
	// WindowTypeHintPopupMenu: menu that does not belong to a menubar, e.g. a
	// context menu.
	WindowTypeHintPopupMenu
	// WindowTypeHintTooltip: tooltip.
	WindowTypeHintTooltip
	// WindowTypeHintNotification: notification - typically a “bubble” that
	// belongs to a status icon.
	WindowTypeHintNotification
	// WindowTypeHintCombo: popup from a combo box.
	WindowTypeHintCombo
	// WindowTypeHintDND: window that is used to implement a DND cursor.
	WindowTypeHintDND
)

func marshalWindowTypeHint(p uintptr) (interface{}, error) {
	return WindowTypeHint(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowTypeHint.
func (w WindowTypeHint) String() string {
	switch w {
	case WindowTypeHintNormal:
		return "Normal"
	case WindowTypeHintDialog:
		return "Dialog"
	case WindowTypeHintMenu:
		return "Menu"
	case WindowTypeHintToolbar:
		return "Toolbar"
	case WindowTypeHintSplashscreen:
		return "Splashscreen"
	case WindowTypeHintUtility:
		return "Utility"
	case WindowTypeHintDock:
		return "Dock"
	case WindowTypeHintDesktop:
		return "Desktop"
	case WindowTypeHintDropdownMenu:
		return "DropdownMenu"
	case WindowTypeHintPopupMenu:
		return "PopupMenu"
	case WindowTypeHintTooltip:
		return "Tooltip"
	case WindowTypeHintNotification:
		return "Notification"
	case WindowTypeHintCombo:
		return "Combo"
	case WindowTypeHintDND:
		return "DND"
	default:
		return fmt.Sprintf("WindowTypeHint(%d)", w)
	}
}

// EventMask: set of bit-flags to indicate which events a window is to receive.
// Most of these masks map onto one or more of the EventType event types above.
//
// See the [input handling overview][chap-input-handling] for details of [event
// masks][event-masks] and [event propagation][event-propagation].
//
// GDK_POINTER_MOTION_HINT_MASK is deprecated. It is a special mask to reduce
// the number of GDK_MOTION_NOTIFY events received. When using
// GDK_POINTER_MOTION_HINT_MASK, fewer GDK_MOTION_NOTIFY events will be sent,
// some of which are marked as a hint (the is_hint member is TRUE). To receive
// more motion events after a motion hint event, the application needs to asks
// for more, by calling gdk_event_request_motions().
//
// Since GTK 3.8, motion events are already compressed by default, independent
// of this mechanism. This compression can be disabled with
// gdk_window_set_event_compression(). See the documentation of that function
// for details.
//
// If GDK_TOUCH_MASK is enabled, the window will receive touch events from
// touch-enabled devices. Those will come as sequences of EventTouch with type
// GDK_TOUCH_UPDATE, enclosed by two events with type GDK_TOUCH_BEGIN and
// GDK_TOUCH_END (or GDK_TOUCH_CANCEL). gdk_event_get_event_sequence() returns
// the event sequence for these events, so different sequences may be
// distinguished.
type EventMask C.guint

const (
	// ExposureMask: receive expose events.
	ExposureMask EventMask = 0b10
	// PointerMotionMask: receive all pointer motion events.
	PointerMotionMask EventMask = 0b100
	// PointerMotionHintMask: deprecated. see the explanation above.
	PointerMotionHintMask EventMask = 0b1000
	// ButtonMotionMask: receive pointer motion events while any button is
	// pressed.
	ButtonMotionMask EventMask = 0b10000
	// Button1MotionMask: receive pointer motion events while 1 button is
	// pressed.
	Button1MotionMask EventMask = 0b100000
	// Button2MotionMask: receive pointer motion events while 2 button is
	// pressed.
	Button2MotionMask EventMask = 0b1000000
	// Button3MotionMask: receive pointer motion events while 3 button is
	// pressed.
	Button3MotionMask EventMask = 0b10000000
	// ButtonPressMask: receive button press events.
	ButtonPressMask EventMask = 0b100000000
	// ButtonReleaseMask: receive button release events.
	ButtonReleaseMask EventMask = 0b1000000000
	// KeyPressMask: receive key press events.
	KeyPressMask EventMask = 0b10000000000
	// KeyReleaseMask: receive key release events.
	KeyReleaseMask EventMask = 0b100000000000
	// EnterNotifyMask: receive window enter events.
	EnterNotifyMask EventMask = 0b1000000000000
	// LeaveNotifyMask: receive window leave events.
	LeaveNotifyMask EventMask = 0b10000000000000
	// FocusChangeMask: receive focus change events.
	FocusChangeMask EventMask = 0b100000000000000
	// StructureMask: receive events about window configuration change.
	StructureMask EventMask = 0b1000000000000000
	// PropertyChangeMask: receive property change events.
	PropertyChangeMask EventMask = 0b10000000000000000
	// VisibilityNotifyMask: receive visibility change events.
	VisibilityNotifyMask EventMask = 0b100000000000000000
	// ProximityInMask: receive proximity in events.
	ProximityInMask EventMask = 0b1000000000000000000
	// ProximityOutMask: receive proximity out events.
	ProximityOutMask EventMask = 0b10000000000000000000
	// SubstructureMask: receive events about window configuration changes of
	// child windows.
	SubstructureMask EventMask = 0b100000000000000000000
	// ScrollMask: receive scroll events.
	ScrollMask EventMask = 0b1000000000000000000000
	// TouchMask: receive touch events. Since 3.4.
	TouchMask EventMask = 0b10000000000000000000000
	// SmoothScrollMask: receive smooth scrolling events. Since 3.4.
	SmoothScrollMask EventMask = 0b100000000000000000000000
	// TouchpadGestureMask: receive touchpad gesture events. Since 3.18.
	TouchpadGestureMask EventMask = 0b1000000000000000000000000
	// TabletPadMask: receive tablet pad events. Since 3.22.
	TabletPadMask EventMask = 0b10000000000000000000000000
	// AllEventsMask: combination of all the above event masks.
	AllEventsMask EventMask = 0b11111111111111111111111110
)

func marshalEventMask(p uintptr) (interface{}, error) {
	return EventMask(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for EventMask.
func (e EventMask) String() string {
	if e == 0 {
		return "EventMask(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case ExposureMask:
			builder.WriteString("ExposureMask|")
		case PointerMotionMask:
			builder.WriteString("PointerMotionMask|")
		case PointerMotionHintMask:
			builder.WriteString("PointerMotionHintMask|")
		case ButtonMotionMask:
			builder.WriteString("ButtonMotionMask|")
		case Button1MotionMask:
			builder.WriteString("Button1MotionMask|")
		case Button2MotionMask:
			builder.WriteString("Button2MotionMask|")
		case Button3MotionMask:
			builder.WriteString("Button3MotionMask|")
		case ButtonPressMask:
			builder.WriteString("ButtonPressMask|")
		case ButtonReleaseMask:
			builder.WriteString("ButtonReleaseMask|")
		case KeyPressMask:
			builder.WriteString("KeyPressMask|")
		case KeyReleaseMask:
			builder.WriteString("KeyReleaseMask|")
		case EnterNotifyMask:
			builder.WriteString("EnterNotifyMask|")
		case LeaveNotifyMask:
			builder.WriteString("LeaveNotifyMask|")
		case FocusChangeMask:
			builder.WriteString("FocusChangeMask|")
		case StructureMask:
			builder.WriteString("StructureMask|")
		case PropertyChangeMask:
			builder.WriteString("PropertyChangeMask|")
		case VisibilityNotifyMask:
			builder.WriteString("VisibilityNotifyMask|")
		case ProximityInMask:
			builder.WriteString("ProximityInMask|")
		case ProximityOutMask:
			builder.WriteString("ProximityOutMask|")
		case SubstructureMask:
			builder.WriteString("SubstructureMask|")
		case ScrollMask:
			builder.WriteString("ScrollMask|")
		case TouchMask:
			builder.WriteString("TouchMask|")
		case SmoothScrollMask:
			builder.WriteString("SmoothScrollMask|")
		case TouchpadGestureMask:
			builder.WriteString("TouchpadGestureMask|")
		case TabletPadMask:
			builder.WriteString("TabletPadMask|")
		case AllEventsMask:
			builder.WriteString("AllEventsMask|")
		default:
			builder.WriteString(fmt.Sprintf("EventMask(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e EventMask) Has(other EventMask) bool {
	return (e & other) == other
}

// ModifierType: set of bit-flags to indicate the state of modifier keys and
// mouse buttons in various event types. Typical modifier keys are Shift,
// Control, Meta, Super, Hyper, Alt, Compose, Apple, CapsLock or ShiftLock.
//
// Like the X Window System, GDK supports 8 modifier keys and 5 mouse buttons.
//
// Since 2.10, GDK recognizes which of the Meta, Super or Hyper keys are mapped
// to Mod2 - Mod5, and indicates this by setting GDK_SUPER_MASK, GDK_HYPER_MASK
// or GDK_META_MASK in the state field of key events.
//
// Note that GDK may add internal values to events which include reserved values
// such as GDK_MODIFIER_RESERVED_13_MASK. Your code should preserve and ignore
// them. You can use GDK_MODIFIER_MASK to remove all reserved values.
//
// Also note that the GDK X backend interprets button press events for button
// 4-7 as scroll events, so GDK_BUTTON4_MASK and GDK_BUTTON5_MASK will never be
// set.
type ModifierType C.guint

const (
	// ShiftMask: shift key.
	ShiftMask ModifierType = 0b1
	// LockMask: lock key (depending on the modifier mapping of the X server
	// this may either be CapsLock or ShiftLock).
	LockMask ModifierType = 0b10
	// ControlMask: control key.
	ControlMask ModifierType = 0b100
	// Mod1Mask: fourth modifier key (it depends on the modifier mapping of the
	// X server which key is interpreted as this modifier, but normally it is
	// the Alt key).
	Mod1Mask ModifierType = 0b1000
	// Mod2Mask: fifth modifier key (it depends on the modifier mapping of the X
	// server which key is interpreted as this modifier).
	Mod2Mask ModifierType = 0b10000
	// Mod3Mask: sixth modifier key (it depends on the modifier mapping of the X
	// server which key is interpreted as this modifier).
	Mod3Mask ModifierType = 0b100000
	// Mod4Mask: seventh modifier key (it depends on the modifier mapping of the
	// X server which key is interpreted as this modifier).
	Mod4Mask ModifierType = 0b1000000
	// Mod5Mask: eighth modifier key (it depends on the modifier mapping of the
	// X server which key is interpreted as this modifier).
	Mod5Mask ModifierType = 0b10000000
	// Button1Mask: first mouse button.
	Button1Mask ModifierType = 0b100000000
	// Button2Mask: second mouse button.
	Button2Mask ModifierType = 0b1000000000
	// Button3Mask: third mouse button.
	Button3Mask ModifierType = 0b10000000000
	// Button4Mask: fourth mouse button.
	Button4Mask ModifierType = 0b100000000000
	// Button5Mask: fifth mouse button.
	Button5Mask ModifierType = 0b1000000000000
	// ModifierReserved13Mask: reserved bit flag; do not use in your own code.
	ModifierReserved13Mask ModifierType = 0b10000000000000
	// ModifierReserved14Mask: reserved bit flag; do not use in your own code.
	ModifierReserved14Mask ModifierType = 0b100000000000000
	// ModifierReserved15Mask: reserved bit flag; do not use in your own code.
	ModifierReserved15Mask ModifierType = 0b1000000000000000
	// ModifierReserved16Mask: reserved bit flag; do not use in your own code.
	ModifierReserved16Mask ModifierType = 0b10000000000000000
	// ModifierReserved17Mask: reserved bit flag; do not use in your own code.
	ModifierReserved17Mask ModifierType = 0b100000000000000000
	// ModifierReserved18Mask: reserved bit flag; do not use in your own code.
	ModifierReserved18Mask ModifierType = 0b1000000000000000000
	// ModifierReserved19Mask: reserved bit flag; do not use in your own code.
	ModifierReserved19Mask ModifierType = 0b10000000000000000000
	// ModifierReserved20Mask: reserved bit flag; do not use in your own code.
	ModifierReserved20Mask ModifierType = 0b100000000000000000000
	// ModifierReserved21Mask: reserved bit flag; do not use in your own code.
	ModifierReserved21Mask ModifierType = 0b1000000000000000000000
	// ModifierReserved22Mask: reserved bit flag; do not use in your own code.
	ModifierReserved22Mask ModifierType = 0b10000000000000000000000
	// ModifierReserved23Mask: reserved bit flag; do not use in your own code.
	ModifierReserved23Mask ModifierType = 0b100000000000000000000000
	// ModifierReserved24Mask: reserved bit flag; do not use in your own code.
	ModifierReserved24Mask ModifierType = 0b1000000000000000000000000
	// ModifierReserved25Mask: reserved bit flag; do not use in your own code.
	ModifierReserved25Mask ModifierType = 0b10000000000000000000000000
	// SuperMask: super modifier. Since 2.10.
	SuperMask ModifierType = 0b100000000000000000000000000
	// HyperMask: hyper modifier. Since 2.10.
	HyperMask ModifierType = 0b1000000000000000000000000000
	// MetaMask: meta modifier. Since 2.10.
	MetaMask ModifierType = 0b10000000000000000000000000000
	// ModifierReserved29Mask: reserved bit flag; do not use in your own code.
	ModifierReserved29Mask ModifierType = 0b100000000000000000000000000000
	// ReleaseMask: not used in GDK itself. GTK+ uses it to differentiate
	// between (keyval, modifiers) pairs from key press and release events.
	ReleaseMask ModifierType = 0b1000000000000000000000000000000
	// ModifierMask: mask covering all modifier types.
	ModifierMask ModifierType = 0b1011100000000000001111111111111
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ModifierType.
func (m ModifierType) String() string {
	if m == 0 {
		return "ModifierType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case ShiftMask:
			builder.WriteString("ShiftMask|")
		case LockMask:
			builder.WriteString("LockMask|")
		case ControlMask:
			builder.WriteString("ControlMask|")
		case Mod1Mask:
			builder.WriteString("Mod1Mask|")
		case Mod2Mask:
			builder.WriteString("Mod2Mask|")
		case Mod3Mask:
			builder.WriteString("Mod3Mask|")
		case Mod4Mask:
			builder.WriteString("Mod4Mask|")
		case Mod5Mask:
			builder.WriteString("Mod5Mask|")
		case Button1Mask:
			builder.WriteString("Button1Mask|")
		case Button2Mask:
			builder.WriteString("Button2Mask|")
		case Button3Mask:
			builder.WriteString("Button3Mask|")
		case Button4Mask:
			builder.WriteString("Button4Mask|")
		case Button5Mask:
			builder.WriteString("Button5Mask|")
		case ModifierReserved13Mask:
			builder.WriteString("ModifierReserved13Mask|")
		case ModifierReserved14Mask:
			builder.WriteString("ModifierReserved14Mask|")
		case ModifierReserved15Mask:
			builder.WriteString("ModifierReserved15Mask|")
		case ModifierReserved16Mask:
			builder.WriteString("ModifierReserved16Mask|")
		case ModifierReserved17Mask:
			builder.WriteString("ModifierReserved17Mask|")
		case ModifierReserved18Mask:
			builder.WriteString("ModifierReserved18Mask|")
		case ModifierReserved19Mask:
			builder.WriteString("ModifierReserved19Mask|")
		case ModifierReserved20Mask:
			builder.WriteString("ModifierReserved20Mask|")
		case ModifierReserved21Mask:
			builder.WriteString("ModifierReserved21Mask|")
		case ModifierReserved22Mask:
			builder.WriteString("ModifierReserved22Mask|")
		case ModifierReserved23Mask:
			builder.WriteString("ModifierReserved23Mask|")
		case ModifierReserved24Mask:
			builder.WriteString("ModifierReserved24Mask|")
		case ModifierReserved25Mask:
			builder.WriteString("ModifierReserved25Mask|")
		case SuperMask:
			builder.WriteString("SuperMask|")
		case HyperMask:
			builder.WriteString("HyperMask|")
		case MetaMask:
			builder.WriteString("MetaMask|")
		case ModifierReserved29Mask:
			builder.WriteString("ModifierReserved29Mask|")
		case ReleaseMask:
			builder.WriteString("ReleaseMask|")
		case ModifierMask:
			builder.WriteString("ModifierMask|")
		default:
			builder.WriteString(fmt.Sprintf("ModifierType(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m ModifierType) Has(other ModifierType) bool {
	return (m & other) == other
}

// Point defines the x and y coordinates of a point.
//
// An instance of this type is always passed by reference.
type Point struct {
	*point
}

// point is the struct that's finalized.
type point struct {
	native unsafe.Pointer
}

var GIRInfoPoint = girepository.MustFind("Gdk", "Point")

// NewPoint creates a new Point instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewPoint(x, y int) Point {
	var f0 C.gint // out
	f0 = C.gint(x)
	var f1 C.gint // out
	f1 = C.gint(y)

	size := GIRInfoPoint.StructSize()
	native := make([]byte, size)
	gextras.Sink(&native[0])

	offset0 := GIRInfoPoint.StructFieldOffset("x")
	valptr0 := (*C.gint)(unsafe.Add(unsafe.Pointer(&native[0]), offset0))
	*valptr0 = f0

	offset1 := GIRInfoPoint.StructFieldOffset("y")
	valptr1 := (*C.gint)(unsafe.Add(unsafe.Pointer(&native[0]), offset1))
	*valptr1 = f1

	return *(*Point)(gextras.NewStructNative(unsafe.Pointer(&native[0])))
}

// X: x coordinate of the point.
func (p *Point) X() int {
	offset := GIRInfoPoint.StructFieldOffset("x")
	valptr := (*int)(unsafe.Add(p.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Y: y coordinate of the point.
func (p *Point) Y() int {
	offset := GIRInfoPoint.StructFieldOffset("y")
	valptr := (*int)(unsafe.Add(p.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

// X: x coordinate of the point.
func (p *Point) SetX(x int) {
	offset := GIRInfoPoint.StructFieldOffset("x")
	valptr := (*C.gint)(unsafe.Add(p.native, offset))
	*valptr = C.gint(x)
}

// Y: y coordinate of the point.
func (p *Point) SetY(y int) {
	offset := GIRInfoPoint.StructFieldOffset("y")
	valptr := (*C.gint)(unsafe.Add(p.native, offset))
	*valptr = C.gint(y)
}

// Rectangle defines the position and size of a rectangle. It is identical to
// #cairo_rectangle_int_t.
//
// An instance of this type is always passed by reference.
type Rectangle struct {
	*rectangle
}

// rectangle is the struct that's finalized.
type rectangle struct {
	native unsafe.Pointer
}

var GIRInfoRectangle = girepository.MustFind("Gdk", "Rectangle")

func marshalRectangle(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Rectangle{&rectangle{(unsafe.Pointer)(b)}}, nil
}

// NewRectangle creates a new Rectangle instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewRectangle(x, y, width, height int) Rectangle {
	var f0 C.int // out
	f0 = C.int(x)
	var f1 C.int // out
	f1 = C.int(y)
	var f2 C.int // out
	f2 = C.int(width)
	var f3 C.int // out
	f3 = C.int(height)

	size := GIRInfoRectangle.StructSize()
	native := make([]byte, size)
	gextras.Sink(&native[0])

	offset0 := GIRInfoRectangle.StructFieldOffset("x")
	valptr0 := (*C.int)(unsafe.Add(unsafe.Pointer(&native[0]), offset0))
	*valptr0 = f0

	offset1 := GIRInfoRectangle.StructFieldOffset("y")
	valptr1 := (*C.int)(unsafe.Add(unsafe.Pointer(&native[0]), offset1))
	*valptr1 = f1

	offset2 := GIRInfoRectangle.StructFieldOffset("width")
	valptr2 := (*C.int)(unsafe.Add(unsafe.Pointer(&native[0]), offset2))
	*valptr2 = f2

	offset3 := GIRInfoRectangle.StructFieldOffset("height")
	valptr3 := (*C.int)(unsafe.Add(unsafe.Pointer(&native[0]), offset3))
	*valptr3 = f3

	return *(*Rectangle)(gextras.NewStructNative(unsafe.Pointer(&native[0])))
}

func (r *Rectangle) X() int {
	offset := GIRInfoRectangle.StructFieldOffset("x")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (r *Rectangle) Y() int {
	offset := GIRInfoRectangle.StructFieldOffset("y")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (r *Rectangle) Width() int {
	offset := GIRInfoRectangle.StructFieldOffset("width")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (r *Rectangle) Height() int {
	offset := GIRInfoRectangle.StructFieldOffset("height")
	valptr := (*int)(unsafe.Add(r.native, offset))
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (r *Rectangle) SetX(x int) {
	offset := GIRInfoRectangle.StructFieldOffset("x")
	valptr := (*C.int)(unsafe.Add(r.native, offset))
	*valptr = C.int(x)
}

func (r *Rectangle) SetY(y int) {
	offset := GIRInfoRectangle.StructFieldOffset("y")
	valptr := (*C.int)(unsafe.Add(r.native, offset))
	*valptr = C.int(y)
}

func (r *Rectangle) SetWidth(width int) {
	offset := GIRInfoRectangle.StructFieldOffset("width")
	valptr := (*C.int)(unsafe.Add(r.native, offset))
	*valptr = C.int(width)
}

func (r *Rectangle) SetHeight(height int) {
	offset := GIRInfoRectangle.StructFieldOffset("height")
	valptr := (*C.int)(unsafe.Add(r.native, offset))
	*valptr = C.int(height)
}
