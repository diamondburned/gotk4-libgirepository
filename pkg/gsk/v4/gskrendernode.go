// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeRenderNode = coreglib.Type(girepository.MustFind("Gsk", "RenderNode").RegisteredGType())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRenderNode, F: marshalRenderNode},
	})
}

// ParseErrorFunc: type of callback that is called when an error occurs during
// node deserialization.
type ParseErrorFunc func(start, end *ParseLocation, err error)

// RenderNode: GskRenderNode is the basic block in a scene graph to be rendered
// using GskRenderer.
//
// Each node has a parent, except the top-level node; each node may have
// children nodes.
//
// Each node has an associated drawing surface, which has the size of the
// rectangle set when creating it.
//
// Render nodes are meant to be transient; once they have been associated to a
// gsk.Renderer it's safe to release any reference you have on them. All
// gsk.RenderNodes are immutable, you can only specify their properties during
// construction.
type RenderNode struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RenderNode)(nil)
)

// RenderNoder describes types inherited from class RenderNode.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RenderNoder interface {
	coreglib.Objector
	baseRenderNode() *RenderNode
}

var _ RenderNoder = (*RenderNode)(nil)

func wrapRenderNode(obj *coreglib.Object) *RenderNode {
	return &RenderNode{
		Object: obj,
	}
}

func marshalRenderNode(p uintptr) (interface{}, error) {
	return wrapRenderNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *RenderNode) baseRenderNode() *RenderNode {
	return v
}

// BaseRenderNode returns the underlying base object.
func BaseRenderNode(obj RenderNoder) *RenderNode {
	return obj.baseRenderNode()
}

// ColorStop: color stop in a gradient node.
//
// An instance of this type is always passed by reference.
type ColorStop struct {
	*colorStop
}

// colorStop is the struct that's finalized.
type colorStop struct {
	native unsafe.Pointer
}

var GIRInfoColorStop = girepository.MustFind("Gsk", "ColorStop")

// ParseLocation: location in a parse buffer.
//
// An instance of this type is always passed by reference.
type ParseLocation struct {
	*parseLocation
}

// parseLocation is the struct that's finalized.
type parseLocation struct {
	native unsafe.Pointer
}

var GIRInfoParseLocation = girepository.MustFind("Gsk", "ParseLocation")

// NewParseLocation creates a new ParseLocation instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewParseLocation(bytes, chars, lines, lineBytes, lineChars uint) ParseLocation {
	var f0 C.gsize // out
	f0 = C.gsize(bytes)
	var f1 C.gsize // out
	f1 = C.gsize(chars)
	var f2 C.gsize // out
	f2 = C.gsize(lines)
	var f3 C.gsize // out
	f3 = C.gsize(lineBytes)
	var f4 C.gsize // out
	f4 = C.gsize(lineChars)

	size := GIRInfoParseLocation.StructSize()
	native := make([]byte, size)
	gextras.Sink(&native[0])

	offset0 := GIRInfoParseLocation.StructFieldOffset("bytes")
	valptr0 := (*C.gsize)(unsafe.Add(unsafe.Pointer(&native[0]), offset0))
	*valptr0 = f0

	offset1 := GIRInfoParseLocation.StructFieldOffset("chars")
	valptr1 := (*C.gsize)(unsafe.Add(unsafe.Pointer(&native[0]), offset1))
	*valptr1 = f1

	offset2 := GIRInfoParseLocation.StructFieldOffset("lines")
	valptr2 := (*C.gsize)(unsafe.Add(unsafe.Pointer(&native[0]), offset2))
	*valptr2 = f2

	offset3 := GIRInfoParseLocation.StructFieldOffset("line_bytes")
	valptr3 := (*C.gsize)(unsafe.Add(unsafe.Pointer(&native[0]), offset3))
	*valptr3 = f3

	offset4 := GIRInfoParseLocation.StructFieldOffset("line_chars")
	valptr4 := (*C.gsize)(unsafe.Add(unsafe.Pointer(&native[0]), offset4))
	*valptr4 = f4

	return *(*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(&native[0])))
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) Bytes() uint {
	offset := GIRInfoParseLocation.StructFieldOffset("bytes")
	valptr := (*uint)(unsafe.Add(p.native, offset))
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) Chars() uint {
	offset := GIRInfoParseLocation.StructFieldOffset("chars")
	valptr := (*uint)(unsafe.Add(p.native, offset))
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) Lines() uint {
	offset := GIRInfoParseLocation.StructFieldOffset("lines")
	valptr := (*uint)(unsafe.Add(p.native, offset))
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) LineBytes() uint {
	offset := GIRInfoParseLocation.StructFieldOffset("line_bytes")
	valptr := (*uint)(unsafe.Add(p.native, offset))
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) LineChars() uint {
	offset := GIRInfoParseLocation.StructFieldOffset("line_chars")
	valptr := (*uint)(unsafe.Add(p.native, offset))
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) SetBytes(bytes uint) {
	offset := GIRInfoParseLocation.StructFieldOffset("bytes")
	valptr := (*C.gsize)(unsafe.Add(p.native, offset))
	*valptr = C.gsize(bytes)
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) SetChars(chars uint) {
	offset := GIRInfoParseLocation.StructFieldOffset("chars")
	valptr := (*C.gsize)(unsafe.Add(p.native, offset))
	*valptr = C.gsize(chars)
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) SetLines(lines uint) {
	offset := GIRInfoParseLocation.StructFieldOffset("lines")
	valptr := (*C.gsize)(unsafe.Add(p.native, offset))
	*valptr = C.gsize(lines)
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) SetLineBytes(lineBytes uint) {
	offset := GIRInfoParseLocation.StructFieldOffset("line_bytes")
	valptr := (*C.gsize)(unsafe.Add(p.native, offset))
	*valptr = C.gsize(lineBytes)
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) SetLineChars(lineChars uint) {
	offset := GIRInfoParseLocation.StructFieldOffset("line_chars")
	valptr := (*C.gsize)(unsafe.Add(p.native, offset))
	*valptr = C.gsize(lineChars)
}

// Shadow: shadow parameters in a shadow node.
//
// An instance of this type is always passed by reference.
type Shadow struct {
	*shadow
}

// shadow is the struct that's finalized.
type shadow struct {
	native unsafe.Pointer
}

var GIRInfoShadow = girepository.MustFind("Gsk", "Shadow")
